diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt
index 70912a9..006f7d8 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt
@@ -48,6 +48,32 @@ class DataStorePrefsStorage(
     return ResultSet(cipherStorageName, bytesForUsername, bytesForPassword)
   }
 
+  override fun getAllEncryptedEntries(): MutableList<Map<String, Any?>> {
+    val processedServices = mutableListOf<String>()
+    val data = mutableListOf<Map<String, Any?>>()
+    runBlocking {
+      val allKeys = prefsData.asMap().keys
+      for (key in allKeys) {
+        val keyName = key.name
+        if (keyName.length >= 2) {
+          val serviceName = keyName.substring(0, keyName.length - 2)
+          if (!processedServices.contains(serviceName)) {
+            val item = getEncryptedEntry(serviceName)
+            if (item != null) {
+              val map = mapOf(
+                "resultSet" to item,
+                "service" to serviceName
+              )
+              data.add(map)
+              processedServices.add(serviceName)
+            }
+          }
+        }
+      }
+    }
+    return data
+  }
+
   override fun removeEntry(service: String) {
     val keyForUsername = stringPreferencesKey(getKeyForUsername(service))
     val keyForPassword = stringPreferencesKey(getKeyForPassword(service))
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt
index 722a5ed..0cb4ec3 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt
@@ -281,6 +281,49 @@ class KeychainModule(reactContext: ReactApplicationContext) :
     }
   }
 
+  @ReactMethod
+  fun getAllInternetCredentialsForServer(options: ReadableMap, promise: Promise) {
+    coroutineScope.launch {
+      mutex.withLock {
+        try {
+          val accessControl = getAccessControlOrDefault(options)
+          val usePasscode = getUsePasscode(accessControl) && isPasscodeAvailable
+          val useBiometry =
+            getUseBiometry(accessControl) && (isFingerprintAuthAvailable || isFaceAuthAvailable || isIrisAuthAvailable)
+          val allCredentials = Arguments.createArray()
+          val currentCipherStorage = getCipherStorageForCurrentAPILevel(useBiometry, usePasscode)
+          val allResults = prefsStorage.getAllEncryptedEntries()
+
+          for (data in allResults) {
+            val resultSet = data["resultSet"] as PrefsStorageBase.ResultSet
+            val service = data["service"] as String
+            val promptInfo = getPromptInfo(options, usePasscode, useBiometry)
+            val decryptionResult =
+              decryptCredentials(service, currentCipherStorage, resultSet, promptInfo)
+
+            val credentials = Arguments.createMap().apply {
+              putString("service", service)
+              putString("username", decryptionResult.username)
+              putString("password", decryptionResult.password)
+            }
+            allCredentials.pushMap(credentials)
+          }
+
+          val result = Arguments.createMap().apply {
+            putArray("results", allCredentials)
+          }
+          promise.resolve(result)
+        } catch (e: KeyStoreAccessException) {
+          e.message?.let { Log.e(KEYCHAIN_MODULE, it) }
+          promise.reject(Errors.E_KEYSTORE_ACCESS_ERROR, e)
+        } catch (e: CryptoFailedException) {
+          e.message?.let { Log.e(KEYCHAIN_MODULE, it) }
+          promise.reject(Errors.E_CRYPTO_FAILED, e)
+        }
+      }
+    }
+  }
+
   @ReactMethod
   fun getAllGenericPasswordServices(options: ReadableMap?, promise: Promise) {
     try {
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt
index d165f3e..91fd8b1 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt
@@ -13,6 +13,8 @@ interface PrefsStorageBase {
 
   fun getEncryptedEntry(service: String): ResultSet?
 
+  fun getAllEncryptedEntries(): MutableList<Map<String, Any?>>
+
   fun removeEntry(service: String)
 
   fun storeEncryptedEntry(service: String, encryptionResult: EncryptionResult)
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/resultHandler/ResultHandlerInteractiveDeviceCredential.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/resultHandler/ResultHandlerInteractiveDeviceCredential.kt
new file mode 100644
index 0000000..218ec3c
--- /dev/null
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/resultHandler/ResultHandlerInteractiveDeviceCredential.kt
@@ -0,0 +1,156 @@
+package com.oblador.keychain.resultHandler
+
+import android.app.Activity
+import android.app.KeyguardManager
+import android.content.Context
+import android.content.Intent
+import android.os.Build
+import android.os.Handler
+import android.os.Looper
+import android.util.Log
+import androidx.biometric.BiometricPrompt
+import com.facebook.react.bridge.BaseActivityEventListener
+import com.facebook.react.bridge.ReactApplicationContext
+import com.oblador.keychain.cipherStorage.CipherStorage
+import com.oblador.keychain.cipherStorage.CipherStorageBase
+import com.oblador.keychain.exceptions.CryptoFailedException
+import java.util.concurrent.locks.ReentrantLock
+import kotlin.concurrent.withLock
+
+class ResultHandlerInteractiveDeviceCredential(
+  private val reactContext: ReactApplicationContext,
+  private val storage: CipherStorage,
+  private var promptInfo: BiometricPrompt.PromptInfo
+) : ResultHandler {
+  override var decryptionResult: CipherStorage.DecryptionResult? = null
+  override var encryptionResult: CipherStorage.EncryptionResult? = null
+  override var error: Throwable? = null
+
+  private var context: CryptoContext? = null
+  private val lock = ReentrantLock()
+  private val condition = lock.newCondition()
+
+  private val LOG_TAG = ResultHandlerInteractiveDeviceCredential::class.java.simpleName
+
+  private val REQUEST_CODE = 49127
+
+  private val activityEventListener = object : BaseActivityEventListener() {
+    override fun onActivityResult(activity: Activity?, requestCode: Int, resultCode: Int, data: Intent?) {
+      if (requestCode == REQUEST_CODE) {
+        if (resultCode == Activity.RESULT_OK) {
+          onAuthenticationSucceeded()
+        } else {
+          val failure = CryptoFailedException("User canceled or failed device credential authentication")
+          when (context?.operation) {
+            CryptoOperation.ENCRYPT -> onEncrypt(null, failure)
+            CryptoOperation.DECRYPT -> onDecrypt(null, failure)
+            null -> Log.e(LOG_TAG, "No operation context available")
+          }
+        }
+      }
+    }
+  }
+
+  init {
+    reactContext.addActivityEventListener(activityEventListener)
+  }
+
+  override fun askAccessPermissions(context: CryptoContext) {
+    this.context = context
+
+    startAuthentication()
+  }
+
+  /** Trigger interactive authentication. */
+  fun startAuthentication() {
+    val activity = reactContext.currentActivity ?: throw NullPointerException("Not assigned current activity")
+
+    // Code can be executed only from MAIN thread
+    if (Thread.currentThread() != Looper.getMainLooper().thread) {
+      activity.runOnUiThread { startAuthentication() }
+      waitResult()
+      return
+    }
+
+    val keyguardManager = reactContext.getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
+
+    val intent = keyguardManager.createConfirmDeviceCredentialIntent(
+      promptInfo.title,
+      promptInfo.description
+    )
+
+    if (intent == null) {
+      val failure = CryptoFailedException("Failed to create credential intent")
+      when (context?.operation) {
+        CryptoOperation.ENCRYPT -> onEncrypt(null, failure)
+        CryptoOperation.DECRYPT -> onDecrypt(null, failure)
+        null -> Log.e(LOG_TAG, "No operation context available")
+      }
+      return
+    }
+
+    activity.startActivityForResult(intent, REQUEST_CODE)
+  }
+
+  private fun onAuthenticationSucceeded() {
+    try {
+      val ctx = context ?: throw NullPointerException("Crypto context is not assigned yet.")
+      val key = ctx.key
+      val storageBase = storage as CipherStorageBase
+
+      when (ctx.operation) {
+        CryptoOperation.ENCRYPT -> {
+          val encrypted = CipherStorage.EncryptionResult(
+            storageBase.encryptString(key, String(ctx.username)),
+            storageBase.encryptString(key, String(ctx.password)),
+            storageBase
+          )
+          onEncrypt(encrypted, null)
+        }
+        CryptoOperation.DECRYPT -> {
+          val decrypted = CipherStorage.DecryptionResult(
+            storageBase.decryptBytes(key, ctx.username),
+            storageBase.decryptBytes(key, ctx.password)
+          )
+          onDecrypt(decrypted, null)
+        }
+      }
+    } catch (e: Throwable) {
+      when (context?.operation) {
+        CryptoOperation.ENCRYPT -> onEncrypt(null, e)
+        CryptoOperation.DECRYPT -> onDecrypt(null, e)
+        null -> Log.e(LOG_TAG, "No operation context available")
+      }
+    }
+  }
+
+  override fun onEncrypt(encryptionResult: CipherStorage.EncryptionResult?, error: Throwable?) {
+    lock.withLock {
+      this.encryptionResult = encryptionResult
+      this.error = error
+      condition.signalAll()
+    }
+  }
+
+  override fun onDecrypt(decryptionResult: CipherStorage.DecryptionResult?, error: Throwable?) {
+    lock.withLock {
+      this.decryptionResult = decryptionResult
+      this.error = error
+      condition.signalAll()
+    }
+  }
+
+  override fun waitResult() {
+    if (Thread.currentThread() == Looper.getMainLooper().thread) {
+      throw IllegalStateException("waitResult() should not be called from main thread")
+    }
+
+    Log.i(LOG_TAG, "Blocking thread for credential prompt result")
+
+    lock.withLock {
+      condition.await()
+    }
+
+    Log.i(LOG_TAG, "Resuming thread after credential prompt result")
+  }
+}
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/resultHandler/ResultHandlerProvider.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/resultHandler/ResultHandlerProvider.kt
index dd89f83..f462440 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/resultHandler/ResultHandlerProvider.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/resultHandler/ResultHandlerProvider.kt
@@ -4,6 +4,7 @@ import android.os.Build
 import androidx.biometric.BiometricPrompt
 import com.facebook.react.bridge.ReactApplicationContext
 import com.oblador.keychain.cipherStorage.CipherStorage
+import com.oblador.keychain.DeviceAvailability
 
 // NOTE: the logic for handling OnePlus bug is taken from the following forum post:
 // https://forums.oneplus.com/threads/oneplus-7-pro-fingerprint-biometricprompt-does-not-show.1035821/#post-21710422
@@ -39,7 +40,13 @@ object ResultHandlerProvider {
     promptInfo: BiometricPrompt.PromptInfo
   ): ResultHandler {
     return if (storage.isAuthSupported()) {
-      if (hasOnePlusBiometricBug()) {
+      if (!DeviceAvailability.isStrongBiometricAuthAvailable(reactContext)) {
+        ResultHandlerInteractiveDeviceCredential(
+          reactContext,
+          storage,
+          promptInfo
+        )
+      } else if (hasOnePlusBiometricBug()) {
         ResultHandlerInteractiveBiometricManualRetry(reactContext, storage, promptInfo)
       } else {
         ResultHandlerInteractiveBiometric(reactContext, storage, promptInfo)
diff --git a/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m b/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m
index 6888ff0..23675f3 100644
--- a/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m
+++ b/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m
@@ -519,6 +519,86 @@ - (OSStatus)deleteCredentialsForServer:(NSString *)server withOptions:(NSDiction
   return resolve([result copy]);
 }
 
+RCT_EXPORT_METHOD(getAllInternetCredentialsForServer:(NSDictionary *)options resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
+{
+  NSDictionary *query = @{
+    (__bridge NSString *)kSecClass: (__bridge id)(kSecClassInternetPassword),
+    (__bridge NSString *)kSecReturnAttributes: (__bridge id)kCFBooleanTrue,
+    (__bridge NSString *)kSecReturnData: (__bridge id)kCFBooleanTrue,
+    (__bridge NSString *)kSecMatchLimit: (__bridge NSString *)kSecMatchLimitAll
+  };
+
+  // Look up server in the keychain
+  NSArray *found = nil;
+  CFTypeRef foundTypeRef = NULL;
+  OSStatus osStatus = SecItemCopyMatching((__bridge CFDictionaryRef) query, (CFTypeRef*)&foundTypeRef);
+
+  if (osStatus != noErr && osStatus != errSecItemNotFound) {
+    NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:osStatus userInfo:nil];
+    return rejectWithError(reject, error);
+  }
+
+  found = (__bridge NSArray*)(foundTypeRef);
+  if (!found) {
+    return resolve(@(NO));
+  }
+
+  NSMutableArray *results = [@[] mutableCopy];
+
+  for(int i=0; i< found.count; i++){
+      NSDictionary *item  = found[i];
+      NSString *server = (NSString *) [item objectForKey:(__bridge id)(kSecAttrServer)];
+      NSString *username = (NSString *) [item objectForKey:(__bridge id)(kSecAttrAccount)];
+        NSString *password = [[NSString alloc] initWithData:[item objectForKey:(__bridge id)(kSecValueData)] encoding:NSUTF8StringEncoding];
+
+        [results addObject:@{@"username": username, @"password":password, @"server": server}];
+  }
+
+  CFRelease(foundTypeRef);
+
+  return resolve(@{
+    @"results": results
+  });
+}
+
+RCT_EXPORT_METHOD(getAllInternetCredentialsKeys:(NSDictionary *)options resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
+{
+  NSDictionary *query = @{
+    (__bridge NSString *)kSecClass: (__bridge id)(kSecClassInternetPassword),
+    (__bridge NSString *)kSecReturnAttributes: (__bridge id)kCFBooleanTrue,
+    (__bridge NSString *)kSecMatchLimit: (__bridge NSString *)kSecMatchLimitAll
+  };
+
+  // Look up all the keys in the keychain
+  NSArray *found = nil;
+  CFTypeRef foundTypeRef = NULL;
+  OSStatus osStatus = SecItemCopyMatching((__bridge CFDictionaryRef) query, (CFTypeRef*)&foundTypeRef);
+
+  if (osStatus != noErr && osStatus != errSecItemNotFound) {
+    NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:osStatus userInfo:nil];
+    return rejectWithError(reject, error);
+  }
+
+  found = (__bridge NSArray*)(foundTypeRef);
+  if (!found) {
+    return resolve(@(NO));
+  }
+
+  NSMutableArray *results = [@[] mutableCopy];
+
+  for(int i=0; i< found.count; i++){
+      NSDictionary *item  = found[i];
+      NSString *username = (NSString *) [item objectForKey:(__bridge id)(kSecAttrAccount)];
+      [results addObject:username];
+  }
+
+  CFRelease(foundTypeRef);
+
+  return resolve(@{
+    @"results": results
+  });
+}
+
 RCT_EXPORT_METHOD(resetGenericPasswordForOptions:(NSDictionary *)options
                   resolver:(RCTPromiseResolveBlock)resolve
                   rejecter:(RCTPromiseRejectBlock)reject)
diff --git a/node_modules/react-native-keychain/lib/commonjs/index.js b/node_modules/react-native-keychain/lib/commonjs/index.js
index da7ccb9..a49f39f 100644
--- a/node_modules/react-native-keychain/lib/commonjs/index.js
+++ b/node_modules/react-native-keychain/lib/commonjs/index.js
@@ -12,6 +12,8 @@ var _exportNames = {
   hasInternetCredentials: true,
   setInternetCredentials: true,
   getInternetCredentials: true,
+  getAllInternetCredentials: true,
+  getAllInternetCredentialsKeys: true,
   resetInternetCredentials: true,
   getSupportedBiometryType: true,
   requestSharedWebCredentials: true,
@@ -25,6 +27,8 @@ exports.default = void 0;
 exports.getAllGenericPasswordServices = getAllGenericPasswordServices;
 exports.getGenericPassword = getGenericPassword;
 exports.getInternetCredentials = getInternetCredentials;
+exports.getAllInternetCredentials = getAllInternetCredentials;
+exports.getAllInternetCredentialsKeys = getAllInternetCredentialsKeys;
 exports.getSecurityLevel = getSecurityLevel;
 exports.getSupportedBiometryType = getSupportedBiometryType;
 exports.hasGenericPassword = hasGenericPassword;
@@ -212,6 +216,24 @@ function getInternetCredentials(server, options) {
   return RNKeychainManager.getInternetCredentialsForServer(server, (0, _normalizeOptions.normalizeAuthPrompt)(options));
 }
 
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+function getAllInternetCredentials(options) {
+  return RNKeychainManager.getAllInternetCredentialsForServer(normalizeOptions(options));
+}
+
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+function getAllInternetCredentialsKeys(options) {
+  return RNKeychainManager.getAllInternetCredentialsKeys(normalizeOptions(options));
+}
+
 /**
  * Deletes all internet password keychain entries for the given server.
  *
@@ -370,6 +392,8 @@ var _default = exports.default = {
   setInternetCredentials,
   isPasscodeAuthAvailable,
   getInternetCredentials,
+  getAllInternetCredentials,
+  getAllInternetCredentialsKeys,
   resetInternetCredentials,
   setGenericPassword,
   getGenericPassword,
diff --git a/node_modules/react-native-keychain/lib/module/index.js b/node_modules/react-native-keychain/lib/module/index.js
index b4f2bb6..789a1de 100644
--- a/node_modules/react-native-keychain/lib/module/index.js
+++ b/node_modules/react-native-keychain/lib/module/index.js
@@ -153,6 +153,24 @@ export function getInternetCredentials(server, options) {
   return RNKeychainManager.getInternetCredentialsForServer(server, normalizeAuthPrompt(options));
 }
 
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+export function getAllInternetCredentials(options) {
+  return RNKeychainManager.getAllInternetCredentialsForServer(normalizeOptions(options));
+}
+
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+export function getAllInternetCredentialsKeys(options) {
+  return RNKeychainManager.getAllInternetCredentialsKeys(normalizeOptions(options));
+}
+
 /**
  * Deletes all internet password keychain entries for the given server.
  *
diff --git a/node_modules/react-native-keychain/lib/typescript/index.d.ts b/node_modules/react-native-keychain/lib/typescript/index.d.ts
index b868899..22936b2 100644
--- a/node_modules/react-native-keychain/lib/typescript/index.d.ts
+++ b/node_modules/react-native-keychain/lib/typescript/index.d.ts
@@ -1,5 +1,5 @@
 import { ACCESSIBLE, ACCESS_CONTROL, AUTHENTICATION_TYPE, SECURITY_LEVEL, STORAGE_TYPE, BIOMETRY_TYPE } from './enums';
-import type { Result, UserCredentials, SharedWebCredentials, GetOptions, GetAllOptions, BaseOptions, SetOptions, AuthenticationTypeOption, AccessControlOption } from './types';
+import type { Result, UserCredentials, SharedWebCredentials, GetOptions, GetAllOptions, BaseOptions, SetOptions, AuthenticationTypeOption, AccessControlOption, AllCredentials, AllCredentialsKeys } from './types';
 /**
  * Saves the `username` and `password` combination for the given service.
  *
@@ -135,6 +135,18 @@ export declare function getInternetCredentials(server: string, options?: GetOpti
  * console.log('Credentials reset for server');
  * ```
  */
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+export declare function getAllInternetCredentials(options?: GetOptions): Promise<false | AllCredentials>;
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+export declare function getAllInternetCredentialsKeys(options?: GetOptions): Promise<false | AllCredentialsKeys>;
 export declare function resetInternetCredentials(options: BaseOptions): Promise<void>;
 /**
  * Gets the type of biometric authentication supported by the device.
diff --git a/node_modules/react-native-keychain/lib/typescript/types.d.ts b/node_modules/react-native-keychain/lib/typescript/types.d.ts
index ff6a12e..0bc4135 100644
--- a/node_modules/react-native-keychain/lib/typescript/types.d.ts
+++ b/node_modules/react-native-keychain/lib/typescript/types.d.ts
@@ -111,6 +111,21 @@ export type UserCredentials = {
     /** The password associated with the keychain item. */
     password: string;
 } & Result;
+
+/**
+ * All credentials returned by keychain functions.
+ */
+export type AllCredentials = {
+    results: UserCredentials[];
+};
+
+/**
+ * All credentials keys returned by keychain functions.
+ */
+export type AllCredentialsKeys = {
+    results: string[];
+};
+
 /**
  * Shared web credentials returned by keychain functions.
  * @platform iOS
diff --git a/node_modules/react-native-keychain/src/index.ts b/node_modules/react-native-keychain/src/index.ts
index 1de35da..08eeb88 100644
--- a/node_modules/react-native-keychain/src/index.ts
+++ b/node_modules/react-native-keychain/src/index.ts
@@ -17,6 +17,8 @@ import type {
   SetOptions,
   AuthenticationTypeOption,
   AccessControlOption,
+  AllCredentials,
+  AllCredentialsKeys,
 } from './types';
 import { normalizeAuthPrompt } from './normalizeOptions';
 
@@ -200,6 +202,32 @@ export function getInternetCredentials(
   );
 }
 
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+export function getAllInternetCredentials(
+  options?: GetOptions
+): Promise<false | AllCredentials> {
+  return RNKeychainManager.getAllInternetCredentialsForServer(
+    normalizeAuthPrompt(options)
+  );
+}
+
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+export function getAllInternetCredentialsKeys(
+  options?: GetOptions
+): Promise<false | AllCredentialsKeys> {
+  return RNKeychainManager.getAllInternetCredentialsKeys(
+    normalizeAuthPrompt(options)
+  );
+}
+
 /**
  * Deletes all internet password keychain entries for the given server.
  *
@@ -384,6 +412,8 @@ export default {
   setInternetCredentials,
   isPasscodeAuthAvailable,
   getInternetCredentials,
+  getAllInternetCredentials,
+  getAllInternetCredentialsKeys,
   resetInternetCredentials,
   setGenericPassword,
   getGenericPassword,
diff --git a/node_modules/react-native-keychain/src/normalizeOptions.ts b/node_modules/react-native-keychain/src/normalizeOptions.ts
index e72d2fb..ea4d3c7 100644
--- a/node_modules/react-native-keychain/src/normalizeOptions.ts
+++ b/node_modules/react-native-keychain/src/normalizeOptions.ts
@@ -12,10 +12,11 @@ export function normalizeAuthPrompt<T extends SetOptions | GetOptions>(
 ) {
   const { authenticationPrompt } = options;
 
-  options.authenticationPrompt = {
-    ...AUTH_PROMPT_DEFAULTS,
-    ...authenticationPrompt,
+  return {
+    ...options,
+    authenticationPrompt: {
+      ...AUTH_PROMPT_DEFAULTS,
+      ...authenticationPrompt,
+    },
   };
-
-  return options;
 }
diff --git a/node_modules/react-native-keychain/src/types.ts b/node_modules/react-native-keychain/src/types.ts
index 00448d3..4a6c58f 100644
--- a/node_modules/react-native-keychain/src/types.ts
+++ b/node_modules/react-native-keychain/src/types.ts
@@ -129,6 +129,20 @@ export type UserCredentials = {
   password: string;
 } & Result;
 
+/**
+ * All credentials returned by keychain functions.
+ */
+export type AllCredentials = {
+  results: UserCredentials[];
+};
+
+/**
+ * All credentials keys returned by keychain functions.
+ */
+export type AllCredentialsKeys = {
+  results: string[];
+};
+
 /**
  * Shared web credentials returned by keychain functions.
  * @platform iOS
