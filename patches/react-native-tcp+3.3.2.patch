diff --git a/node_modules/react-native-tcp/TcpSockets.podspec b/node_modules/react-native-tcp/TcpSockets.podspec
index 43ce35d..c1dd344 100644
--- a/node_modules/react-native-tcp/TcpSockets.podspec
+++ b/node_modules/react-native-tcp/TcpSockets.podspec
@@ -19,5 +19,6 @@ Pod::Spec.new do |s|
   s.preserve_paths = 'README.md', 'package.json', '**/*.js'
   s.source_files   = 'ios/**/*.{h,m}'
   s.dependency 'React'
+  s.dependency "CocoaAsyncSocket"
 
 end
diff --git a/node_modules/react-native-tcp/android/build.gradle b/node_modules/react-native-tcp/android/build.gradle
index c582eb7..5785289 100644
--- a/node_modules/react-native-tcp/android/build.gradle
+++ b/node_modules/react-native-tcp/android/build.gradle
@@ -44,6 +44,6 @@ repositories {
 }
 
 dependencies {
-    compile 'com.facebook.react:react-native:+'
-    compile 'com.koushikdutta.async:androidasync:2.1.6'
+    implementation 'com.facebook.react:react-native:+'
+    implementation 'com.koushikdutta.async:androidasync:2.1.6'
 }
diff --git a/node_modules/react-native-tcp/android/build/.transforms/d2695092db081b3b8eec61cbb982e3ef/results.bin b/node_modules/react-native-tcp/android/build/.transforms/d2695092db081b3b8eec61cbb982e3ef/results.bin
new file mode 100644
index 0000000..0d259dd
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/.transforms/d2695092db081b3b8eec61cbb982e3ef/results.bin
@@ -0,0 +1 @@
+o/classes
diff --git a/node_modules/react-native-tcp/android/build/.transforms/d2695092db081b3b8eec61cbb982e3ef/transformed/classes/classes.dex b/node_modules/react-native-tcp/android/build/.transforms/d2695092db081b3b8eec61cbb982e3ef/transformed/classes/classes.dex
new file mode 100644
index 0000000..9ab8151
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/.transforms/d2695092db081b3b8eec61cbb982e3ef/transformed/classes/classes.dex differ
diff --git a/node_modules/react-native-tcp/android/build/generated/source/buildConfig/debug/com/peel/react/BuildConfig.java b/node_modules/react-native-tcp/android/build/generated/source/buildConfig/debug/com/peel/react/BuildConfig.java
new file mode 100644
index 0000000..8602bda
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/generated/source/buildConfig/debug/com/peel/react/BuildConfig.java
@@ -0,0 +1,10 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package com.peel.react;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String LIBRARY_PACKAGE_NAME = "com.peel.react";
+  public static final String BUILD_TYPE = "debug";
+}
diff --git a/node_modules/react-native-tcp/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml b/node_modules/react-native-tcp/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml
new file mode 100644
index 0000000..68a94ae
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.peel.react" >
+
+    <uses-sdk
+        android:minSdkVersion="21"
+        android:targetSdkVersion="31" />
+
+    <uses-permission android:name="android.permission.INTERNET" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json b/node_modules/react-native-tcp/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json
new file mode 100644
index 0000000..824c932
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json
@@ -0,0 +1,18 @@
+{
+  "version": 3,
+  "artifactType": {
+    "type": "AAPT_FRIENDLY_MERGED_MANIFESTS",
+    "kind": "Directory"
+  },
+  "applicationId": "com.peel.react",
+  "variantName": "debug",
+  "elements": [
+    {
+      "type": "SINGLE",
+      "filters": [],
+      "attributes": [],
+      "outputFile": "AndroidManifest.xml"
+    }
+  ],
+  "elementType": "File"
+}
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/aar_metadata/debug/aar-metadata.properties b/node_modules/react-native-tcp/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
new file mode 100644
index 0000000..d8f70c0
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
@@ -0,0 +1,3 @@
+aarFormatVersion=1.0
+aarMetadataVersion=1.0
+minCompileSdk=1
diff --git a/node_modules/react-native-tcp/android/build/intermediates/annotation_processor_list/debug/annotationProcessors.json b/node_modules/react-native-tcp/android/build/intermediates/annotation_processor_list/debug/annotationProcessors.json
new file mode 100644
index 0000000..9e26dfe
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/annotation_processor_list/debug/annotationProcessors.json
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/compile_library_classes_jar/debug/classes.jar b/node_modules/react-native-tcp/android/build/intermediates/compile_library_classes_jar/debug/classes.jar
new file mode 100644
index 0000000..7638228
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/compile_library_classes_jar/debug/classes.jar differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/compile_r_class_jar/debug/R.jar b/node_modules/react-native-tcp/android/build/intermediates/compile_r_class_jar/debug/R.jar
new file mode 100644
index 0000000..97c33af
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/compile_r_class_jar/debug/R.jar differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/compile_symbol_list/debug/R.txt b/node_modules/react-native-tcp/android/build/intermediates/compile_symbol_list/debug/R.txt
new file mode 100644
index 0000000..e7814ce
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/compile_symbol_list/debug/R.txt
@@ -0,0 +1,1860 @@
+int anim abc_fade_in 0x0
+int anim abc_fade_out 0x0
+int anim abc_grow_fade_in_from_bottom 0x0
+int anim abc_popup_enter 0x0
+int anim abc_popup_exit 0x0
+int anim abc_shrink_fade_out_from_bottom 0x0
+int anim abc_slide_in_bottom 0x0
+int anim abc_slide_in_top 0x0
+int anim abc_slide_out_bottom 0x0
+int anim abc_slide_out_top 0x0
+int anim abc_tooltip_enter 0x0
+int anim abc_tooltip_exit 0x0
+int anim catalyst_fade_in 0x0
+int anim catalyst_fade_out 0x0
+int anim catalyst_push_up_in 0x0
+int anim catalyst_push_up_out 0x0
+int anim catalyst_slide_down 0x0
+int anim catalyst_slide_up 0x0
+int attr actionBarDivider 0x0
+int attr actionBarItemBackground 0x0
+int attr actionBarPopupTheme 0x0
+int attr actionBarSize 0x0
+int attr actionBarSplitStyle 0x0
+int attr actionBarStyle 0x0
+int attr actionBarTabBarStyle 0x0
+int attr actionBarTabStyle 0x0
+int attr actionBarTabTextStyle 0x0
+int attr actionBarTheme 0x0
+int attr actionBarWidgetTheme 0x0
+int attr actionButtonStyle 0x0
+int attr actionDropDownStyle 0x0
+int attr actionLayout 0x0
+int attr actionMenuTextAppearance 0x0
+int attr actionMenuTextColor 0x0
+int attr actionModeBackground 0x0
+int attr actionModeCloseButtonStyle 0x0
+int attr actionModeCloseDrawable 0x0
+int attr actionModeCopyDrawable 0x0
+int attr actionModeCutDrawable 0x0
+int attr actionModeFindDrawable 0x0
+int attr actionModePasteDrawable 0x0
+int attr actionModePopupWindowStyle 0x0
+int attr actionModeSelectAllDrawable 0x0
+int attr actionModeShareDrawable 0x0
+int attr actionModeSplitBackground 0x0
+int attr actionModeStyle 0x0
+int attr actionModeWebSearchDrawable 0x0
+int attr actionOverflowButtonStyle 0x0
+int attr actionOverflowMenuStyle 0x0
+int attr actionProviderClass 0x0
+int attr actionViewClass 0x0
+int attr activityChooserViewStyle 0x0
+int attr actualImageResource 0x0
+int attr actualImageScaleType 0x0
+int attr actualImageUri 0x0
+int attr alertDialogButtonGroupStyle 0x0
+int attr alertDialogCenterButtons 0x0
+int attr alertDialogStyle 0x0
+int attr alertDialogTheme 0x0
+int attr allowStacking 0x0
+int attr alpha 0x0
+int attr alphabeticModifiers 0x0
+int attr arrowHeadLength 0x0
+int attr arrowShaftLength 0x0
+int attr autoCompleteTextViewStyle 0x0
+int attr autoSizeMaxTextSize 0x0
+int attr autoSizeMinTextSize 0x0
+int attr autoSizePresetSizes 0x0
+int attr autoSizeStepGranularity 0x0
+int attr autoSizeTextType 0x0
+int attr autofillInlineSuggestionChip 0x0
+int attr autofillInlineSuggestionEndIconStyle 0x0
+int attr autofillInlineSuggestionStartIconStyle 0x0
+int attr autofillInlineSuggestionSubtitle 0x0
+int attr autofillInlineSuggestionTitle 0x0
+int attr background 0x0
+int attr backgroundImage 0x0
+int attr backgroundSplit 0x0
+int attr backgroundStacked 0x0
+int attr backgroundTint 0x0
+int attr backgroundTintMode 0x0
+int attr barLength 0x0
+int attr borderlessButtonStyle 0x0
+int attr buttonBarButtonStyle 0x0
+int attr buttonBarNegativeButtonStyle 0x0
+int attr buttonBarNeutralButtonStyle 0x0
+int attr buttonBarPositiveButtonStyle 0x0
+int attr buttonBarStyle 0x0
+int attr buttonGravity 0x0
+int attr buttonIconDimen 0x0
+int attr buttonPanelSideLayout 0x0
+int attr buttonStyle 0x0
+int attr buttonStyleSmall 0x0
+int attr buttonTint 0x0
+int attr buttonTintMode 0x0
+int attr checkboxStyle 0x0
+int attr checkedTextViewStyle 0x0
+int attr closeIcon 0x0
+int attr closeItemLayout 0x0
+int attr collapseContentDescription 0x0
+int attr collapseIcon 0x0
+int attr color 0x0
+int attr colorAccent 0x0
+int attr colorBackgroundFloating 0x0
+int attr colorButtonNormal 0x0
+int attr colorControlActivated 0x0
+int attr colorControlHighlight 0x0
+int attr colorControlNormal 0x0
+int attr colorError 0x0
+int attr colorPrimary 0x0
+int attr colorPrimaryDark 0x0
+int attr colorSwitchThumbNormal 0x0
+int attr commitIcon 0x0
+int attr contentDescription 0x0
+int attr contentInsetEnd 0x0
+int attr contentInsetEndWithActions 0x0
+int attr contentInsetLeft 0x0
+int attr contentInsetRight 0x0
+int attr contentInsetStart 0x0
+int attr contentInsetStartWithNavigation 0x0
+int attr controlBackground 0x0
+int attr coordinatorLayoutStyle 0x0
+int attr customNavigationLayout 0x0
+int attr defaultQueryHint 0x0
+int attr dialogCornerRadius 0x0
+int attr dialogPreferredPadding 0x0
+int attr dialogTheme 0x0
+int attr displayOptions 0x0
+int attr divider 0x0
+int attr dividerHorizontal 0x0
+int attr dividerPadding 0x0
+int attr dividerVertical 0x0
+int attr drawableSize 0x0
+int attr drawerArrowStyle 0x0
+int attr dropDownListViewStyle 0x0
+int attr dropdownListPreferredItemHeight 0x0
+int attr editTextBackground 0x0
+int attr editTextColor 0x0
+int attr editTextStyle 0x0
+int attr elevation 0x0
+int attr expandActivityOverflowButtonDrawable 0x0
+int attr fadeDuration 0x0
+int attr failureImage 0x0
+int attr failureImageScaleType 0x0
+int attr firstBaselineToTopHeight 0x0
+int attr font 0x0
+int attr fontFamily 0x0
+int attr fontProviderAuthority 0x0
+int attr fontProviderCerts 0x0
+int attr fontProviderFetchStrategy 0x0
+int attr fontProviderFetchTimeout 0x0
+int attr fontProviderPackage 0x0
+int attr fontProviderQuery 0x0
+int attr fontStyle 0x0
+int attr fontVariationSettings 0x0
+int attr fontWeight 0x0
+int attr gapBetweenBars 0x0
+int attr goIcon 0x0
+int attr height 0x0
+int attr hideOnContentScroll 0x0
+int attr homeAsUpIndicator 0x0
+int attr homeLayout 0x0
+int attr icon 0x0
+int attr iconTint 0x0
+int attr iconTintMode 0x0
+int attr iconifiedByDefault 0x0
+int attr imageButtonStyle 0x0
+int attr indeterminateProgressStyle 0x0
+int attr initialActivityCount 0x0
+int attr isAutofillInlineSuggestionTheme 0x0
+int attr isLightTheme 0x0
+int attr itemPadding 0x0
+int attr keylines 0x0
+int attr lastBaselineToBottomHeight 0x0
+int attr layout 0x0
+int attr layout_anchor 0x0
+int attr layout_anchorGravity 0x0
+int attr layout_behavior 0x0
+int attr layout_dodgeInsetEdges 0x0
+int attr layout_insetEdge 0x0
+int attr layout_keyline 0x0
+int attr lineHeight 0x0
+int attr listChoiceBackgroundIndicator 0x0
+int attr listDividerAlertDialog 0x0
+int attr listItemLayout 0x0
+int attr listLayout 0x0
+int attr listMenuViewStyle 0x0
+int attr listPopupWindowStyle 0x0
+int attr listPreferredItemHeight 0x0
+int attr listPreferredItemHeightLarge 0x0
+int attr listPreferredItemHeightSmall 0x0
+int attr listPreferredItemPaddingLeft 0x0
+int attr listPreferredItemPaddingRight 0x0
+int attr logo 0x0
+int attr logoDescription 0x0
+int attr maxButtonHeight 0x0
+int attr measureWithLargestChild 0x0
+int attr multiChoiceItemLayout 0x0
+int attr navigationContentDescription 0x0
+int attr navigationIcon 0x0
+int attr navigationMode 0x0
+int attr numericModifiers 0x0
+int attr overlapAnchor 0x0
+int attr overlayImage 0x0
+int attr paddingBottomNoButtons 0x0
+int attr paddingEnd 0x0
+int attr paddingStart 0x0
+int attr paddingTopNoTitle 0x0
+int attr panelBackground 0x0
+int attr panelMenuListTheme 0x0
+int attr panelMenuListWidth 0x0
+int attr placeholderImage 0x0
+int attr placeholderImageScaleType 0x0
+int attr popupMenuStyle 0x0
+int attr popupTheme 0x0
+int attr popupWindowStyle 0x0
+int attr preserveIconSpacing 0x0
+int attr pressedStateOverlayImage 0x0
+int attr progressBarAutoRotateInterval 0x0
+int attr progressBarImage 0x0
+int attr progressBarImageScaleType 0x0
+int attr progressBarPadding 0x0
+int attr progressBarStyle 0x0
+int attr queryBackground 0x0
+int attr queryHint 0x0
+int attr radioButtonStyle 0x0
+int attr ratingBarStyle 0x0
+int attr ratingBarStyleIndicator 0x0
+int attr ratingBarStyleSmall 0x0
+int attr retryImage 0x0
+int attr retryImageScaleType 0x0
+int attr roundAsCircle 0x0
+int attr roundBottomEnd 0x0
+int attr roundBottomLeft 0x0
+int attr roundBottomRight 0x0
+int attr roundBottomStart 0x0
+int attr roundTopEnd 0x0
+int attr roundTopLeft 0x0
+int attr roundTopRight 0x0
+int attr roundTopStart 0x0
+int attr roundWithOverlayColor 0x0
+int attr roundedCornerRadius 0x0
+int attr roundingBorderColor 0x0
+int attr roundingBorderPadding 0x0
+int attr roundingBorderWidth 0x0
+int attr searchHintIcon 0x0
+int attr searchIcon 0x0
+int attr searchViewStyle 0x0
+int attr seekBarStyle 0x0
+int attr selectableItemBackground 0x0
+int attr selectableItemBackgroundBorderless 0x0
+int attr showAsAction 0x0
+int attr showDividers 0x0
+int attr showText 0x0
+int attr showTitle 0x0
+int attr singleChoiceItemLayout 0x0
+int attr spinBars 0x0
+int attr spinnerDropDownItemStyle 0x0
+int attr spinnerStyle 0x0
+int attr splitTrack 0x0
+int attr srcCompat 0x0
+int attr state_above_anchor 0x0
+int attr statusBarBackground 0x0
+int attr subMenuArrow 0x0
+int attr submitBackground 0x0
+int attr subtitle 0x0
+int attr subtitleTextAppearance 0x0
+int attr subtitleTextColor 0x0
+int attr subtitleTextStyle 0x0
+int attr suggestionRowLayout 0x0
+int attr switchMinWidth 0x0
+int attr switchPadding 0x0
+int attr switchStyle 0x0
+int attr switchTextAppearance 0x0
+int attr textAllCaps 0x0
+int attr textAppearanceLargePopupMenu 0x0
+int attr textAppearanceListItem 0x0
+int attr textAppearanceListItemSecondary 0x0
+int attr textAppearanceListItemSmall 0x0
+int attr textAppearancePopupMenuHeader 0x0
+int attr textAppearanceSearchResultSubtitle 0x0
+int attr textAppearanceSearchResultTitle 0x0
+int attr textAppearanceSmallPopupMenu 0x0
+int attr textColorAlertDialogListItem 0x0
+int attr textColorSearchUrl 0x0
+int attr theme 0x0
+int attr thickness 0x0
+int attr thumbTextPadding 0x0
+int attr thumbTint 0x0
+int attr thumbTintMode 0x0
+int attr tickMark 0x0
+int attr tickMarkTint 0x0
+int attr tickMarkTintMode 0x0
+int attr tint 0x0
+int attr tintMode 0x0
+int attr title 0x0
+int attr titleMargin 0x0
+int attr titleMarginBottom 0x0
+int attr titleMarginEnd 0x0
+int attr titleMarginStart 0x0
+int attr titleMarginTop 0x0
+int attr titleMargins 0x0
+int attr titleTextAppearance 0x0
+int attr titleTextColor 0x0
+int attr titleTextStyle 0x0
+int attr toolbarNavigationButtonStyle 0x0
+int attr toolbarStyle 0x0
+int attr tooltipForegroundColor 0x0
+int attr tooltipFrameBackground 0x0
+int attr tooltipText 0x0
+int attr track 0x0
+int attr trackTint 0x0
+int attr trackTintMode 0x0
+int attr ttcIndex 0x0
+int attr viewAspectRatio 0x0
+int attr viewInflaterClass 0x0
+int attr voiceIcon 0x0
+int attr windowActionBar 0x0
+int attr windowActionBarOverlay 0x0
+int attr windowActionModeOverlay 0x0
+int attr windowFixedHeightMajor 0x0
+int attr windowFixedHeightMinor 0x0
+int attr windowFixedWidthMajor 0x0
+int attr windowFixedWidthMinor 0x0
+int attr windowMinWidthMajor 0x0
+int attr windowMinWidthMinor 0x0
+int attr windowNoTitle 0x0
+int bool abc_action_bar_embed_tabs 0x0
+int bool abc_allow_stacked_button_bar 0x0
+int bool abc_config_actionMenuItemAllCaps 0x0
+int color abc_background_cache_hint_selector_material_dark 0x0
+int color abc_background_cache_hint_selector_material_light 0x0
+int color abc_btn_colored_borderless_text_material 0x0
+int color abc_btn_colored_text_material 0x0
+int color abc_color_highlight_material 0x0
+int color abc_hint_foreground_material_dark 0x0
+int color abc_hint_foreground_material_light 0x0
+int color abc_input_method_navigation_guard 0x0
+int color abc_primary_text_disable_only_material_dark 0x0
+int color abc_primary_text_disable_only_material_light 0x0
+int color abc_primary_text_material_dark 0x0
+int color abc_primary_text_material_light 0x0
+int color abc_search_url_text 0x0
+int color abc_search_url_text_normal 0x0
+int color abc_search_url_text_pressed 0x0
+int color abc_search_url_text_selected 0x0
+int color abc_secondary_text_material_dark 0x0
+int color abc_secondary_text_material_light 0x0
+int color abc_tint_btn_checkable 0x0
+int color abc_tint_default 0x0
+int color abc_tint_edittext 0x0
+int color abc_tint_seek_thumb 0x0
+int color abc_tint_spinner 0x0
+int color abc_tint_switch_track 0x0
+int color accent_material_dark 0x0
+int color accent_material_light 0x0
+int color background_floating_material_dark 0x0
+int color background_floating_material_light 0x0
+int color background_material_dark 0x0
+int color background_material_light 0x0
+int color bright_foreground_disabled_material_dark 0x0
+int color bright_foreground_disabled_material_light 0x0
+int color bright_foreground_inverse_material_dark 0x0
+int color bright_foreground_inverse_material_light 0x0
+int color bright_foreground_material_dark 0x0
+int color bright_foreground_material_light 0x0
+int color button_material_dark 0x0
+int color button_material_light 0x0
+int color catalyst_logbox_background 0x0
+int color catalyst_redbox_background 0x0
+int color dim_foreground_disabled_material_dark 0x0
+int color dim_foreground_disabled_material_light 0x0
+int color dim_foreground_material_dark 0x0
+int color dim_foreground_material_light 0x0
+int color error_color_material_dark 0x0
+int color error_color_material_light 0x0
+int color foreground_material_dark 0x0
+int color foreground_material_light 0x0
+int color highlighted_text_material_dark 0x0
+int color highlighted_text_material_light 0x0
+int color material_blue_grey_800 0x0
+int color material_blue_grey_900 0x0
+int color material_blue_grey_950 0x0
+int color material_deep_teal_200 0x0
+int color material_deep_teal_500 0x0
+int color material_grey_100 0x0
+int color material_grey_300 0x0
+int color material_grey_50 0x0
+int color material_grey_600 0x0
+int color material_grey_800 0x0
+int color material_grey_850 0x0
+int color material_grey_900 0x0
+int color notification_action_color_filter 0x0
+int color notification_icon_bg_color 0x0
+int color primary_dark_material_dark 0x0
+int color primary_dark_material_light 0x0
+int color primary_material_dark 0x0
+int color primary_material_light 0x0
+int color primary_text_default_material_dark 0x0
+int color primary_text_default_material_light 0x0
+int color primary_text_disabled_material_dark 0x0
+int color primary_text_disabled_material_light 0x0
+int color ripple_material_dark 0x0
+int color ripple_material_light 0x0
+int color secondary_text_default_material_dark 0x0
+int color secondary_text_default_material_light 0x0
+int color secondary_text_disabled_material_dark 0x0
+int color secondary_text_disabled_material_light 0x0
+int color switch_thumb_disabled_material_dark 0x0
+int color switch_thumb_disabled_material_light 0x0
+int color switch_thumb_material_dark 0x0
+int color switch_thumb_material_light 0x0
+int color switch_thumb_normal_material_dark 0x0
+int color switch_thumb_normal_material_light 0x0
+int color tooltip_background_dark 0x0
+int color tooltip_background_light 0x0
+int dimen abc_action_bar_content_inset_material 0x0
+int dimen abc_action_bar_content_inset_with_nav 0x0
+int dimen abc_action_bar_default_height_material 0x0
+int dimen abc_action_bar_default_padding_end_material 0x0
+int dimen abc_action_bar_default_padding_start_material 0x0
+int dimen abc_action_bar_elevation_material 0x0
+int dimen abc_action_bar_icon_vertical_padding_material 0x0
+int dimen abc_action_bar_overflow_padding_end_material 0x0
+int dimen abc_action_bar_overflow_padding_start_material 0x0
+int dimen abc_action_bar_stacked_max_height 0x0
+int dimen abc_action_bar_stacked_tab_max_width 0x0
+int dimen abc_action_bar_subtitle_bottom_margin_material 0x0
+int dimen abc_action_bar_subtitle_top_margin_material 0x0
+int dimen abc_action_button_min_height_material 0x0
+int dimen abc_action_button_min_width_material 0x0
+int dimen abc_action_button_min_width_overflow_material 0x0
+int dimen abc_alert_dialog_button_bar_height 0x0
+int dimen abc_alert_dialog_button_dimen 0x0
+int dimen abc_button_inset_horizontal_material 0x0
+int dimen abc_button_inset_vertical_material 0x0
+int dimen abc_button_padding_horizontal_material 0x0
+int dimen abc_button_padding_vertical_material 0x0
+int dimen abc_cascading_menus_min_smallest_width 0x0
+int dimen abc_config_prefDialogWidth 0x0
+int dimen abc_control_corner_material 0x0
+int dimen abc_control_inset_material 0x0
+int dimen abc_control_padding_material 0x0
+int dimen abc_dialog_corner_radius_material 0x0
+int dimen abc_dialog_fixed_height_major 0x0
+int dimen abc_dialog_fixed_height_minor 0x0
+int dimen abc_dialog_fixed_width_major 0x0
+int dimen abc_dialog_fixed_width_minor 0x0
+int dimen abc_dialog_list_padding_bottom_no_buttons 0x0
+int dimen abc_dialog_list_padding_top_no_title 0x0
+int dimen abc_dialog_min_width_major 0x0
+int dimen abc_dialog_min_width_minor 0x0
+int dimen abc_dialog_padding_material 0x0
+int dimen abc_dialog_padding_top_material 0x0
+int dimen abc_dialog_title_divider_material 0x0
+int dimen abc_disabled_alpha_material_dark 0x0
+int dimen abc_disabled_alpha_material_light 0x0
+int dimen abc_dropdownitem_icon_width 0x0
+int dimen abc_dropdownitem_text_padding_left 0x0
+int dimen abc_dropdownitem_text_padding_right 0x0
+int dimen abc_edit_text_inset_bottom_material 0x0
+int dimen abc_edit_text_inset_horizontal_material 0x0
+int dimen abc_edit_text_inset_top_material 0x0
+int dimen abc_floating_window_z 0x0
+int dimen abc_list_item_padding_horizontal_material 0x0
+int dimen abc_panel_menu_list_width 0x0
+int dimen abc_progress_bar_height_material 0x0
+int dimen abc_search_view_preferred_height 0x0
+int dimen abc_search_view_preferred_width 0x0
+int dimen abc_seekbar_track_background_height_material 0x0
+int dimen abc_seekbar_track_progress_height_material 0x0
+int dimen abc_select_dialog_padding_start_material 0x0
+int dimen abc_switch_padding 0x0
+int dimen abc_text_size_body_1_material 0x0
+int dimen abc_text_size_body_2_material 0x0
+int dimen abc_text_size_button_material 0x0
+int dimen abc_text_size_caption_material 0x0
+int dimen abc_text_size_display_1_material 0x0
+int dimen abc_text_size_display_2_material 0x0
+int dimen abc_text_size_display_3_material 0x0
+int dimen abc_text_size_display_4_material 0x0
+int dimen abc_text_size_headline_material 0x0
+int dimen abc_text_size_large_material 0x0
+int dimen abc_text_size_medium_material 0x0
+int dimen abc_text_size_menu_header_material 0x0
+int dimen abc_text_size_menu_material 0x0
+int dimen abc_text_size_small_material 0x0
+int dimen abc_text_size_subhead_material 0x0
+int dimen abc_text_size_subtitle_material_toolbar 0x0
+int dimen abc_text_size_title_material 0x0
+int dimen abc_text_size_title_material_toolbar 0x0
+int dimen autofill_inline_suggestion_icon_size 0x0
+int dimen compat_button_inset_horizontal_material 0x0
+int dimen compat_button_inset_vertical_material 0x0
+int dimen compat_button_padding_horizontal_material 0x0
+int dimen compat_button_padding_vertical_material 0x0
+int dimen compat_control_corner_material 0x0
+int dimen compat_notification_large_icon_max_height 0x0
+int dimen compat_notification_large_icon_max_width 0x0
+int dimen disabled_alpha_material_dark 0x0
+int dimen disabled_alpha_material_light 0x0
+int dimen highlight_alpha_material_colored 0x0
+int dimen highlight_alpha_material_dark 0x0
+int dimen highlight_alpha_material_light 0x0
+int dimen hint_alpha_material_dark 0x0
+int dimen hint_alpha_material_light 0x0
+int dimen hint_pressed_alpha_material_dark 0x0
+int dimen hint_pressed_alpha_material_light 0x0
+int dimen notification_action_icon_size 0x0
+int dimen notification_action_text_size 0x0
+int dimen notification_big_circle_margin 0x0
+int dimen notification_content_margin_start 0x0
+int dimen notification_large_icon_height 0x0
+int dimen notification_large_icon_width 0x0
+int dimen notification_main_column_padding_top 0x0
+int dimen notification_media_narrow_margin 0x0
+int dimen notification_right_icon_size 0x0
+int dimen notification_right_side_padding_top 0x0
+int dimen notification_small_icon_background_padding 0x0
+int dimen notification_small_icon_size_as_large 0x0
+int dimen notification_subtext_size 0x0
+int dimen notification_top_pad 0x0
+int dimen notification_top_pad_large_text 0x0
+int dimen tooltip_corner_radius 0x0
+int dimen tooltip_horizontal_padding 0x0
+int dimen tooltip_margin 0x0
+int dimen tooltip_precise_anchor_extra_offset 0x0
+int dimen tooltip_precise_anchor_threshold 0x0
+int dimen tooltip_vertical_padding 0x0
+int dimen tooltip_y_offset_non_touch 0x0
+int dimen tooltip_y_offset_touch 0x0
+int drawable abc_ab_share_pack_mtrl_alpha 0x0
+int drawable abc_action_bar_item_background_material 0x0
+int drawable abc_btn_borderless_material 0x0
+int drawable abc_btn_check_material 0x0
+int drawable abc_btn_check_to_on_mtrl_000 0x0
+int drawable abc_btn_check_to_on_mtrl_015 0x0
+int drawable abc_btn_colored_material 0x0
+int drawable abc_btn_default_mtrl_shape 0x0
+int drawable abc_btn_radio_material 0x0
+int drawable abc_btn_radio_to_on_mtrl_000 0x0
+int drawable abc_btn_radio_to_on_mtrl_015 0x0
+int drawable abc_btn_switch_to_on_mtrl_00001 0x0
+int drawable abc_btn_switch_to_on_mtrl_00012 0x0
+int drawable abc_cab_background_internal_bg 0x0
+int drawable abc_cab_background_top_material 0x0
+int drawable abc_cab_background_top_mtrl_alpha 0x0
+int drawable abc_control_background_material 0x0
+int drawable abc_dialog_material_background 0x0
+int drawable abc_edit_text_material 0x0
+int drawable abc_ic_ab_back_material 0x0
+int drawable abc_ic_arrow_drop_right_black_24dp 0x0
+int drawable abc_ic_clear_material 0x0
+int drawable abc_ic_commit_search_api_mtrl_alpha 0x0
+int drawable abc_ic_go_search_api_material 0x0
+int drawable abc_ic_menu_copy_mtrl_am_alpha 0x0
+int drawable abc_ic_menu_cut_mtrl_alpha 0x0
+int drawable abc_ic_menu_overflow_material 0x0
+int drawable abc_ic_menu_paste_mtrl_am_alpha 0x0
+int drawable abc_ic_menu_selectall_mtrl_alpha 0x0
+int drawable abc_ic_menu_share_mtrl_alpha 0x0
+int drawable abc_ic_search_api_material 0x0
+int drawable abc_ic_star_black_16dp 0x0
+int drawable abc_ic_star_black_36dp 0x0
+int drawable abc_ic_star_black_48dp 0x0
+int drawable abc_ic_star_half_black_16dp 0x0
+int drawable abc_ic_star_half_black_36dp 0x0
+int drawable abc_ic_star_half_black_48dp 0x0
+int drawable abc_ic_voice_search_api_material 0x0
+int drawable abc_item_background_holo_dark 0x0
+int drawable abc_item_background_holo_light 0x0
+int drawable abc_list_divider_material 0x0
+int drawable abc_list_divider_mtrl_alpha 0x0
+int drawable abc_list_focused_holo 0x0
+int drawable abc_list_longpressed_holo 0x0
+int drawable abc_list_pressed_holo_dark 0x0
+int drawable abc_list_pressed_holo_light 0x0
+int drawable abc_list_selector_background_transition_holo_dark 0x0
+int drawable abc_list_selector_background_transition_holo_light 0x0
+int drawable abc_list_selector_disabled_holo_dark 0x0
+int drawable abc_list_selector_disabled_holo_light 0x0
+int drawable abc_list_selector_holo_dark 0x0
+int drawable abc_list_selector_holo_light 0x0
+int drawable abc_menu_hardkey_panel_mtrl_mult 0x0
+int drawable abc_popup_background_mtrl_mult 0x0
+int drawable abc_ratingbar_indicator_material 0x0
+int drawable abc_ratingbar_material 0x0
+int drawable abc_ratingbar_small_material 0x0
+int drawable abc_scrubber_control_off_mtrl_alpha 0x0
+int drawable abc_scrubber_control_to_pressed_mtrl_000 0x0
+int drawable abc_scrubber_control_to_pressed_mtrl_005 0x0
+int drawable abc_scrubber_primary_mtrl_alpha 0x0
+int drawable abc_scrubber_track_mtrl_alpha 0x0
+int drawable abc_seekbar_thumb_material 0x0
+int drawable abc_seekbar_tick_mark_material 0x0
+int drawable abc_seekbar_track_material 0x0
+int drawable abc_spinner_mtrl_am_alpha 0x0
+int drawable abc_spinner_textfield_background_material 0x0
+int drawable abc_switch_thumb_material 0x0
+int drawable abc_switch_track_mtrl_alpha 0x0
+int drawable abc_tab_indicator_material 0x0
+int drawable abc_tab_indicator_mtrl_alpha 0x0
+int drawable abc_text_cursor_material 0x0
+int drawable abc_text_select_handle_left_mtrl_dark 0x0
+int drawable abc_text_select_handle_left_mtrl_light 0x0
+int drawable abc_text_select_handle_middle_mtrl_dark 0x0
+int drawable abc_text_select_handle_middle_mtrl_light 0x0
+int drawable abc_text_select_handle_right_mtrl_dark 0x0
+int drawable abc_text_select_handle_right_mtrl_light 0x0
+int drawable abc_textfield_activated_mtrl_alpha 0x0
+int drawable abc_textfield_default_mtrl_alpha 0x0
+int drawable abc_textfield_search_activated_mtrl_alpha 0x0
+int drawable abc_textfield_search_default_mtrl_alpha 0x0
+int drawable abc_textfield_search_material 0x0
+int drawable abc_vector_test 0x0
+int drawable autofill_inline_suggestion_chip_background 0x0
+int drawable notification_action_background 0x0
+int drawable notification_bg 0x0
+int drawable notification_bg_low 0x0
+int drawable notification_bg_low_normal 0x0
+int drawable notification_bg_low_pressed 0x0
+int drawable notification_bg_normal 0x0
+int drawable notification_bg_normal_pressed 0x0
+int drawable notification_icon_background 0x0
+int drawable notification_template_icon_bg 0x0
+int drawable notification_template_icon_low_bg 0x0
+int drawable notification_tile_bg 0x0
+int drawable notify_panel_notification_icon_bg 0x0
+int drawable redbox_top_border_background 0x0
+int drawable tooltip_frame_dark 0x0
+int drawable tooltip_frame_light 0x0
+int id accessibility_action_clickable_span 0x0
+int id accessibility_actions 0x0
+int id accessibility_custom_action_0 0x0
+int id accessibility_custom_action_1 0x0
+int id accessibility_custom_action_10 0x0
+int id accessibility_custom_action_11 0x0
+int id accessibility_custom_action_12 0x0
+int id accessibility_custom_action_13 0x0
+int id accessibility_custom_action_14 0x0
+int id accessibility_custom_action_15 0x0
+int id accessibility_custom_action_16 0x0
+int id accessibility_custom_action_17 0x0
+int id accessibility_custom_action_18 0x0
+int id accessibility_custom_action_19 0x0
+int id accessibility_custom_action_2 0x0
+int id accessibility_custom_action_20 0x0
+int id accessibility_custom_action_21 0x0
+int id accessibility_custom_action_22 0x0
+int id accessibility_custom_action_23 0x0
+int id accessibility_custom_action_24 0x0
+int id accessibility_custom_action_25 0x0
+int id accessibility_custom_action_26 0x0
+int id accessibility_custom_action_27 0x0
+int id accessibility_custom_action_28 0x0
+int id accessibility_custom_action_29 0x0
+int id accessibility_custom_action_3 0x0
+int id accessibility_custom_action_30 0x0
+int id accessibility_custom_action_31 0x0
+int id accessibility_custom_action_4 0x0
+int id accessibility_custom_action_5 0x0
+int id accessibility_custom_action_6 0x0
+int id accessibility_custom_action_7 0x0
+int id accessibility_custom_action_8 0x0
+int id accessibility_custom_action_9 0x0
+int id accessibility_hint 0x0
+int id accessibility_label 0x0
+int id accessibility_role 0x0
+int id accessibility_state 0x0
+int id accessibility_value 0x0
+int id action_bar 0x0
+int id action_bar_activity_content 0x0
+int id action_bar_container 0x0
+int id action_bar_root 0x0
+int id action_bar_spinner 0x0
+int id action_bar_subtitle 0x0
+int id action_bar_title 0x0
+int id action_container 0x0
+int id action_context_bar 0x0
+int id action_divider 0x0
+int id action_image 0x0
+int id action_menu_divider 0x0
+int id action_menu_presenter 0x0
+int id action_mode_bar 0x0
+int id action_mode_bar_stub 0x0
+int id action_mode_close_button 0x0
+int id action_text 0x0
+int id actions 0x0
+int id activity_chooser_view_content 0x0
+int id add 0x0
+int id alertTitle 0x0
+int id async 0x0
+int id autofill_inline_suggestion_end_icon 0x0
+int id autofill_inline_suggestion_start_icon 0x0
+int id autofill_inline_suggestion_subtitle 0x0
+int id autofill_inline_suggestion_title 0x0
+int id blocking 0x0
+int id bottom 0x0
+int id buttonPanel 0x0
+int id catalyst_redbox_title 0x0
+int id center 0x0
+int id centerCrop 0x0
+int id centerInside 0x0
+int id checkbox 0x0
+int id chronometer 0x0
+int id content 0x0
+int id contentPanel 0x0
+int id custom 0x0
+int id customPanel 0x0
+int id decor_content_parent 0x0
+int id default_activity_button 0x0
+int id dialog_button 0x0
+int id edit_query 0x0
+int id end 0x0
+int id expand_activities_button 0x0
+int id expanded_menu 0x0
+int id fitBottomStart 0x0
+int id fitCenter 0x0
+int id fitEnd 0x0
+int id fitStart 0x0
+int id fitXY 0x0
+int id focusCrop 0x0
+int id forever 0x0
+int id fps_text 0x0
+int id group_divider 0x0
+int id home 0x0
+int id icon 0x0
+int id icon_group 0x0
+int id image 0x0
+int id info 0x0
+int id italic 0x0
+int id labelled_by 0x0
+int id left 0x0
+int id line1 0x0
+int id line3 0x0
+int id listMode 0x0
+int id list_item 0x0
+int id message 0x0
+int id multiply 0x0
+int id none 0x0
+int id normal 0x0
+int id notification_background 0x0
+int id notification_main_column 0x0
+int id notification_main_column_container 0x0
+int id parentPanel 0x0
+int id pointer_enter 0x0
+int id pointer_leave 0x0
+int id pointer_move 0x0
+int id progress_circular 0x0
+int id progress_horizontal 0x0
+int id radio 0x0
+int id react_test_id 0x0
+int id right 0x0
+int id right_icon 0x0
+int id right_side 0x0
+int id rn_frame_file 0x0
+int id rn_frame_method 0x0
+int id rn_redbox_dismiss_button 0x0
+int id rn_redbox_line_separator 0x0
+int id rn_redbox_loading_indicator 0x0
+int id rn_redbox_reload_button 0x0
+int id rn_redbox_report_button 0x0
+int id rn_redbox_report_label 0x0
+int id rn_redbox_stack 0x0
+int id screen 0x0
+int id scrollIndicatorDown 0x0
+int id scrollIndicatorUp 0x0
+int id scrollView 0x0
+int id search_badge 0x0
+int id search_bar 0x0
+int id search_button 0x0
+int id search_close_btn 0x0
+int id search_edit_frame 0x0
+int id search_go_btn 0x0
+int id search_mag_icon 0x0
+int id search_plate 0x0
+int id search_src_text 0x0
+int id search_voice_btn 0x0
+int id select_dialog_listview 0x0
+int id shortcut 0x0
+int id spacer 0x0
+int id split_action_bar 0x0
+int id src_atop 0x0
+int id src_in 0x0
+int id src_over 0x0
+int id start 0x0
+int id submenuarrow 0x0
+int id submit_area 0x0
+int id tabMode 0x0
+int id tag_accessibility_actions 0x0
+int id tag_accessibility_clickable_spans 0x0
+int id tag_accessibility_heading 0x0
+int id tag_accessibility_pane_title 0x0
+int id tag_screen_reader_focusable 0x0
+int id tag_transition_group 0x0
+int id tag_unhandled_key_event_manager 0x0
+int id tag_unhandled_key_listeners 0x0
+int id text 0x0
+int id text2 0x0
+int id textSpacerNoButtons 0x0
+int id textSpacerNoTitle 0x0
+int id time 0x0
+int id title 0x0
+int id titleDividerNoCustom 0x0
+int id title_template 0x0
+int id top 0x0
+int id topPanel 0x0
+int id uniform 0x0
+int id up 0x0
+int id view_tag_instance_handle 0x0
+int id view_tag_native_id 0x0
+int id wrap_content 0x0
+int integer abc_config_activityDefaultDur 0x0
+int integer abc_config_activityShortDur 0x0
+int integer cancel_button_image_alpha 0x0
+int integer config_tooltipAnimTime 0x0
+int integer react_native_dev_server_port 0x0
+int integer react_native_inspector_proxy_port 0x0
+int integer status_bar_notification_info_maxnum 0x0
+int layout abc_action_bar_title_item 0x0
+int layout abc_action_bar_up_container 0x0
+int layout abc_action_menu_item_layout 0x0
+int layout abc_action_menu_layout 0x0
+int layout abc_action_mode_bar 0x0
+int layout abc_action_mode_close_item_material 0x0
+int layout abc_activity_chooser_view 0x0
+int layout abc_activity_chooser_view_list_item 0x0
+int layout abc_alert_dialog_button_bar_material 0x0
+int layout abc_alert_dialog_material 0x0
+int layout abc_alert_dialog_title_material 0x0
+int layout abc_cascading_menu_item_layout 0x0
+int layout abc_dialog_title_material 0x0
+int layout abc_expanded_menu_layout 0x0
+int layout abc_list_menu_item_checkbox 0x0
+int layout abc_list_menu_item_icon 0x0
+int layout abc_list_menu_item_layout 0x0
+int layout abc_list_menu_item_radio 0x0
+int layout abc_popup_menu_header_item_layout 0x0
+int layout abc_popup_menu_item_layout 0x0
+int layout abc_screen_content_include 0x0
+int layout abc_screen_simple 0x0
+int layout abc_screen_simple_overlay_action_mode 0x0
+int layout abc_screen_toolbar 0x0
+int layout abc_search_dropdown_item_icons_2line 0x0
+int layout abc_search_view 0x0
+int layout abc_select_dialog_material 0x0
+int layout abc_tooltip 0x0
+int layout autofill_inline_suggestion 0x0
+int layout custom_dialog 0x0
+int layout dev_loading_view 0x0
+int layout fps_view 0x0
+int layout notification_action 0x0
+int layout notification_action_tombstone 0x0
+int layout notification_template_custom_big 0x0
+int layout notification_template_icon_group 0x0
+int layout notification_template_part_chronometer 0x0
+int layout notification_template_part_time 0x0
+int layout redbox_item_frame 0x0
+int layout redbox_item_title 0x0
+int layout redbox_view 0x0
+int layout select_dialog_item_material 0x0
+int layout select_dialog_multichoice_material 0x0
+int layout select_dialog_singlechoice_material 0x0
+int layout support_simple_spinner_dropdown_item 0x0
+int string abc_action_bar_home_description 0x0
+int string abc_action_bar_up_description 0x0
+int string abc_action_menu_overflow_description 0x0
+int string abc_action_mode_done 0x0
+int string abc_activity_chooser_view_see_all 0x0
+int string abc_activitychooserview_choose_application 0x0
+int string abc_capital_off 0x0
+int string abc_capital_on 0x0
+int string abc_font_family_body_1_material 0x0
+int string abc_font_family_body_2_material 0x0
+int string abc_font_family_button_material 0x0
+int string abc_font_family_caption_material 0x0
+int string abc_font_family_display_1_material 0x0
+int string abc_font_family_display_2_material 0x0
+int string abc_font_family_display_3_material 0x0
+int string abc_font_family_display_4_material 0x0
+int string abc_font_family_headline_material 0x0
+int string abc_font_family_menu_material 0x0
+int string abc_font_family_subhead_material 0x0
+int string abc_font_family_title_material 0x0
+int string abc_menu_alt_shortcut_label 0x0
+int string abc_menu_ctrl_shortcut_label 0x0
+int string abc_menu_delete_shortcut_label 0x0
+int string abc_menu_enter_shortcut_label 0x0
+int string abc_menu_function_shortcut_label 0x0
+int string abc_menu_meta_shortcut_label 0x0
+int string abc_menu_shift_shortcut_label 0x0
+int string abc_menu_space_shortcut_label 0x0
+int string abc_menu_sym_shortcut_label 0x0
+int string abc_prepend_shortcut_label 0x0
+int string abc_search_hint 0x0
+int string abc_searchview_description_clear 0x0
+int string abc_searchview_description_query 0x0
+int string abc_searchview_description_search 0x0
+int string abc_searchview_description_submit 0x0
+int string abc_searchview_description_voice 0x0
+int string abc_shareactionprovider_share_with 0x0
+int string abc_shareactionprovider_share_with_application 0x0
+int string abc_toolbar_collapse_description 0x0
+int string alert_description 0x0
+int string catalyst_change_bundle_location 0x0
+int string catalyst_copy_button 0x0
+int string catalyst_debug 0x0
+int string catalyst_debug_chrome 0x0
+int string catalyst_debug_chrome_stop 0x0
+int string catalyst_debug_connecting 0x0
+int string catalyst_debug_error 0x0
+int string catalyst_debug_open 0x0
+int string catalyst_debug_stop 0x0
+int string catalyst_devtools_open 0x0
+int string catalyst_dismiss_button 0x0
+int string catalyst_heap_capture 0x0
+int string catalyst_hot_reloading 0x0
+int string catalyst_hot_reloading_auto_disable 0x0
+int string catalyst_hot_reloading_auto_enable 0x0
+int string catalyst_hot_reloading_stop 0x0
+int string catalyst_inspector 0x0
+int string catalyst_inspector_stop 0x0
+int string catalyst_loading_from_url 0x0
+int string catalyst_open_flipper_error 0x0
+int string catalyst_perf_monitor 0x0
+int string catalyst_perf_monitor_stop 0x0
+int string catalyst_reload 0x0
+int string catalyst_reload_button 0x0
+int string catalyst_reload_error 0x0
+int string catalyst_report_button 0x0
+int string catalyst_sample_profiler_disable 0x0
+int string catalyst_sample_profiler_enable 0x0
+int string catalyst_settings 0x0
+int string catalyst_settings_title 0x0
+int string combobox_description 0x0
+int string header_description 0x0
+int string image_description 0x0
+int string imagebutton_description 0x0
+int string link_description 0x0
+int string menu_description 0x0
+int string menubar_description 0x0
+int string menuitem_description 0x0
+int string progressbar_description 0x0
+int string radiogroup_description 0x0
+int string rn_tab_description 0x0
+int string scrollbar_description 0x0
+int string search_menu_title 0x0
+int string spinbutton_description 0x0
+int string state_busy_description 0x0
+int string state_collapsed_description 0x0
+int string state_expanded_description 0x0
+int string state_mixed_description 0x0
+int string state_off_description 0x0
+int string state_on_description 0x0
+int string state_unselected_description 0x0
+int string status_bar_notification_info_overflow 0x0
+int string summary_description 0x0
+int string tablist_description 0x0
+int string timer_description 0x0
+int string toolbar_description 0x0
+int style AlertDialog_AppCompat 0x0
+int style AlertDialog_AppCompat_Light 0x0
+int style Animation_AppCompat_Dialog 0x0
+int style Animation_AppCompat_DropDownUp 0x0
+int style Animation_AppCompat_Tooltip 0x0
+int style Animation_Catalyst_LogBox 0x0
+int style Animation_Catalyst_RedBox 0x0
+int style Base_AlertDialog_AppCompat 0x0
+int style Base_AlertDialog_AppCompat_Light 0x0
+int style Base_Animation_AppCompat_Dialog 0x0
+int style Base_Animation_AppCompat_DropDownUp 0x0
+int style Base_Animation_AppCompat_Tooltip 0x0
+int style Base_DialogWindowTitleBackground_AppCompat 0x0
+int style Base_DialogWindowTitle_AppCompat 0x0
+int style Base_TextAppearance_AppCompat 0x0
+int style Base_TextAppearance_AppCompat_Body1 0x0
+int style Base_TextAppearance_AppCompat_Body2 0x0
+int style Base_TextAppearance_AppCompat_Button 0x0
+int style Base_TextAppearance_AppCompat_Caption 0x0
+int style Base_TextAppearance_AppCompat_Display1 0x0
+int style Base_TextAppearance_AppCompat_Display2 0x0
+int style Base_TextAppearance_AppCompat_Display3 0x0
+int style Base_TextAppearance_AppCompat_Display4 0x0
+int style Base_TextAppearance_AppCompat_Headline 0x0
+int style Base_TextAppearance_AppCompat_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Large 0x0
+int style Base_TextAppearance_AppCompat_Large_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Light_Widget_PopupMenu_Large 0x0
+int style Base_TextAppearance_AppCompat_Light_Widget_PopupMenu_Small 0x0
+int style Base_TextAppearance_AppCompat_Medium 0x0
+int style Base_TextAppearance_AppCompat_Medium_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Menu 0x0
+int style Base_TextAppearance_AppCompat_SearchResult 0x0
+int style Base_TextAppearance_AppCompat_SearchResult_Subtitle 0x0
+int style Base_TextAppearance_AppCompat_SearchResult_Title 0x0
+int style Base_TextAppearance_AppCompat_Small 0x0
+int style Base_TextAppearance_AppCompat_Small_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Subhead 0x0
+int style Base_TextAppearance_AppCompat_Subhead_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Title 0x0
+int style Base_TextAppearance_AppCompat_Title_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Tooltip 0x0
+int style Base_TextAppearance_AppCompat_Widget_ActionBar_Menu 0x0
+int style Base_TextAppearance_AppCompat_Widget_ActionBar_Subtitle 0x0
+int style Base_TextAppearance_AppCompat_Widget_ActionBar_Subtitle_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Widget_ActionBar_Title 0x0
+int style Base_TextAppearance_AppCompat_Widget_ActionBar_Title_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Widget_ActionMode_Subtitle 0x0
+int style Base_TextAppearance_AppCompat_Widget_ActionMode_Title 0x0
+int style Base_TextAppearance_AppCompat_Widget_Button 0x0
+int style Base_TextAppearance_AppCompat_Widget_Button_Borderless_Colored 0x0
+int style Base_TextAppearance_AppCompat_Widget_Button_Colored 0x0
+int style Base_TextAppearance_AppCompat_Widget_Button_Inverse 0x0
+int style Base_TextAppearance_AppCompat_Widget_DropDownItem 0x0
+int style Base_TextAppearance_AppCompat_Widget_PopupMenu_Header 0x0
+int style Base_TextAppearance_AppCompat_Widget_PopupMenu_Large 0x0
+int style Base_TextAppearance_AppCompat_Widget_PopupMenu_Small 0x0
+int style Base_TextAppearance_AppCompat_Widget_Switch 0x0
+int style Base_TextAppearance_AppCompat_Widget_TextView_SpinnerItem 0x0
+int style Base_TextAppearance_Widget_AppCompat_ExpandedMenu_Item 0x0
+int style Base_TextAppearance_Widget_AppCompat_Toolbar_Subtitle 0x0
+int style Base_TextAppearance_Widget_AppCompat_Toolbar_Title 0x0
+int style Base_ThemeOverlay_AppCompat 0x0
+int style Base_ThemeOverlay_AppCompat_ActionBar 0x0
+int style Base_ThemeOverlay_AppCompat_Dark 0x0
+int style Base_ThemeOverlay_AppCompat_Dark_ActionBar 0x0
+int style Base_ThemeOverlay_AppCompat_Dialog 0x0
+int style Base_ThemeOverlay_AppCompat_Dialog_Alert 0x0
+int style Base_ThemeOverlay_AppCompat_Light 0x0
+int style Base_Theme_AppCompat 0x0
+int style Base_Theme_AppCompat_CompactMenu 0x0
+int style Base_Theme_AppCompat_Dialog 0x0
+int style Base_Theme_AppCompat_DialogWhenLarge 0x0
+int style Base_Theme_AppCompat_Dialog_Alert 0x0
+int style Base_Theme_AppCompat_Dialog_FixedSize 0x0
+int style Base_Theme_AppCompat_Dialog_MinWidth 0x0
+int style Base_Theme_AppCompat_Light 0x0
+int style Base_Theme_AppCompat_Light_DarkActionBar 0x0
+int style Base_Theme_AppCompat_Light_Dialog 0x0
+int style Base_Theme_AppCompat_Light_DialogWhenLarge 0x0
+int style Base_Theme_AppCompat_Light_Dialog_Alert 0x0
+int style Base_Theme_AppCompat_Light_Dialog_FixedSize 0x0
+int style Base_Theme_AppCompat_Light_Dialog_MinWidth 0x0
+int style Base_V21_ThemeOverlay_AppCompat_Dialog 0x0
+int style Base_V21_Theme_AppCompat 0x0
+int style Base_V21_Theme_AppCompat_Dialog 0x0
+int style Base_V21_Theme_AppCompat_Light 0x0
+int style Base_V21_Theme_AppCompat_Light_Dialog 0x0
+int style Base_V22_Theme_AppCompat 0x0
+int style Base_V22_Theme_AppCompat_Light 0x0
+int style Base_V23_Theme_AppCompat 0x0
+int style Base_V23_Theme_AppCompat_Light 0x0
+int style Base_V26_Theme_AppCompat 0x0
+int style Base_V26_Theme_AppCompat_Light 0x0
+int style Base_V26_Widget_AppCompat_Toolbar 0x0
+int style Base_V28_Theme_AppCompat 0x0
+int style Base_V28_Theme_AppCompat_Light 0x0
+int style Base_V7_ThemeOverlay_AppCompat_Dialog 0x0
+int style Base_V7_Theme_AppCompat 0x0
+int style Base_V7_Theme_AppCompat_Dialog 0x0
+int style Base_V7_Theme_AppCompat_Light 0x0
+int style Base_V7_Theme_AppCompat_Light_Dialog 0x0
+int style Base_V7_Widget_AppCompat_AutoCompleteTextView 0x0
+int style Base_V7_Widget_AppCompat_EditText 0x0
+int style Base_V7_Widget_AppCompat_Toolbar 0x0
+int style Base_Widget_AppCompat_ActionBar 0x0
+int style Base_Widget_AppCompat_ActionBar_Solid 0x0
+int style Base_Widget_AppCompat_ActionBar_TabBar 0x0
+int style Base_Widget_AppCompat_ActionBar_TabText 0x0
+int style Base_Widget_AppCompat_ActionBar_TabView 0x0
+int style Base_Widget_AppCompat_ActionButton 0x0
+int style Base_Widget_AppCompat_ActionButton_CloseMode 0x0
+int style Base_Widget_AppCompat_ActionButton_Overflow 0x0
+int style Base_Widget_AppCompat_ActionMode 0x0
+int style Base_Widget_AppCompat_ActivityChooserView 0x0
+int style Base_Widget_AppCompat_AutoCompleteTextView 0x0
+int style Base_Widget_AppCompat_Button 0x0
+int style Base_Widget_AppCompat_ButtonBar 0x0
+int style Base_Widget_AppCompat_ButtonBar_AlertDialog 0x0
+int style Base_Widget_AppCompat_Button_Borderless 0x0
+int style Base_Widget_AppCompat_Button_Borderless_Colored 0x0
+int style Base_Widget_AppCompat_Button_ButtonBar_AlertDialog 0x0
+int style Base_Widget_AppCompat_Button_Colored 0x0
+int style Base_Widget_AppCompat_Button_Small 0x0
+int style Base_Widget_AppCompat_CompoundButton_CheckBox 0x0
+int style Base_Widget_AppCompat_CompoundButton_RadioButton 0x0
+int style Base_Widget_AppCompat_CompoundButton_Switch 0x0
+int style Base_Widget_AppCompat_DrawerArrowToggle 0x0
+int style Base_Widget_AppCompat_DrawerArrowToggle_Common 0x0
+int style Base_Widget_AppCompat_DropDownItem_Spinner 0x0
+int style Base_Widget_AppCompat_EditText 0x0
+int style Base_Widget_AppCompat_ImageButton 0x0
+int style Base_Widget_AppCompat_Light_ActionBar 0x0
+int style Base_Widget_AppCompat_Light_ActionBar_Solid 0x0
+int style Base_Widget_AppCompat_Light_ActionBar_TabBar 0x0
+int style Base_Widget_AppCompat_Light_ActionBar_TabText 0x0
+int style Base_Widget_AppCompat_Light_ActionBar_TabText_Inverse 0x0
+int style Base_Widget_AppCompat_Light_ActionBar_TabView 0x0
+int style Base_Widget_AppCompat_Light_PopupMenu 0x0
+int style Base_Widget_AppCompat_Light_PopupMenu_Overflow 0x0
+int style Base_Widget_AppCompat_ListMenuView 0x0
+int style Base_Widget_AppCompat_ListPopupWindow 0x0
+int style Base_Widget_AppCompat_ListView 0x0
+int style Base_Widget_AppCompat_ListView_DropDown 0x0
+int style Base_Widget_AppCompat_ListView_Menu 0x0
+int style Base_Widget_AppCompat_PopupMenu 0x0
+int style Base_Widget_AppCompat_PopupMenu_Overflow 0x0
+int style Base_Widget_AppCompat_PopupWindow 0x0
+int style Base_Widget_AppCompat_ProgressBar 0x0
+int style Base_Widget_AppCompat_ProgressBar_Horizontal 0x0
+int style Base_Widget_AppCompat_RatingBar 0x0
+int style Base_Widget_AppCompat_RatingBar_Indicator 0x0
+int style Base_Widget_AppCompat_RatingBar_Small 0x0
+int style Base_Widget_AppCompat_SearchView 0x0
+int style Base_Widget_AppCompat_SearchView_ActionBar 0x0
+int style Base_Widget_AppCompat_SeekBar 0x0
+int style Base_Widget_AppCompat_SeekBar_Discrete 0x0
+int style Base_Widget_AppCompat_Spinner 0x0
+int style Base_Widget_AppCompat_Spinner_Underlined 0x0
+int style Base_Widget_AppCompat_TextView_SpinnerItem 0x0
+int style Base_Widget_AppCompat_Toolbar 0x0
+int style Base_Widget_AppCompat_Toolbar_Button_Navigation 0x0
+int style CalendarDatePickerDialog 0x0
+int style CalendarDatePickerStyle 0x0
+int style DialogAnimationFade 0x0
+int style DialogAnimationSlide 0x0
+int style Platform_AppCompat 0x0
+int style Platform_AppCompat_Light 0x0
+int style Platform_ThemeOverlay_AppCompat 0x0
+int style Platform_ThemeOverlay_AppCompat_Dark 0x0
+int style Platform_ThemeOverlay_AppCompat_Light 0x0
+int style Platform_V21_AppCompat 0x0
+int style Platform_V21_AppCompat_Light 0x0
+int style Platform_V25_AppCompat 0x0
+int style Platform_V25_AppCompat_Light 0x0
+int style Platform_Widget_AppCompat_Spinner 0x0
+int style RtlOverlay_DialogWindowTitle_AppCompat 0x0
+int style RtlOverlay_Widget_AppCompat_ActionBar_TitleItem 0x0
+int style RtlOverlay_Widget_AppCompat_DialogTitle_Icon 0x0
+int style RtlOverlay_Widget_AppCompat_PopupMenuItem 0x0
+int style RtlOverlay_Widget_AppCompat_PopupMenuItem_InternalGroup 0x0
+int style RtlOverlay_Widget_AppCompat_PopupMenuItem_Shortcut 0x0
+int style RtlOverlay_Widget_AppCompat_PopupMenuItem_SubmenuArrow 0x0
+int style RtlOverlay_Widget_AppCompat_PopupMenuItem_Text 0x0
+int style RtlOverlay_Widget_AppCompat_PopupMenuItem_Title 0x0
+int style RtlOverlay_Widget_AppCompat_SearchView_MagIcon 0x0
+int style RtlOverlay_Widget_AppCompat_Search_DropDown 0x0
+int style RtlOverlay_Widget_AppCompat_Search_DropDown_Icon1 0x0
+int style RtlOverlay_Widget_AppCompat_Search_DropDown_Icon2 0x0
+int style RtlOverlay_Widget_AppCompat_Search_DropDown_Query 0x0
+int style RtlOverlay_Widget_AppCompat_Search_DropDown_Text 0x0
+int style RtlUnderlay_Widget_AppCompat_ActionButton 0x0
+int style RtlUnderlay_Widget_AppCompat_ActionButton_Overflow 0x0
+int style SpinnerDatePickerDialog 0x0
+int style SpinnerDatePickerStyle 0x0
+int style TextAppearance_AppCompat 0x0
+int style TextAppearance_AppCompat_Body1 0x0
+int style TextAppearance_AppCompat_Body2 0x0
+int style TextAppearance_AppCompat_Button 0x0
+int style TextAppearance_AppCompat_Caption 0x0
+int style TextAppearance_AppCompat_Display1 0x0
+int style TextAppearance_AppCompat_Display2 0x0
+int style TextAppearance_AppCompat_Display3 0x0
+int style TextAppearance_AppCompat_Display4 0x0
+int style TextAppearance_AppCompat_Headline 0x0
+int style TextAppearance_AppCompat_Inverse 0x0
+int style TextAppearance_AppCompat_Large 0x0
+int style TextAppearance_AppCompat_Large_Inverse 0x0
+int style TextAppearance_AppCompat_Light_SearchResult_Subtitle 0x0
+int style TextAppearance_AppCompat_Light_SearchResult_Title 0x0
+int style TextAppearance_AppCompat_Light_Widget_PopupMenu_Large 0x0
+int style TextAppearance_AppCompat_Light_Widget_PopupMenu_Small 0x0
+int style TextAppearance_AppCompat_Medium 0x0
+int style TextAppearance_AppCompat_Medium_Inverse 0x0
+int style TextAppearance_AppCompat_Menu 0x0
+int style TextAppearance_AppCompat_SearchResult_Subtitle 0x0
+int style TextAppearance_AppCompat_SearchResult_Title 0x0
+int style TextAppearance_AppCompat_Small 0x0
+int style TextAppearance_AppCompat_Small_Inverse 0x0
+int style TextAppearance_AppCompat_Subhead 0x0
+int style TextAppearance_AppCompat_Subhead_Inverse 0x0
+int style TextAppearance_AppCompat_Title 0x0
+int style TextAppearance_AppCompat_Title_Inverse 0x0
+int style TextAppearance_AppCompat_Tooltip 0x0
+int style TextAppearance_AppCompat_Widget_ActionBar_Menu 0x0
+int style TextAppearance_AppCompat_Widget_ActionBar_Subtitle 0x0
+int style TextAppearance_AppCompat_Widget_ActionBar_Subtitle_Inverse 0x0
+int style TextAppearance_AppCompat_Widget_ActionBar_Title 0x0
+int style TextAppearance_AppCompat_Widget_ActionBar_Title_Inverse 0x0
+int style TextAppearance_AppCompat_Widget_ActionMode_Subtitle 0x0
+int style TextAppearance_AppCompat_Widget_ActionMode_Subtitle_Inverse 0x0
+int style TextAppearance_AppCompat_Widget_ActionMode_Title 0x0
+int style TextAppearance_AppCompat_Widget_ActionMode_Title_Inverse 0x0
+int style TextAppearance_AppCompat_Widget_Button 0x0
+int style TextAppearance_AppCompat_Widget_Button_Borderless_Colored 0x0
+int style TextAppearance_AppCompat_Widget_Button_Colored 0x0
+int style TextAppearance_AppCompat_Widget_Button_Inverse 0x0
+int style TextAppearance_AppCompat_Widget_DropDownItem 0x0
+int style TextAppearance_AppCompat_Widget_PopupMenu_Header 0x0
+int style TextAppearance_AppCompat_Widget_PopupMenu_Large 0x0
+int style TextAppearance_AppCompat_Widget_PopupMenu_Small 0x0
+int style TextAppearance_AppCompat_Widget_Switch 0x0
+int style TextAppearance_AppCompat_Widget_TextView_SpinnerItem 0x0
+int style TextAppearance_Compat_Notification 0x0
+int style TextAppearance_Compat_Notification_Info 0x0
+int style TextAppearance_Compat_Notification_Line2 0x0
+int style TextAppearance_Compat_Notification_Time 0x0
+int style TextAppearance_Compat_Notification_Title 0x0
+int style TextAppearance_Widget_AppCompat_ExpandedMenu_Item 0x0
+int style TextAppearance_Widget_AppCompat_Toolbar_Subtitle 0x0
+int style TextAppearance_Widget_AppCompat_Toolbar_Title 0x0
+int style Theme 0x0
+int style ThemeOverlay_AppCompat 0x0
+int style ThemeOverlay_AppCompat_ActionBar 0x0
+int style ThemeOverlay_AppCompat_Dark 0x0
+int style ThemeOverlay_AppCompat_Dark_ActionBar 0x0
+int style ThemeOverlay_AppCompat_Dialog 0x0
+int style ThemeOverlay_AppCompat_Dialog_Alert 0x0
+int style ThemeOverlay_AppCompat_Light 0x0
+int style Theme_AppCompat 0x0
+int style Theme_AppCompat_CompactMenu 0x0
+int style Theme_AppCompat_DayNight 0x0
+int style Theme_AppCompat_DayNight_DarkActionBar 0x0
+int style Theme_AppCompat_DayNight_Dialog 0x0
+int style Theme_AppCompat_DayNight_DialogWhenLarge 0x0
+int style Theme_AppCompat_DayNight_Dialog_Alert 0x0
+int style Theme_AppCompat_DayNight_Dialog_MinWidth 0x0
+int style Theme_AppCompat_DayNight_NoActionBar 0x0
+int style Theme_AppCompat_Dialog 0x0
+int style Theme_AppCompat_DialogWhenLarge 0x0
+int style Theme_AppCompat_Dialog_Alert 0x0
+int style Theme_AppCompat_Dialog_MinWidth 0x0
+int style Theme_AppCompat_Light 0x0
+int style Theme_AppCompat_Light_DarkActionBar 0x0
+int style Theme_AppCompat_Light_Dialog 0x0
+int style Theme_AppCompat_Light_DialogWhenLarge 0x0
+int style Theme_AppCompat_Light_Dialog_Alert 0x0
+int style Theme_AppCompat_Light_Dialog_MinWidth 0x0
+int style Theme_AppCompat_Light_NoActionBar 0x0
+int style Theme_AppCompat_NoActionBar 0x0
+int style Theme_AutofillInlineSuggestion 0x0
+int style Theme_Catalyst 0x0
+int style Theme_Catalyst_LogBox 0x0
+int style Theme_Catalyst_RedBox 0x0
+int style Theme_FullScreenDialog 0x0
+int style Theme_FullScreenDialogAnimatedFade 0x0
+int style Theme_FullScreenDialogAnimatedSlide 0x0
+int style Theme_ReactNative_AppCompat_Light 0x0
+int style Theme_ReactNative_AppCompat_Light_NoActionBar_FullScreen 0x0
+int style Widget_AppCompat_ActionBar 0x0
+int style Widget_AppCompat_ActionBar_Solid 0x0
+int style Widget_AppCompat_ActionBar_TabBar 0x0
+int style Widget_AppCompat_ActionBar_TabText 0x0
+int style Widget_AppCompat_ActionBar_TabView 0x0
+int style Widget_AppCompat_ActionButton 0x0
+int style Widget_AppCompat_ActionButton_CloseMode 0x0
+int style Widget_AppCompat_ActionButton_Overflow 0x0
+int style Widget_AppCompat_ActionMode 0x0
+int style Widget_AppCompat_ActivityChooserView 0x0
+int style Widget_AppCompat_AutoCompleteTextView 0x0
+int style Widget_AppCompat_Button 0x0
+int style Widget_AppCompat_ButtonBar 0x0
+int style Widget_AppCompat_ButtonBar_AlertDialog 0x0
+int style Widget_AppCompat_Button_Borderless 0x0
+int style Widget_AppCompat_Button_Borderless_Colored 0x0
+int style Widget_AppCompat_Button_ButtonBar_AlertDialog 0x0
+int style Widget_AppCompat_Button_Colored 0x0
+int style Widget_AppCompat_Button_Small 0x0
+int style Widget_AppCompat_CompoundButton_CheckBox 0x0
+int style Widget_AppCompat_CompoundButton_RadioButton 0x0
+int style Widget_AppCompat_CompoundButton_Switch 0x0
+int style Widget_AppCompat_DrawerArrowToggle 0x0
+int style Widget_AppCompat_DropDownItem_Spinner 0x0
+int style Widget_AppCompat_EditText 0x0
+int style Widget_AppCompat_ImageButton 0x0
+int style Widget_AppCompat_Light_ActionBar 0x0
+int style Widget_AppCompat_Light_ActionBar_Solid 0x0
+int style Widget_AppCompat_Light_ActionBar_Solid_Inverse 0x0
+int style Widget_AppCompat_Light_ActionBar_TabBar 0x0
+int style Widget_AppCompat_Light_ActionBar_TabBar_Inverse 0x0
+int style Widget_AppCompat_Light_ActionBar_TabText 0x0
+int style Widget_AppCompat_Light_ActionBar_TabText_Inverse 0x0
+int style Widget_AppCompat_Light_ActionBar_TabView 0x0
+int style Widget_AppCompat_Light_ActionBar_TabView_Inverse 0x0
+int style Widget_AppCompat_Light_ActionButton 0x0
+int style Widget_AppCompat_Light_ActionButton_CloseMode 0x0
+int style Widget_AppCompat_Light_ActionButton_Overflow 0x0
+int style Widget_AppCompat_Light_ActionMode_Inverse 0x0
+int style Widget_AppCompat_Light_ActivityChooserView 0x0
+int style Widget_AppCompat_Light_AutoCompleteTextView 0x0
+int style Widget_AppCompat_Light_DropDownItem_Spinner 0x0
+int style Widget_AppCompat_Light_ListPopupWindow 0x0
+int style Widget_AppCompat_Light_ListView_DropDown 0x0
+int style Widget_AppCompat_Light_PopupMenu 0x0
+int style Widget_AppCompat_Light_PopupMenu_Overflow 0x0
+int style Widget_AppCompat_Light_SearchView 0x0
+int style Widget_AppCompat_Light_Spinner_DropDown_ActionBar 0x0
+int style Widget_AppCompat_ListMenuView 0x0
+int style Widget_AppCompat_ListPopupWindow 0x0
+int style Widget_AppCompat_ListView 0x0
+int style Widget_AppCompat_ListView_DropDown 0x0
+int style Widget_AppCompat_ListView_Menu 0x0
+int style Widget_AppCompat_PopupMenu 0x0
+int style Widget_AppCompat_PopupMenu_Overflow 0x0
+int style Widget_AppCompat_PopupWindow 0x0
+int style Widget_AppCompat_ProgressBar 0x0
+int style Widget_AppCompat_ProgressBar_Horizontal 0x0
+int style Widget_AppCompat_RatingBar 0x0
+int style Widget_AppCompat_RatingBar_Indicator 0x0
+int style Widget_AppCompat_RatingBar_Small 0x0
+int style Widget_AppCompat_SearchView 0x0
+int style Widget_AppCompat_SearchView_ActionBar 0x0
+int style Widget_AppCompat_SeekBar 0x0
+int style Widget_AppCompat_SeekBar_Discrete 0x0
+int style Widget_AppCompat_Spinner 0x0
+int style Widget_AppCompat_Spinner_DropDown 0x0
+int style Widget_AppCompat_Spinner_DropDown_ActionBar 0x0
+int style Widget_AppCompat_Spinner_Underlined 0x0
+int style Widget_AppCompat_TextView_SpinnerItem 0x0
+int style Widget_AppCompat_Toolbar 0x0
+int style Widget_AppCompat_Toolbar_Button_Navigation 0x0
+int style Widget_Autofill 0x0
+int style Widget_Autofill_InlineSuggestionChip 0x0
+int style Widget_Autofill_InlineSuggestionEndIconStyle 0x0
+int style Widget_Autofill_InlineSuggestionStartIconStyle 0x0
+int style Widget_Autofill_InlineSuggestionSubtitle 0x0
+int style Widget_Autofill_InlineSuggestionTitle 0x0
+int style Widget_Compat_NotificationActionContainer 0x0
+int style Widget_Compat_NotificationActionText 0x0
+int style Widget_Support_CoordinatorLayout 0x0
+int style redboxButton 0x0
+int[] styleable ActionBar { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable ActionBar_background 0
+int styleable ActionBar_backgroundSplit 1
+int styleable ActionBar_backgroundStacked 2
+int styleable ActionBar_contentInsetEnd 3
+int styleable ActionBar_contentInsetEndWithActions 4
+int styleable ActionBar_contentInsetLeft 5
+int styleable ActionBar_contentInsetRight 6
+int styleable ActionBar_contentInsetStart 7
+int styleable ActionBar_contentInsetStartWithNavigation 8
+int styleable ActionBar_customNavigationLayout 9
+int styleable ActionBar_displayOptions 10
+int styleable ActionBar_divider 11
+int styleable ActionBar_elevation 12
+int styleable ActionBar_height 13
+int styleable ActionBar_hideOnContentScroll 14
+int styleable ActionBar_homeAsUpIndicator 15
+int styleable ActionBar_homeLayout 16
+int styleable ActionBar_icon 17
+int styleable ActionBar_indeterminateProgressStyle 18
+int styleable ActionBar_itemPadding 19
+int styleable ActionBar_logo 20
+int styleable ActionBar_navigationMode 21
+int styleable ActionBar_popupTheme 22
+int styleable ActionBar_progressBarPadding 23
+int styleable ActionBar_progressBarStyle 24
+int styleable ActionBar_subtitle 25
+int styleable ActionBar_subtitleTextStyle 26
+int styleable ActionBar_title 27
+int styleable ActionBar_titleTextStyle 28
+int[] styleable ActionBarLayout { 0x10100b3 }
+int styleable ActionBarLayout_android_layout_gravity 0
+int[] styleable ActionMenuItemView { 0x101013f }
+int styleable ActionMenuItemView_android_minWidth 0
+int[] styleable ActionMenuView {  }
+int[] styleable ActionMode { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable ActionMode_background 0
+int styleable ActionMode_backgroundSplit 1
+int styleable ActionMode_closeItemLayout 2
+int styleable ActionMode_height 3
+int styleable ActionMode_subtitleTextStyle 4
+int styleable ActionMode_titleTextStyle 5
+int[] styleable ActivityChooserView { 0x0, 0x0 }
+int styleable ActivityChooserView_expandActivityOverflowButtonDrawable 0
+int styleable ActivityChooserView_initialActivityCount 1
+int[] styleable AlertDialog { 0x10100f2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable AlertDialog_android_layout 0
+int styleable AlertDialog_buttonIconDimen 1
+int styleable AlertDialog_buttonPanelSideLayout 2
+int styleable AlertDialog_listItemLayout 3
+int styleable AlertDialog_listLayout 4
+int styleable AlertDialog_multiChoiceItemLayout 5
+int styleable AlertDialog_showTitle 6
+int styleable AlertDialog_singleChoiceItemLayout 7
+int[] styleable AnimatedStateListDrawableCompat { 0x1010196, 0x101011c, 0x101030c, 0x101030d, 0x1010195, 0x1010194 }
+int styleable AnimatedStateListDrawableCompat_android_constantSize 0
+int styleable AnimatedStateListDrawableCompat_android_dither 1
+int styleable AnimatedStateListDrawableCompat_android_enterFadeDuration 2
+int styleable AnimatedStateListDrawableCompat_android_exitFadeDuration 3
+int styleable AnimatedStateListDrawableCompat_android_variablePadding 4
+int styleable AnimatedStateListDrawableCompat_android_visible 5
+int[] styleable AnimatedStateListDrawableItem { 0x1010199, 0x10100d0 }
+int styleable AnimatedStateListDrawableItem_android_drawable 0
+int styleable AnimatedStateListDrawableItem_android_id 1
+int[] styleable AnimatedStateListDrawableTransition { 0x1010199, 0x101044a, 0x101044b, 0x1010449 }
+int styleable AnimatedStateListDrawableTransition_android_drawable 0
+int styleable AnimatedStateListDrawableTransition_android_fromId 1
+int styleable AnimatedStateListDrawableTransition_android_reversible 2
+int styleable AnimatedStateListDrawableTransition_android_toId 3
+int[] styleable AppCompatImageView { 0x1010119, 0x0, 0x0, 0x0 }
+int styleable AppCompatImageView_android_src 0
+int styleable AppCompatImageView_srcCompat 1
+int styleable AppCompatImageView_tint 2
+int styleable AppCompatImageView_tintMode 3
+int[] styleable AppCompatSeekBar { 0x1010142, 0x0, 0x0, 0x0 }
+int styleable AppCompatSeekBar_android_thumb 0
+int styleable AppCompatSeekBar_tickMark 1
+int styleable AppCompatSeekBar_tickMarkTint 2
+int styleable AppCompatSeekBar_tickMarkTintMode 3
+int[] styleable AppCompatTextHelper { 0x101016e, 0x1010393, 0x101016f, 0x1010170, 0x1010392, 0x101016d, 0x1010034 }
+int styleable AppCompatTextHelper_android_drawableBottom 0
+int styleable AppCompatTextHelper_android_drawableEnd 1
+int styleable AppCompatTextHelper_android_drawableLeft 2
+int styleable AppCompatTextHelper_android_drawableRight 3
+int styleable AppCompatTextHelper_android_drawableStart 4
+int styleable AppCompatTextHelper_android_drawableTop 5
+int styleable AppCompatTextHelper_android_textAppearance 6
+int[] styleable AppCompatTextView { 0x1010034, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable AppCompatTextView_android_textAppearance 0
+int styleable AppCompatTextView_autoSizeMaxTextSize 1
+int styleable AppCompatTextView_autoSizeMinTextSize 2
+int styleable AppCompatTextView_autoSizePresetSizes 3
+int styleable AppCompatTextView_autoSizeStepGranularity 4
+int styleable AppCompatTextView_autoSizeTextType 5
+int styleable AppCompatTextView_firstBaselineToTopHeight 6
+int styleable AppCompatTextView_fontFamily 7
+int styleable AppCompatTextView_lastBaselineToBottomHeight 8
+int styleable AppCompatTextView_lineHeight 9
+int styleable AppCompatTextView_textAllCaps 10
+int[] styleable AppCompatTheme { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10100ae, 0x1010057, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable AppCompatTheme_actionBarDivider 0
+int styleable AppCompatTheme_actionBarItemBackground 1
+int styleable AppCompatTheme_actionBarPopupTheme 2
+int styleable AppCompatTheme_actionBarSize 3
+int styleable AppCompatTheme_actionBarSplitStyle 4
+int styleable AppCompatTheme_actionBarStyle 5
+int styleable AppCompatTheme_actionBarTabBarStyle 6
+int styleable AppCompatTheme_actionBarTabStyle 7
+int styleable AppCompatTheme_actionBarTabTextStyle 8
+int styleable AppCompatTheme_actionBarTheme 9
+int styleable AppCompatTheme_actionBarWidgetTheme 10
+int styleable AppCompatTheme_actionButtonStyle 11
+int styleable AppCompatTheme_actionDropDownStyle 12
+int styleable AppCompatTheme_actionMenuTextAppearance 13
+int styleable AppCompatTheme_actionMenuTextColor 14
+int styleable AppCompatTheme_actionModeBackground 15
+int styleable AppCompatTheme_actionModeCloseButtonStyle 16
+int styleable AppCompatTheme_actionModeCloseDrawable 17
+int styleable AppCompatTheme_actionModeCopyDrawable 18
+int styleable AppCompatTheme_actionModeCutDrawable 19
+int styleable AppCompatTheme_actionModeFindDrawable 20
+int styleable AppCompatTheme_actionModePasteDrawable 21
+int styleable AppCompatTheme_actionModePopupWindowStyle 22
+int styleable AppCompatTheme_actionModeSelectAllDrawable 23
+int styleable AppCompatTheme_actionModeShareDrawable 24
+int styleable AppCompatTheme_actionModeSplitBackground 25
+int styleable AppCompatTheme_actionModeStyle 26
+int styleable AppCompatTheme_actionModeWebSearchDrawable 27
+int styleable AppCompatTheme_actionOverflowButtonStyle 28
+int styleable AppCompatTheme_actionOverflowMenuStyle 29
+int styleable AppCompatTheme_activityChooserViewStyle 30
+int styleable AppCompatTheme_alertDialogButtonGroupStyle 31
+int styleable AppCompatTheme_alertDialogCenterButtons 32
+int styleable AppCompatTheme_alertDialogStyle 33
+int styleable AppCompatTheme_alertDialogTheme 34
+int styleable AppCompatTheme_android_windowAnimationStyle 35
+int styleable AppCompatTheme_android_windowIsFloating 36
+int styleable AppCompatTheme_autoCompleteTextViewStyle 37
+int styleable AppCompatTheme_borderlessButtonStyle 38
+int styleable AppCompatTheme_buttonBarButtonStyle 39
+int styleable AppCompatTheme_buttonBarNegativeButtonStyle 40
+int styleable AppCompatTheme_buttonBarNeutralButtonStyle 41
+int styleable AppCompatTheme_buttonBarPositiveButtonStyle 42
+int styleable AppCompatTheme_buttonBarStyle 43
+int styleable AppCompatTheme_buttonStyle 44
+int styleable AppCompatTheme_buttonStyleSmall 45
+int styleable AppCompatTheme_checkboxStyle 46
+int styleable AppCompatTheme_checkedTextViewStyle 47
+int styleable AppCompatTheme_colorAccent 48
+int styleable AppCompatTheme_colorBackgroundFloating 49
+int styleable AppCompatTheme_colorButtonNormal 50
+int styleable AppCompatTheme_colorControlActivated 51
+int styleable AppCompatTheme_colorControlHighlight 52
+int styleable AppCompatTheme_colorControlNormal 53
+int styleable AppCompatTheme_colorError 54
+int styleable AppCompatTheme_colorPrimary 55
+int styleable AppCompatTheme_colorPrimaryDark 56
+int styleable AppCompatTheme_colorSwitchThumbNormal 57
+int styleable AppCompatTheme_controlBackground 58
+int styleable AppCompatTheme_dialogCornerRadius 59
+int styleable AppCompatTheme_dialogPreferredPadding 60
+int styleable AppCompatTheme_dialogTheme 61
+int styleable AppCompatTheme_dividerHorizontal 62
+int styleable AppCompatTheme_dividerVertical 63
+int styleable AppCompatTheme_dropDownListViewStyle 64
+int styleable AppCompatTheme_dropdownListPreferredItemHeight 65
+int styleable AppCompatTheme_editTextBackground 66
+int styleable AppCompatTheme_editTextColor 67
+int styleable AppCompatTheme_editTextStyle 68
+int styleable AppCompatTheme_homeAsUpIndicator 69
+int styleable AppCompatTheme_imageButtonStyle 70
+int styleable AppCompatTheme_listChoiceBackgroundIndicator 71
+int styleable AppCompatTheme_listDividerAlertDialog 72
+int styleable AppCompatTheme_listMenuViewStyle 73
+int styleable AppCompatTheme_listPopupWindowStyle 74
+int styleable AppCompatTheme_listPreferredItemHeight 75
+int styleable AppCompatTheme_listPreferredItemHeightLarge 76
+int styleable AppCompatTheme_listPreferredItemHeightSmall 77
+int styleable AppCompatTheme_listPreferredItemPaddingLeft 78
+int styleable AppCompatTheme_listPreferredItemPaddingRight 79
+int styleable AppCompatTheme_panelBackground 80
+int styleable AppCompatTheme_panelMenuListTheme 81
+int styleable AppCompatTheme_panelMenuListWidth 82
+int styleable AppCompatTheme_popupMenuStyle 83
+int styleable AppCompatTheme_popupWindowStyle 84
+int styleable AppCompatTheme_radioButtonStyle 85
+int styleable AppCompatTheme_ratingBarStyle 86
+int styleable AppCompatTheme_ratingBarStyleIndicator 87
+int styleable AppCompatTheme_ratingBarStyleSmall 88
+int styleable AppCompatTheme_searchViewStyle 89
+int styleable AppCompatTheme_seekBarStyle 90
+int styleable AppCompatTheme_selectableItemBackground 91
+int styleable AppCompatTheme_selectableItemBackgroundBorderless 92
+int styleable AppCompatTheme_spinnerDropDownItemStyle 93
+int styleable AppCompatTheme_spinnerStyle 94
+int styleable AppCompatTheme_switchStyle 95
+int styleable AppCompatTheme_textAppearanceLargePopupMenu 96
+int styleable AppCompatTheme_textAppearanceListItem 97
+int styleable AppCompatTheme_textAppearanceListItemSecondary 98
+int styleable AppCompatTheme_textAppearanceListItemSmall 99
+int styleable AppCompatTheme_textAppearancePopupMenuHeader 100
+int styleable AppCompatTheme_textAppearanceSearchResultSubtitle 101
+int styleable AppCompatTheme_textAppearanceSearchResultTitle 102
+int styleable AppCompatTheme_textAppearanceSmallPopupMenu 103
+int styleable AppCompatTheme_textColorAlertDialogListItem 104
+int styleable AppCompatTheme_textColorSearchUrl 105
+int styleable AppCompatTheme_toolbarNavigationButtonStyle 106
+int styleable AppCompatTheme_toolbarStyle 107
+int styleable AppCompatTheme_tooltipForegroundColor 108
+int styleable AppCompatTheme_tooltipFrameBackground 109
+int styleable AppCompatTheme_viewInflaterClass 110
+int styleable AppCompatTheme_windowActionBar 111
+int styleable AppCompatTheme_windowActionBarOverlay 112
+int styleable AppCompatTheme_windowActionModeOverlay 113
+int styleable AppCompatTheme_windowFixedHeightMajor 114
+int styleable AppCompatTheme_windowFixedHeightMinor 115
+int styleable AppCompatTheme_windowFixedWidthMajor 116
+int styleable AppCompatTheme_windowFixedWidthMinor 117
+int styleable AppCompatTheme_windowMinWidthMajor 118
+int styleable AppCompatTheme_windowMinWidthMinor 119
+int styleable AppCompatTheme_windowNoTitle 120
+int[] styleable Autofill_InlineSuggestion { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable Autofill_InlineSuggestion_autofillInlineSuggestionChip 0
+int styleable Autofill_InlineSuggestion_autofillInlineSuggestionEndIconStyle 1
+int styleable Autofill_InlineSuggestion_autofillInlineSuggestionStartIconStyle 2
+int styleable Autofill_InlineSuggestion_autofillInlineSuggestionSubtitle 3
+int styleable Autofill_InlineSuggestion_autofillInlineSuggestionTitle 4
+int styleable Autofill_InlineSuggestion_isAutofillInlineSuggestionTheme 5
+int[] styleable ButtonBarLayout { 0x0 }
+int styleable ButtonBarLayout_allowStacking 0
+int[] styleable ColorStateListItem { 0x0, 0x101031f, 0x10101a5 }
+int styleable ColorStateListItem_alpha 0
+int styleable ColorStateListItem_android_alpha 1
+int styleable ColorStateListItem_android_color 2
+int[] styleable CompoundButton { 0x1010107, 0x0, 0x0 }
+int styleable CompoundButton_android_button 0
+int styleable CompoundButton_buttonTint 1
+int styleable CompoundButton_buttonTintMode 2
+int[] styleable CoordinatorLayout { 0x0, 0x0 }
+int styleable CoordinatorLayout_keylines 0
+int styleable CoordinatorLayout_statusBarBackground 1
+int[] styleable CoordinatorLayout_Layout { 0x10100b3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable CoordinatorLayout_Layout_android_layout_gravity 0
+int styleable CoordinatorLayout_Layout_layout_anchor 1
+int styleable CoordinatorLayout_Layout_layout_anchorGravity 2
+int styleable CoordinatorLayout_Layout_layout_behavior 3
+int styleable CoordinatorLayout_Layout_layout_dodgeInsetEdges 4
+int styleable CoordinatorLayout_Layout_layout_insetEdge 5
+int styleable CoordinatorLayout_Layout_layout_keyline 6
+int[] styleable DrawerArrowToggle { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable DrawerArrowToggle_arrowHeadLength 0
+int styleable DrawerArrowToggle_arrowShaftLength 1
+int styleable DrawerArrowToggle_barLength 2
+int styleable DrawerArrowToggle_color 3
+int styleable DrawerArrowToggle_drawableSize 4
+int styleable DrawerArrowToggle_gapBetweenBars 5
+int styleable DrawerArrowToggle_spinBars 6
+int styleable DrawerArrowToggle_thickness 7
+int[] styleable FontFamily { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable FontFamily_fontProviderAuthority 0
+int styleable FontFamily_fontProviderCerts 1
+int styleable FontFamily_fontProviderFetchStrategy 2
+int styleable FontFamily_fontProviderFetchTimeout 3
+int styleable FontFamily_fontProviderPackage 4
+int styleable FontFamily_fontProviderQuery 5
+int[] styleable FontFamilyFont { 0x1010532, 0x101053f, 0x1010570, 0x1010533, 0x101056f, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable FontFamilyFont_android_font 0
+int styleable FontFamilyFont_android_fontStyle 1
+int styleable FontFamilyFont_android_fontVariationSettings 2
+int styleable FontFamilyFont_android_fontWeight 3
+int styleable FontFamilyFont_android_ttcIndex 4
+int styleable FontFamilyFont_font 5
+int styleable FontFamilyFont_fontStyle 6
+int styleable FontFamilyFont_fontVariationSettings 7
+int styleable FontFamilyFont_fontWeight 8
+int styleable FontFamilyFont_ttcIndex 9
+int[] styleable GenericDraweeHierarchy { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable GenericDraweeHierarchy_actualImageScaleType 0
+int styleable GenericDraweeHierarchy_backgroundImage 1
+int styleable GenericDraweeHierarchy_fadeDuration 2
+int styleable GenericDraweeHierarchy_failureImage 3
+int styleable GenericDraweeHierarchy_failureImageScaleType 4
+int styleable GenericDraweeHierarchy_overlayImage 5
+int styleable GenericDraweeHierarchy_placeholderImage 6
+int styleable GenericDraweeHierarchy_placeholderImageScaleType 7
+int styleable GenericDraweeHierarchy_pressedStateOverlayImage 8
+int styleable GenericDraweeHierarchy_progressBarAutoRotateInterval 9
+int styleable GenericDraweeHierarchy_progressBarImage 10
+int styleable GenericDraweeHierarchy_progressBarImageScaleType 11
+int styleable GenericDraweeHierarchy_retryImage 12
+int styleable GenericDraweeHierarchy_retryImageScaleType 13
+int styleable GenericDraweeHierarchy_roundAsCircle 14
+int styleable GenericDraweeHierarchy_roundBottomEnd 15
+int styleable GenericDraweeHierarchy_roundBottomLeft 16
+int styleable GenericDraweeHierarchy_roundBottomRight 17
+int styleable GenericDraweeHierarchy_roundBottomStart 18
+int styleable GenericDraweeHierarchy_roundTopEnd 19
+int styleable GenericDraweeHierarchy_roundTopLeft 20
+int styleable GenericDraweeHierarchy_roundTopRight 21
+int styleable GenericDraweeHierarchy_roundTopStart 22
+int styleable GenericDraweeHierarchy_roundWithOverlayColor 23
+int styleable GenericDraweeHierarchy_roundedCornerRadius 24
+int styleable GenericDraweeHierarchy_roundingBorderColor 25
+int styleable GenericDraweeHierarchy_roundingBorderPadding 26
+int styleable GenericDraweeHierarchy_roundingBorderWidth 27
+int styleable GenericDraweeHierarchy_viewAspectRatio 28
+int[] styleable GradientColor { 0x101020b, 0x10101a2, 0x10101a3, 0x101019e, 0x1010512, 0x1010513, 0x10101a4, 0x101019d, 0x1010510, 0x1010511, 0x1010201, 0x10101a1 }
+int styleable GradientColor_android_centerColor 0
+int styleable GradientColor_android_centerX 1
+int styleable GradientColor_android_centerY 2
+int styleable GradientColor_android_endColor 3
+int styleable GradientColor_android_endX 4
+int styleable GradientColor_android_endY 5
+int styleable GradientColor_android_gradientRadius 6
+int styleable GradientColor_android_startColor 7
+int styleable GradientColor_android_startX 8
+int styleable GradientColor_android_startY 9
+int styleable GradientColor_android_tileMode 10
+int styleable GradientColor_android_type 11
+int[] styleable GradientColorItem { 0x10101a5, 0x1010514 }
+int styleable GradientColorItem_android_color 0
+int styleable GradientColorItem_android_offset 1
+int[] styleable LinearLayoutCompat { 0x1010126, 0x1010127, 0x10100af, 0x10100c4, 0x1010128, 0x0, 0x0, 0x0, 0x0 }
+int styleable LinearLayoutCompat_android_baselineAligned 0
+int styleable LinearLayoutCompat_android_baselineAlignedChildIndex 1
+int styleable LinearLayoutCompat_android_gravity 2
+int styleable LinearLayoutCompat_android_orientation 3
+int styleable LinearLayoutCompat_android_weightSum 4
+int styleable LinearLayoutCompat_divider 5
+int styleable LinearLayoutCompat_dividerPadding 6
+int styleable LinearLayoutCompat_measureWithLargestChild 7
+int styleable LinearLayoutCompat_showDividers 8
+int[] styleable LinearLayoutCompat_Layout { 0x10100b3, 0x10100f5, 0x1010181, 0x10100f4 }
+int styleable LinearLayoutCompat_Layout_android_layout_gravity 0
+int styleable LinearLayoutCompat_Layout_android_layout_height 1
+int styleable LinearLayoutCompat_Layout_android_layout_weight 2
+int styleable LinearLayoutCompat_Layout_android_layout_width 3
+int[] styleable ListPopupWindow { 0x10102ac, 0x10102ad }
+int styleable ListPopupWindow_android_dropDownHorizontalOffset 0
+int styleable ListPopupWindow_android_dropDownVerticalOffset 1
+int[] styleable MenuGroup { 0x10101e0, 0x101000e, 0x10100d0, 0x10101de, 0x10101df, 0x1010194 }
+int styleable MenuGroup_android_checkableBehavior 0
+int styleable MenuGroup_android_enabled 1
+int styleable MenuGroup_android_id 2
+int styleable MenuGroup_android_menuCategory 3
+int styleable MenuGroup_android_orderInCategory 4
+int styleable MenuGroup_android_visible 5
+int[] styleable MenuItem { 0x0, 0x0, 0x0, 0x0, 0x10101e3, 0x10101e5, 0x1010106, 0x101000e, 0x1010002, 0x10100d0, 0x10101de, 0x10101e4, 0x101026f, 0x10101df, 0x10101e1, 0x10101e2, 0x1010194, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable MenuItem_actionLayout 0
+int styleable MenuItem_actionProviderClass 1
+int styleable MenuItem_actionViewClass 2
+int styleable MenuItem_alphabeticModifiers 3
+int styleable MenuItem_android_alphabeticShortcut 4
+int styleable MenuItem_android_checkable 5
+int styleable MenuItem_android_checked 6
+int styleable MenuItem_android_enabled 7
+int styleable MenuItem_android_icon 8
+int styleable MenuItem_android_id 9
+int styleable MenuItem_android_menuCategory 10
+int styleable MenuItem_android_numericShortcut 11
+int styleable MenuItem_android_onClick 12
+int styleable MenuItem_android_orderInCategory 13
+int styleable MenuItem_android_title 14
+int styleable MenuItem_android_titleCondensed 15
+int styleable MenuItem_android_visible 16
+int styleable MenuItem_contentDescription 17
+int styleable MenuItem_iconTint 18
+int styleable MenuItem_iconTintMode 19
+int styleable MenuItem_numericModifiers 20
+int styleable MenuItem_showAsAction 21
+int styleable MenuItem_tooltipText 22
+int[] styleable MenuView { 0x101012f, 0x101012d, 0x1010130, 0x1010131, 0x101012c, 0x101012e, 0x10100ae, 0x0, 0x0 }
+int styleable MenuView_android_headerBackground 0
+int styleable MenuView_android_horizontalDivider 1
+int styleable MenuView_android_itemBackground 2
+int styleable MenuView_android_itemIconDisabledAlpha 3
+int styleable MenuView_android_itemTextAppearance 4
+int styleable MenuView_android_verticalDivider 5
+int styleable MenuView_android_windowAnimationStyle 6
+int styleable MenuView_preserveIconSpacing 7
+int styleable MenuView_subMenuArrow 8
+int[] styleable PopupWindow { 0x10102c9, 0x1010176, 0x0 }
+int styleable PopupWindow_android_popupAnimationStyle 0
+int styleable PopupWindow_android_popupBackground 1
+int styleable PopupWindow_overlapAnchor 2
+int[] styleable PopupWindowBackgroundState { 0x0 }
+int styleable PopupWindowBackgroundState_state_above_anchor 0
+int[] styleable RecycleListView { 0x0, 0x0 }
+int styleable RecycleListView_paddingBottomNoButtons 0
+int styleable RecycleListView_paddingTopNoTitle 1
+int[] styleable SearchView { 0x10100da, 0x1010264, 0x1010220, 0x101011f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable SearchView_android_focusable 0
+int styleable SearchView_android_imeOptions 1
+int styleable SearchView_android_inputType 2
+int styleable SearchView_android_maxWidth 3
+int styleable SearchView_closeIcon 4
+int styleable SearchView_commitIcon 5
+int styleable SearchView_defaultQueryHint 6
+int styleable SearchView_goIcon 7
+int styleable SearchView_iconifiedByDefault 8
+int styleable SearchView_layout 9
+int styleable SearchView_queryBackground 10
+int styleable SearchView_queryHint 11
+int styleable SearchView_searchHintIcon 12
+int styleable SearchView_searchIcon 13
+int styleable SearchView_submitBackground 14
+int styleable SearchView_suggestionRowLayout 15
+int styleable SearchView_voiceIcon 16
+int[] styleable SimpleDraweeView { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable SimpleDraweeView_actualImageResource 0
+int styleable SimpleDraweeView_actualImageScaleType 1
+int styleable SimpleDraweeView_actualImageUri 2
+int styleable SimpleDraweeView_backgroundImage 3
+int styleable SimpleDraweeView_fadeDuration 4
+int styleable SimpleDraweeView_failureImage 5
+int styleable SimpleDraweeView_failureImageScaleType 6
+int styleable SimpleDraweeView_overlayImage 7
+int styleable SimpleDraweeView_placeholderImage 8
+int styleable SimpleDraweeView_placeholderImageScaleType 9
+int styleable SimpleDraweeView_pressedStateOverlayImage 10
+int styleable SimpleDraweeView_progressBarAutoRotateInterval 11
+int styleable SimpleDraweeView_progressBarImage 12
+int styleable SimpleDraweeView_progressBarImageScaleType 13
+int styleable SimpleDraweeView_retryImage 14
+int styleable SimpleDraweeView_retryImageScaleType 15
+int styleable SimpleDraweeView_roundAsCircle 16
+int styleable SimpleDraweeView_roundBottomEnd 17
+int styleable SimpleDraweeView_roundBottomLeft 18
+int styleable SimpleDraweeView_roundBottomRight 19
+int styleable SimpleDraweeView_roundBottomStart 20
+int styleable SimpleDraweeView_roundTopEnd 21
+int styleable SimpleDraweeView_roundTopLeft 22
+int styleable SimpleDraweeView_roundTopRight 23
+int styleable SimpleDraweeView_roundTopStart 24
+int styleable SimpleDraweeView_roundWithOverlayColor 25
+int styleable SimpleDraweeView_roundedCornerRadius 26
+int styleable SimpleDraweeView_roundingBorderColor 27
+int styleable SimpleDraweeView_roundingBorderPadding 28
+int styleable SimpleDraweeView_roundingBorderWidth 29
+int styleable SimpleDraweeView_viewAspectRatio 30
+int[] styleable Spinner { 0x1010262, 0x10100b2, 0x1010176, 0x101017b, 0x0 }
+int styleable Spinner_android_dropDownWidth 0
+int styleable Spinner_android_entries 1
+int styleable Spinner_android_popupBackground 2
+int styleable Spinner_android_prompt 3
+int styleable Spinner_popupTheme 4
+int[] styleable StateListDrawable { 0x1010196, 0x101011c, 0x101030c, 0x101030d, 0x1010195, 0x1010194 }
+int styleable StateListDrawable_android_constantSize 0
+int styleable StateListDrawable_android_dither 1
+int styleable StateListDrawable_android_enterFadeDuration 2
+int styleable StateListDrawable_android_exitFadeDuration 3
+int styleable StateListDrawable_android_variablePadding 4
+int styleable StateListDrawable_android_visible 5
+int[] styleable StateListDrawableItem { 0x1010199 }
+int styleable StateListDrawableItem_android_drawable 0
+int[] styleable SwitchCompat { 0x1010125, 0x1010124, 0x1010142, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable SwitchCompat_android_textOff 0
+int styleable SwitchCompat_android_textOn 1
+int styleable SwitchCompat_android_thumb 2
+int styleable SwitchCompat_showText 3
+int styleable SwitchCompat_splitTrack 4
+int styleable SwitchCompat_switchMinWidth 5
+int styleable SwitchCompat_switchPadding 6
+int styleable SwitchCompat_switchTextAppearance 7
+int styleable SwitchCompat_thumbTextPadding 8
+int styleable SwitchCompat_thumbTint 9
+int styleable SwitchCompat_thumbTintMode 10
+int styleable SwitchCompat_track 11
+int styleable SwitchCompat_trackTint 12
+int styleable SwitchCompat_trackTintMode 13
+int[] styleable TextAppearance { 0x10103ac, 0x1010161, 0x1010162, 0x1010163, 0x1010164, 0x1010098, 0x101009a, 0x101009b, 0x1010095, 0x1010097, 0x1010096, 0x0, 0x0 }
+int styleable TextAppearance_android_fontFamily 0
+int styleable TextAppearance_android_shadowColor 1
+int styleable TextAppearance_android_shadowDx 2
+int styleable TextAppearance_android_shadowDy 3
+int styleable TextAppearance_android_shadowRadius 4
+int styleable TextAppearance_android_textColor 5
+int styleable TextAppearance_android_textColorHint 6
+int styleable TextAppearance_android_textColorLink 7
+int styleable TextAppearance_android_textSize 8
+int styleable TextAppearance_android_textStyle 9
+int styleable TextAppearance_android_typeface 10
+int styleable TextAppearance_fontFamily 11
+int styleable TextAppearance_textAllCaps 12
+int[] styleable Toolbar { 0x10100af, 0x1010140, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
+int styleable Toolbar_android_gravity 0
+int styleable Toolbar_android_minHeight 1
+int styleable Toolbar_buttonGravity 2
+int styleable Toolbar_collapseContentDescription 3
+int styleable Toolbar_collapseIcon 4
+int styleable Toolbar_contentInsetEnd 5
+int styleable Toolbar_contentInsetEndWithActions 6
+int styleable Toolbar_contentInsetLeft 7
+int styleable Toolbar_contentInsetRight 8
+int styleable Toolbar_contentInsetStart 9
+int styleable Toolbar_contentInsetStartWithNavigation 10
+int styleable Toolbar_logo 11
+int styleable Toolbar_logoDescription 12
+int styleable Toolbar_maxButtonHeight 13
+int styleable Toolbar_navigationContentDescription 14
+int styleable Toolbar_navigationIcon 15
+int styleable Toolbar_popupTheme 16
+int styleable Toolbar_subtitle 17
+int styleable Toolbar_subtitleTextAppearance 18
+int styleable Toolbar_subtitleTextColor 19
+int styleable Toolbar_title 20
+int styleable Toolbar_titleMargin 21
+int styleable Toolbar_titleMarginBottom 22
+int styleable Toolbar_titleMarginEnd 23
+int styleable Toolbar_titleMarginStart 24
+int styleable Toolbar_titleMarginTop 25
+int styleable Toolbar_titleMargins 26
+int styleable Toolbar_titleTextAppearance 27
+int styleable Toolbar_titleTextColor 28
+int[] styleable View { 0x10100da, 0x1010000, 0x0, 0x0, 0x0 }
+int styleable View_android_focusable 0
+int styleable View_android_theme 1
+int styleable View_paddingEnd 2
+int styleable View_paddingStart 3
+int styleable View_theme 4
+int[] styleable ViewBackgroundHelper { 0x10100d4, 0x0, 0x0 }
+int styleable ViewBackgroundHelper_android_background 0
+int styleable ViewBackgroundHelper_backgroundTint 1
+int styleable ViewBackgroundHelper_backgroundTintMode 2
+int[] styleable ViewStubCompat { 0x10100d0, 0x10100f3, 0x10100f2 }
+int styleable ViewStubCompat_android_id 0
+int styleable ViewStubCompat_android_inflatedId 1
+int styleable ViewStubCompat_android_layout 2
+int xml rn_dev_preferences 0x0
diff --git a/node_modules/react-native-tcp/android/build/intermediates/incremental/mergeDebugJniLibFolders/merger.xml b/node_modules/react-native-tcp/android/build/intermediates/incremental/mergeDebugJniLibFolders/merger.xml
new file mode 100644
index 0000000..5c0374f
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/incremental/mergeDebugJniLibFolders/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/jniLibs"/></dataSet><dataSet config="debug" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/debug/jniLibs"/></dataSet></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/incremental/mergeDebugShaders/merger.xml b/node_modules/react-native-tcp/android/build/intermediates/incremental/mergeDebugShaders/merger.xml
new file mode 100644
index 0000000..5458a22
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/incremental/mergeDebugShaders/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/shaders"/></dataSet><dataSet config="debug" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/debug/shaders"/></dataSet></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugAssets/merger.xml b/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugAssets/merger.xml
new file mode 100644
index 0000000..b1d32bf
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugAssets/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/assets"/><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/build/intermediates/shader_assets/debug/out"/></dataSet><dataSet config="debug" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/debug/assets"/></dataSet></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugResources/compile-file-map.properties b/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugResources/compile-file-map.properties
new file mode 100644
index 0000000..2fffb0b
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugResources/compile-file-map.properties
@@ -0,0 +1 @@
+#Fri Apr 22 21:13:20 EEST 2022
diff --git a/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugResources/merger.xml b/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugResources/merger.xml
new file mode 100644
index 0000000..561bf3b
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/incremental/packageDebugResources/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/res"/><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/build/generated/res/rs/debug"/><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/build/generated/res/resValues/debug"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main" generated-set="main$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/res"/><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/build/generated/res/rs/debug"/><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/build/generated/res/resValues/debug"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/debug/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug" generated-set="debug$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/debug/res"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/BuildConfig.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/BuildConfig.class
new file mode 100644
index 0000000..9f7d4ee
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/BuildConfig.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketListener.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketListener.class
new file mode 100644
index 0000000..4ddcbb8
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketListener.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$1.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$1.class
new file mode 100644
index 0000000..e9d0f54
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$1.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$2.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$2.class
new file mode 100644
index 0000000..5f756dc
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$2.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$3.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$3.class
new file mode 100644
index 0000000..14bc659
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$3.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$4.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$4.class
new file mode 100644
index 0000000..cb8cd21
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$4.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$5.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$5.class
new file mode 100644
index 0000000..c226565
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager$5.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager.class
new file mode 100644
index 0000000..2b134be
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketManager.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$1.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$1.class
new file mode 100644
index 0000000..0f9dbf1
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$1.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$2.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$2.class
new file mode 100644
index 0000000..0f8c182
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$2.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$3.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$3.class
new file mode 100644
index 0000000..45105b0
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$3.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$4.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$4.class
new file mode 100644
index 0000000..fb0086f
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$4.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$5.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$5.class
new file mode 100644
index 0000000..194dcdb
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets$5.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets.class
new file mode 100644
index 0000000..99db7d2
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSockets.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketsModule.class b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketsModule.class
new file mode 100644
index 0000000..21e4b33
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/javac/debug/classes/com/peel/react/TcpSocketsModule.class differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/local_only_symbol_list/debug/R-def.txt b/node_modules/react-native-tcp/android/build/intermediates/local_only_symbol_list/debug/R-def.txt
new file mode 100644
index 0000000..78ac5b8
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/local_only_symbol_list/debug/R-def.txt
@@ -0,0 +1,2 @@
+R_DEF: Internal format may change without notice
+local
diff --git a/node_modules/react-native-tcp/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt b/node_modules/react-native-tcp/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt
new file mode 100644
index 0000000..41930c7
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt
@@ -0,0 +1,15 @@
+1<?xml version="1.0" encoding="utf-8"?>
+2<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+3    package="com.peel.react" >
+4
+5    <uses-sdk
+6        android:minSdkVersion="21"
+6-->/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+7        android:targetSdkVersion="31" />
+7-->/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+8
+9    <uses-permission android:name="android.permission.INTERNET" />
+9-->/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:4:5-66
+9-->/Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:4:22-64
+10
+11</manifest>
diff --git a/node_modules/react-native-tcp/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml b/node_modules/react-native-tcp/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml
new file mode 100644
index 0000000..68a94ae
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.peel.react" >
+
+    <uses-sdk
+        android:minSdkVersion="21"
+        android:targetSdkVersion="31" />
+
+    <uses-permission android:name="android.permission.INTERNET" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/navigation_json/debug/navigation.json b/node_modules/react-native-tcp/android/build/intermediates/navigation_json/debug/navigation.json
new file mode 100644
index 0000000..0637a08
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/navigation_json/debug/navigation.json
@@ -0,0 +1 @@
+[]
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/packaged_manifests/debug/output-metadata.json b/node_modules/react-native-tcp/android/build/intermediates/packaged_manifests/debug/output-metadata.json
new file mode 100644
index 0000000..3e6b4ff
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/packaged_manifests/debug/output-metadata.json
@@ -0,0 +1,18 @@
+{
+  "version": 3,
+  "artifactType": {
+    "type": "PACKAGED_MANIFESTS",
+    "kind": "Directory"
+  },
+  "applicationId": "com.peel.react",
+  "variantName": "debug",
+  "elements": [
+    {
+      "type": "SINGLE",
+      "filters": [],
+      "attributes": [],
+      "outputFile": "../../merged_manifest/debug/AndroidManifest.xml"
+    }
+  ],
+  "elementType": "File"
+}
\ No newline at end of file
diff --git a/node_modules/react-native-tcp/android/build/intermediates/runtime_library_classes_jar/debug/classes.jar b/node_modules/react-native-tcp/android/build/intermediates/runtime_library_classes_jar/debug/classes.jar
new file mode 100644
index 0000000..ade1278
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/intermediates/runtime_library_classes_jar/debug/classes.jar differ
diff --git a/node_modules/react-native-tcp/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt b/node_modules/react-native-tcp/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt
new file mode 100644
index 0000000..28494a0
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt
@@ -0,0 +1,1380 @@
+com.peel.react
+anim abc_fade_in
+anim abc_fade_out
+anim abc_grow_fade_in_from_bottom
+anim abc_popup_enter
+anim abc_popup_exit
+anim abc_shrink_fade_out_from_bottom
+anim abc_slide_in_bottom
+anim abc_slide_in_top
+anim abc_slide_out_bottom
+anim abc_slide_out_top
+anim abc_tooltip_enter
+anim abc_tooltip_exit
+anim catalyst_fade_in
+anim catalyst_fade_out
+anim catalyst_push_up_in
+anim catalyst_push_up_out
+anim catalyst_slide_down
+anim catalyst_slide_up
+attr actionBarDivider
+attr actionBarItemBackground
+attr actionBarPopupTheme
+attr actionBarSize
+attr actionBarSplitStyle
+attr actionBarStyle
+attr actionBarTabBarStyle
+attr actionBarTabStyle
+attr actionBarTabTextStyle
+attr actionBarTheme
+attr actionBarWidgetTheme
+attr actionButtonStyle
+attr actionDropDownStyle
+attr actionLayout
+attr actionMenuTextAppearance
+attr actionMenuTextColor
+attr actionModeBackground
+attr actionModeCloseButtonStyle
+attr actionModeCloseDrawable
+attr actionModeCopyDrawable
+attr actionModeCutDrawable
+attr actionModeFindDrawable
+attr actionModePasteDrawable
+attr actionModePopupWindowStyle
+attr actionModeSelectAllDrawable
+attr actionModeShareDrawable
+attr actionModeSplitBackground
+attr actionModeStyle
+attr actionModeWebSearchDrawable
+attr actionOverflowButtonStyle
+attr actionOverflowMenuStyle
+attr actionProviderClass
+attr actionViewClass
+attr activityChooserViewStyle
+attr actualImageResource
+attr actualImageScaleType
+attr actualImageUri
+attr alertDialogButtonGroupStyle
+attr alertDialogCenterButtons
+attr alertDialogStyle
+attr alertDialogTheme
+attr allowStacking
+attr alpha
+attr alphabeticModifiers
+attr arrowHeadLength
+attr arrowShaftLength
+attr autoCompleteTextViewStyle
+attr autoSizeMaxTextSize
+attr autoSizeMinTextSize
+attr autoSizePresetSizes
+attr autoSizeStepGranularity
+attr autoSizeTextType
+attr autofillInlineSuggestionChip
+attr autofillInlineSuggestionEndIconStyle
+attr autofillInlineSuggestionStartIconStyle
+attr autofillInlineSuggestionSubtitle
+attr autofillInlineSuggestionTitle
+attr background
+attr backgroundImage
+attr backgroundSplit
+attr backgroundStacked
+attr backgroundTint
+attr backgroundTintMode
+attr barLength
+attr borderlessButtonStyle
+attr buttonBarButtonStyle
+attr buttonBarNegativeButtonStyle
+attr buttonBarNeutralButtonStyle
+attr buttonBarPositiveButtonStyle
+attr buttonBarStyle
+attr buttonGravity
+attr buttonIconDimen
+attr buttonPanelSideLayout
+attr buttonStyle
+attr buttonStyleSmall
+attr buttonTint
+attr buttonTintMode
+attr checkboxStyle
+attr checkedTextViewStyle
+attr closeIcon
+attr closeItemLayout
+attr collapseContentDescription
+attr collapseIcon
+attr color
+attr colorAccent
+attr colorBackgroundFloating
+attr colorButtonNormal
+attr colorControlActivated
+attr colorControlHighlight
+attr colorControlNormal
+attr colorError
+attr colorPrimary
+attr colorPrimaryDark
+attr colorSwitchThumbNormal
+attr commitIcon
+attr contentDescription
+attr contentInsetEnd
+attr contentInsetEndWithActions
+attr contentInsetLeft
+attr contentInsetRight
+attr contentInsetStart
+attr contentInsetStartWithNavigation
+attr controlBackground
+attr coordinatorLayoutStyle
+attr customNavigationLayout
+attr defaultQueryHint
+attr dialogCornerRadius
+attr dialogPreferredPadding
+attr dialogTheme
+attr displayOptions
+attr divider
+attr dividerHorizontal
+attr dividerPadding
+attr dividerVertical
+attr drawableSize
+attr drawerArrowStyle
+attr dropDownListViewStyle
+attr dropdownListPreferredItemHeight
+attr editTextBackground
+attr editTextColor
+attr editTextStyle
+attr elevation
+attr expandActivityOverflowButtonDrawable
+attr fadeDuration
+attr failureImage
+attr failureImageScaleType
+attr firstBaselineToTopHeight
+attr font
+attr fontFamily
+attr fontProviderAuthority
+attr fontProviderCerts
+attr fontProviderFetchStrategy
+attr fontProviderFetchTimeout
+attr fontProviderPackage
+attr fontProviderQuery
+attr fontStyle
+attr fontVariationSettings
+attr fontWeight
+attr gapBetweenBars
+attr goIcon
+attr height
+attr hideOnContentScroll
+attr homeAsUpIndicator
+attr homeLayout
+attr icon
+attr iconTint
+attr iconTintMode
+attr iconifiedByDefault
+attr imageButtonStyle
+attr indeterminateProgressStyle
+attr initialActivityCount
+attr isAutofillInlineSuggestionTheme
+attr isLightTheme
+attr itemPadding
+attr keylines
+attr lastBaselineToBottomHeight
+attr layout
+attr layout_anchor
+attr layout_anchorGravity
+attr layout_behavior
+attr layout_dodgeInsetEdges
+attr layout_insetEdge
+attr layout_keyline
+attr lineHeight
+attr listChoiceBackgroundIndicator
+attr listDividerAlertDialog
+attr listItemLayout
+attr listLayout
+attr listMenuViewStyle
+attr listPopupWindowStyle
+attr listPreferredItemHeight
+attr listPreferredItemHeightLarge
+attr listPreferredItemHeightSmall
+attr listPreferredItemPaddingLeft
+attr listPreferredItemPaddingRight
+attr logo
+attr logoDescription
+attr maxButtonHeight
+attr measureWithLargestChild
+attr multiChoiceItemLayout
+attr navigationContentDescription
+attr navigationIcon
+attr navigationMode
+attr numericModifiers
+attr overlapAnchor
+attr overlayImage
+attr paddingBottomNoButtons
+attr paddingEnd
+attr paddingStart
+attr paddingTopNoTitle
+attr panelBackground
+attr panelMenuListTheme
+attr panelMenuListWidth
+attr placeholderImage
+attr placeholderImageScaleType
+attr popupMenuStyle
+attr popupTheme
+attr popupWindowStyle
+attr preserveIconSpacing
+attr pressedStateOverlayImage
+attr progressBarAutoRotateInterval
+attr progressBarImage
+attr progressBarImageScaleType
+attr progressBarPadding
+attr progressBarStyle
+attr queryBackground
+attr queryHint
+attr radioButtonStyle
+attr ratingBarStyle
+attr ratingBarStyleIndicator
+attr ratingBarStyleSmall
+attr retryImage
+attr retryImageScaleType
+attr roundAsCircle
+attr roundBottomEnd
+attr roundBottomLeft
+attr roundBottomRight
+attr roundBottomStart
+attr roundTopEnd
+attr roundTopLeft
+attr roundTopRight
+attr roundTopStart
+attr roundWithOverlayColor
+attr roundedCornerRadius
+attr roundingBorderColor
+attr roundingBorderPadding
+attr roundingBorderWidth
+attr searchHintIcon
+attr searchIcon
+attr searchViewStyle
+attr seekBarStyle
+attr selectableItemBackground
+attr selectableItemBackgroundBorderless
+attr showAsAction
+attr showDividers
+attr showText
+attr showTitle
+attr singleChoiceItemLayout
+attr spinBars
+attr spinnerDropDownItemStyle
+attr spinnerStyle
+attr splitTrack
+attr srcCompat
+attr state_above_anchor
+attr statusBarBackground
+attr subMenuArrow
+attr submitBackground
+attr subtitle
+attr subtitleTextAppearance
+attr subtitleTextColor
+attr subtitleTextStyle
+attr suggestionRowLayout
+attr switchMinWidth
+attr switchPadding
+attr switchStyle
+attr switchTextAppearance
+attr textAllCaps
+attr textAppearanceLargePopupMenu
+attr textAppearanceListItem
+attr textAppearanceListItemSecondary
+attr textAppearanceListItemSmall
+attr textAppearancePopupMenuHeader
+attr textAppearanceSearchResultSubtitle
+attr textAppearanceSearchResultTitle
+attr textAppearanceSmallPopupMenu
+attr textColorAlertDialogListItem
+attr textColorSearchUrl
+attr theme
+attr thickness
+attr thumbTextPadding
+attr thumbTint
+attr thumbTintMode
+attr tickMark
+attr tickMarkTint
+attr tickMarkTintMode
+attr tint
+attr tintMode
+attr title
+attr titleMargin
+attr titleMarginBottom
+attr titleMarginEnd
+attr titleMarginStart
+attr titleMarginTop
+attr titleMargins
+attr titleTextAppearance
+attr titleTextColor
+attr titleTextStyle
+attr toolbarNavigationButtonStyle
+attr toolbarStyle
+attr tooltipForegroundColor
+attr tooltipFrameBackground
+attr tooltipText
+attr track
+attr trackTint
+attr trackTintMode
+attr ttcIndex
+attr viewAspectRatio
+attr viewInflaterClass
+attr voiceIcon
+attr windowActionBar
+attr windowActionBarOverlay
+attr windowActionModeOverlay
+attr windowFixedHeightMajor
+attr windowFixedHeightMinor
+attr windowFixedWidthMajor
+attr windowFixedWidthMinor
+attr windowMinWidthMajor
+attr windowMinWidthMinor
+attr windowNoTitle
+bool abc_action_bar_embed_tabs
+bool abc_allow_stacked_button_bar
+bool abc_config_actionMenuItemAllCaps
+color abc_background_cache_hint_selector_material_dark
+color abc_background_cache_hint_selector_material_light
+color abc_btn_colored_borderless_text_material
+color abc_btn_colored_text_material
+color abc_color_highlight_material
+color abc_hint_foreground_material_dark
+color abc_hint_foreground_material_light
+color abc_input_method_navigation_guard
+color abc_primary_text_disable_only_material_dark
+color abc_primary_text_disable_only_material_light
+color abc_primary_text_material_dark
+color abc_primary_text_material_light
+color abc_search_url_text
+color abc_search_url_text_normal
+color abc_search_url_text_pressed
+color abc_search_url_text_selected
+color abc_secondary_text_material_dark
+color abc_secondary_text_material_light
+color abc_tint_btn_checkable
+color abc_tint_default
+color abc_tint_edittext
+color abc_tint_seek_thumb
+color abc_tint_spinner
+color abc_tint_switch_track
+color accent_material_dark
+color accent_material_light
+color background_floating_material_dark
+color background_floating_material_light
+color background_material_dark
+color background_material_light
+color bright_foreground_disabled_material_dark
+color bright_foreground_disabled_material_light
+color bright_foreground_inverse_material_dark
+color bright_foreground_inverse_material_light
+color bright_foreground_material_dark
+color bright_foreground_material_light
+color button_material_dark
+color button_material_light
+color catalyst_logbox_background
+color catalyst_redbox_background
+color dim_foreground_disabled_material_dark
+color dim_foreground_disabled_material_light
+color dim_foreground_material_dark
+color dim_foreground_material_light
+color error_color_material_dark
+color error_color_material_light
+color foreground_material_dark
+color foreground_material_light
+color highlighted_text_material_dark
+color highlighted_text_material_light
+color material_blue_grey_800
+color material_blue_grey_900
+color material_blue_grey_950
+color material_deep_teal_200
+color material_deep_teal_500
+color material_grey_100
+color material_grey_300
+color material_grey_50
+color material_grey_600
+color material_grey_800
+color material_grey_850
+color material_grey_900
+color notification_action_color_filter
+color notification_icon_bg_color
+color primary_dark_material_dark
+color primary_dark_material_light
+color primary_material_dark
+color primary_material_light
+color primary_text_default_material_dark
+color primary_text_default_material_light
+color primary_text_disabled_material_dark
+color primary_text_disabled_material_light
+color ripple_material_dark
+color ripple_material_light
+color secondary_text_default_material_dark
+color secondary_text_default_material_light
+color secondary_text_disabled_material_dark
+color secondary_text_disabled_material_light
+color switch_thumb_disabled_material_dark
+color switch_thumb_disabled_material_light
+color switch_thumb_material_dark
+color switch_thumb_material_light
+color switch_thumb_normal_material_dark
+color switch_thumb_normal_material_light
+color tooltip_background_dark
+color tooltip_background_light
+dimen abc_action_bar_content_inset_material
+dimen abc_action_bar_content_inset_with_nav
+dimen abc_action_bar_default_height_material
+dimen abc_action_bar_default_padding_end_material
+dimen abc_action_bar_default_padding_start_material
+dimen abc_action_bar_elevation_material
+dimen abc_action_bar_icon_vertical_padding_material
+dimen abc_action_bar_overflow_padding_end_material
+dimen abc_action_bar_overflow_padding_start_material
+dimen abc_action_bar_stacked_max_height
+dimen abc_action_bar_stacked_tab_max_width
+dimen abc_action_bar_subtitle_bottom_margin_material
+dimen abc_action_bar_subtitle_top_margin_material
+dimen abc_action_button_min_height_material
+dimen abc_action_button_min_width_material
+dimen abc_action_button_min_width_overflow_material
+dimen abc_alert_dialog_button_bar_height
+dimen abc_alert_dialog_button_dimen
+dimen abc_button_inset_horizontal_material
+dimen abc_button_inset_vertical_material
+dimen abc_button_padding_horizontal_material
+dimen abc_button_padding_vertical_material
+dimen abc_cascading_menus_min_smallest_width
+dimen abc_config_prefDialogWidth
+dimen abc_control_corner_material
+dimen abc_control_inset_material
+dimen abc_control_padding_material
+dimen abc_dialog_corner_radius_material
+dimen abc_dialog_fixed_height_major
+dimen abc_dialog_fixed_height_minor
+dimen abc_dialog_fixed_width_major
+dimen abc_dialog_fixed_width_minor
+dimen abc_dialog_list_padding_bottom_no_buttons
+dimen abc_dialog_list_padding_top_no_title
+dimen abc_dialog_min_width_major
+dimen abc_dialog_min_width_minor
+dimen abc_dialog_padding_material
+dimen abc_dialog_padding_top_material
+dimen abc_dialog_title_divider_material
+dimen abc_disabled_alpha_material_dark
+dimen abc_disabled_alpha_material_light
+dimen abc_dropdownitem_icon_width
+dimen abc_dropdownitem_text_padding_left
+dimen abc_dropdownitem_text_padding_right
+dimen abc_edit_text_inset_bottom_material
+dimen abc_edit_text_inset_horizontal_material
+dimen abc_edit_text_inset_top_material
+dimen abc_floating_window_z
+dimen abc_list_item_padding_horizontal_material
+dimen abc_panel_menu_list_width
+dimen abc_progress_bar_height_material
+dimen abc_search_view_preferred_height
+dimen abc_search_view_preferred_width
+dimen abc_seekbar_track_background_height_material
+dimen abc_seekbar_track_progress_height_material
+dimen abc_select_dialog_padding_start_material
+dimen abc_switch_padding
+dimen abc_text_size_body_1_material
+dimen abc_text_size_body_2_material
+dimen abc_text_size_button_material
+dimen abc_text_size_caption_material
+dimen abc_text_size_display_1_material
+dimen abc_text_size_display_2_material
+dimen abc_text_size_display_3_material
+dimen abc_text_size_display_4_material
+dimen abc_text_size_headline_material
+dimen abc_text_size_large_material
+dimen abc_text_size_medium_material
+dimen abc_text_size_menu_header_material
+dimen abc_text_size_menu_material
+dimen abc_text_size_small_material
+dimen abc_text_size_subhead_material
+dimen abc_text_size_subtitle_material_toolbar
+dimen abc_text_size_title_material
+dimen abc_text_size_title_material_toolbar
+dimen autofill_inline_suggestion_icon_size
+dimen compat_button_inset_horizontal_material
+dimen compat_button_inset_vertical_material
+dimen compat_button_padding_horizontal_material
+dimen compat_button_padding_vertical_material
+dimen compat_control_corner_material
+dimen compat_notification_large_icon_max_height
+dimen compat_notification_large_icon_max_width
+dimen disabled_alpha_material_dark
+dimen disabled_alpha_material_light
+dimen highlight_alpha_material_colored
+dimen highlight_alpha_material_dark
+dimen highlight_alpha_material_light
+dimen hint_alpha_material_dark
+dimen hint_alpha_material_light
+dimen hint_pressed_alpha_material_dark
+dimen hint_pressed_alpha_material_light
+dimen notification_action_icon_size
+dimen notification_action_text_size
+dimen notification_big_circle_margin
+dimen notification_content_margin_start
+dimen notification_large_icon_height
+dimen notification_large_icon_width
+dimen notification_main_column_padding_top
+dimen notification_media_narrow_margin
+dimen notification_right_icon_size
+dimen notification_right_side_padding_top
+dimen notification_small_icon_background_padding
+dimen notification_small_icon_size_as_large
+dimen notification_subtext_size
+dimen notification_top_pad
+dimen notification_top_pad_large_text
+dimen tooltip_corner_radius
+dimen tooltip_horizontal_padding
+dimen tooltip_margin
+dimen tooltip_precise_anchor_extra_offset
+dimen tooltip_precise_anchor_threshold
+dimen tooltip_vertical_padding
+dimen tooltip_y_offset_non_touch
+dimen tooltip_y_offset_touch
+drawable abc_ab_share_pack_mtrl_alpha
+drawable abc_action_bar_item_background_material
+drawable abc_btn_borderless_material
+drawable abc_btn_check_material
+drawable abc_btn_check_to_on_mtrl_000
+drawable abc_btn_check_to_on_mtrl_015
+drawable abc_btn_colored_material
+drawable abc_btn_default_mtrl_shape
+drawable abc_btn_radio_material
+drawable abc_btn_radio_to_on_mtrl_000
+drawable abc_btn_radio_to_on_mtrl_015
+drawable abc_btn_switch_to_on_mtrl_00001
+drawable abc_btn_switch_to_on_mtrl_00012
+drawable abc_cab_background_internal_bg
+drawable abc_cab_background_top_material
+drawable abc_cab_background_top_mtrl_alpha
+drawable abc_control_background_material
+drawable abc_dialog_material_background
+drawable abc_edit_text_material
+drawable abc_ic_ab_back_material
+drawable abc_ic_arrow_drop_right_black_24dp
+drawable abc_ic_clear_material
+drawable abc_ic_commit_search_api_mtrl_alpha
+drawable abc_ic_go_search_api_material
+drawable abc_ic_menu_copy_mtrl_am_alpha
+drawable abc_ic_menu_cut_mtrl_alpha
+drawable abc_ic_menu_overflow_material
+drawable abc_ic_menu_paste_mtrl_am_alpha
+drawable abc_ic_menu_selectall_mtrl_alpha
+drawable abc_ic_menu_share_mtrl_alpha
+drawable abc_ic_search_api_material
+drawable abc_ic_star_black_16dp
+drawable abc_ic_star_black_36dp
+drawable abc_ic_star_black_48dp
+drawable abc_ic_star_half_black_16dp
+drawable abc_ic_star_half_black_36dp
+drawable abc_ic_star_half_black_48dp
+drawable abc_ic_voice_search_api_material
+drawable abc_item_background_holo_dark
+drawable abc_item_background_holo_light
+drawable abc_list_divider_material
+drawable abc_list_divider_mtrl_alpha
+drawable abc_list_focused_holo
+drawable abc_list_longpressed_holo
+drawable abc_list_pressed_holo_dark
+drawable abc_list_pressed_holo_light
+drawable abc_list_selector_background_transition_holo_dark
+drawable abc_list_selector_background_transition_holo_light
+drawable abc_list_selector_disabled_holo_dark
+drawable abc_list_selector_disabled_holo_light
+drawable abc_list_selector_holo_dark
+drawable abc_list_selector_holo_light
+drawable abc_menu_hardkey_panel_mtrl_mult
+drawable abc_popup_background_mtrl_mult
+drawable abc_ratingbar_indicator_material
+drawable abc_ratingbar_material
+drawable abc_ratingbar_small_material
+drawable abc_scrubber_control_off_mtrl_alpha
+drawable abc_scrubber_control_to_pressed_mtrl_000
+drawable abc_scrubber_control_to_pressed_mtrl_005
+drawable abc_scrubber_primary_mtrl_alpha
+drawable abc_scrubber_track_mtrl_alpha
+drawable abc_seekbar_thumb_material
+drawable abc_seekbar_tick_mark_material
+drawable abc_seekbar_track_material
+drawable abc_spinner_mtrl_am_alpha
+drawable abc_spinner_textfield_background_material
+drawable abc_switch_thumb_material
+drawable abc_switch_track_mtrl_alpha
+drawable abc_tab_indicator_material
+drawable abc_tab_indicator_mtrl_alpha
+drawable abc_text_cursor_material
+drawable abc_text_select_handle_left_mtrl_dark
+drawable abc_text_select_handle_left_mtrl_light
+drawable abc_text_select_handle_middle_mtrl_dark
+drawable abc_text_select_handle_middle_mtrl_light
+drawable abc_text_select_handle_right_mtrl_dark
+drawable abc_text_select_handle_right_mtrl_light
+drawable abc_textfield_activated_mtrl_alpha
+drawable abc_textfield_default_mtrl_alpha
+drawable abc_textfield_search_activated_mtrl_alpha
+drawable abc_textfield_search_default_mtrl_alpha
+drawable abc_textfield_search_material
+drawable abc_vector_test
+drawable autofill_inline_suggestion_chip_background
+drawable notification_action_background
+drawable notification_bg
+drawable notification_bg_low
+drawable notification_bg_low_normal
+drawable notification_bg_low_pressed
+drawable notification_bg_normal
+drawable notification_bg_normal_pressed
+drawable notification_icon_background
+drawable notification_template_icon_bg
+drawable notification_template_icon_low_bg
+drawable notification_tile_bg
+drawable notify_panel_notification_icon_bg
+drawable redbox_top_border_background
+drawable tooltip_frame_dark
+drawable tooltip_frame_light
+id accessibility_action_clickable_span
+id accessibility_actions
+id accessibility_custom_action_0
+id accessibility_custom_action_1
+id accessibility_custom_action_10
+id accessibility_custom_action_11
+id accessibility_custom_action_12
+id accessibility_custom_action_13
+id accessibility_custom_action_14
+id accessibility_custom_action_15
+id accessibility_custom_action_16
+id accessibility_custom_action_17
+id accessibility_custom_action_18
+id accessibility_custom_action_19
+id accessibility_custom_action_2
+id accessibility_custom_action_20
+id accessibility_custom_action_21
+id accessibility_custom_action_22
+id accessibility_custom_action_23
+id accessibility_custom_action_24
+id accessibility_custom_action_25
+id accessibility_custom_action_26
+id accessibility_custom_action_27
+id accessibility_custom_action_28
+id accessibility_custom_action_29
+id accessibility_custom_action_3
+id accessibility_custom_action_30
+id accessibility_custom_action_31
+id accessibility_custom_action_4
+id accessibility_custom_action_5
+id accessibility_custom_action_6
+id accessibility_custom_action_7
+id accessibility_custom_action_8
+id accessibility_custom_action_9
+id accessibility_hint
+id accessibility_label
+id accessibility_role
+id accessibility_state
+id accessibility_value
+id action_bar
+id action_bar_activity_content
+id action_bar_container
+id action_bar_root
+id action_bar_spinner
+id action_bar_subtitle
+id action_bar_title
+id action_container
+id action_context_bar
+id action_divider
+id action_image
+id action_menu_divider
+id action_menu_presenter
+id action_mode_bar
+id action_mode_bar_stub
+id action_mode_close_button
+id action_text
+id actions
+id activity_chooser_view_content
+id add
+id alertTitle
+id async
+id autofill_inline_suggestion_end_icon
+id autofill_inline_suggestion_start_icon
+id autofill_inline_suggestion_subtitle
+id autofill_inline_suggestion_title
+id blocking
+id bottom
+id buttonPanel
+id catalyst_redbox_title
+id center
+id centerCrop
+id centerInside
+id checkbox
+id chronometer
+id content
+id contentPanel
+id custom
+id customPanel
+id decor_content_parent
+id default_activity_button
+id dialog_button
+id edit_query
+id end
+id expand_activities_button
+id expanded_menu
+id fitBottomStart
+id fitCenter
+id fitEnd
+id fitStart
+id fitXY
+id focusCrop
+id forever
+id fps_text
+id group_divider
+id home
+id icon
+id icon_group
+id image
+id info
+id italic
+id labelled_by
+id left
+id line1
+id line3
+id listMode
+id list_item
+id message
+id multiply
+id none
+id normal
+id notification_background
+id notification_main_column
+id notification_main_column_container
+id parentPanel
+id pointer_enter
+id pointer_leave
+id pointer_move
+id progress_circular
+id progress_horizontal
+id radio
+id react_test_id
+id right
+id right_icon
+id right_side
+id rn_frame_file
+id rn_frame_method
+id rn_redbox_dismiss_button
+id rn_redbox_line_separator
+id rn_redbox_loading_indicator
+id rn_redbox_reload_button
+id rn_redbox_report_button
+id rn_redbox_report_label
+id rn_redbox_stack
+id screen
+id scrollIndicatorDown
+id scrollIndicatorUp
+id scrollView
+id search_badge
+id search_bar
+id search_button
+id search_close_btn
+id search_edit_frame
+id search_go_btn
+id search_mag_icon
+id search_plate
+id search_src_text
+id search_voice_btn
+id select_dialog_listview
+id shortcut
+id spacer
+id split_action_bar
+id src_atop
+id src_in
+id src_over
+id start
+id submenuarrow
+id submit_area
+id tabMode
+id tag_accessibility_actions
+id tag_accessibility_clickable_spans
+id tag_accessibility_heading
+id tag_accessibility_pane_title
+id tag_screen_reader_focusable
+id tag_transition_group
+id tag_unhandled_key_event_manager
+id tag_unhandled_key_listeners
+id text
+id text2
+id textSpacerNoButtons
+id textSpacerNoTitle
+id time
+id title
+id titleDividerNoCustom
+id title_template
+id top
+id topPanel
+id uniform
+id up
+id view_tag_instance_handle
+id view_tag_native_id
+id wrap_content
+integer abc_config_activityDefaultDur
+integer abc_config_activityShortDur
+integer cancel_button_image_alpha
+integer config_tooltipAnimTime
+integer react_native_dev_server_port
+integer react_native_inspector_proxy_port
+integer status_bar_notification_info_maxnum
+layout abc_action_bar_title_item
+layout abc_action_bar_up_container
+layout abc_action_menu_item_layout
+layout abc_action_menu_layout
+layout abc_action_mode_bar
+layout abc_action_mode_close_item_material
+layout abc_activity_chooser_view
+layout abc_activity_chooser_view_list_item
+layout abc_alert_dialog_button_bar_material
+layout abc_alert_dialog_material
+layout abc_alert_dialog_title_material
+layout abc_cascading_menu_item_layout
+layout abc_dialog_title_material
+layout abc_expanded_menu_layout
+layout abc_list_menu_item_checkbox
+layout abc_list_menu_item_icon
+layout abc_list_menu_item_layout
+layout abc_list_menu_item_radio
+layout abc_popup_menu_header_item_layout
+layout abc_popup_menu_item_layout
+layout abc_screen_content_include
+layout abc_screen_simple
+layout abc_screen_simple_overlay_action_mode
+layout abc_screen_toolbar
+layout abc_search_dropdown_item_icons_2line
+layout abc_search_view
+layout abc_select_dialog_material
+layout abc_tooltip
+layout autofill_inline_suggestion
+layout custom_dialog
+layout dev_loading_view
+layout fps_view
+layout notification_action
+layout notification_action_tombstone
+layout notification_template_custom_big
+layout notification_template_icon_group
+layout notification_template_part_chronometer
+layout notification_template_part_time
+layout redbox_item_frame
+layout redbox_item_title
+layout redbox_view
+layout select_dialog_item_material
+layout select_dialog_multichoice_material
+layout select_dialog_singlechoice_material
+layout support_simple_spinner_dropdown_item
+string abc_action_bar_home_description
+string abc_action_bar_up_description
+string abc_action_menu_overflow_description
+string abc_action_mode_done
+string abc_activity_chooser_view_see_all
+string abc_activitychooserview_choose_application
+string abc_capital_off
+string abc_capital_on
+string abc_font_family_body_1_material
+string abc_font_family_body_2_material
+string abc_font_family_button_material
+string abc_font_family_caption_material
+string abc_font_family_display_1_material
+string abc_font_family_display_2_material
+string abc_font_family_display_3_material
+string abc_font_family_display_4_material
+string abc_font_family_headline_material
+string abc_font_family_menu_material
+string abc_font_family_subhead_material
+string abc_font_family_title_material
+string abc_menu_alt_shortcut_label
+string abc_menu_ctrl_shortcut_label
+string abc_menu_delete_shortcut_label
+string abc_menu_enter_shortcut_label
+string abc_menu_function_shortcut_label
+string abc_menu_meta_shortcut_label
+string abc_menu_shift_shortcut_label
+string abc_menu_space_shortcut_label
+string abc_menu_sym_shortcut_label
+string abc_prepend_shortcut_label
+string abc_search_hint
+string abc_searchview_description_clear
+string abc_searchview_description_query
+string abc_searchview_description_search
+string abc_searchview_description_submit
+string abc_searchview_description_voice
+string abc_shareactionprovider_share_with
+string abc_shareactionprovider_share_with_application
+string abc_toolbar_collapse_description
+string alert_description
+string catalyst_change_bundle_location
+string catalyst_copy_button
+string catalyst_debug
+string catalyst_debug_chrome
+string catalyst_debug_chrome_stop
+string catalyst_debug_connecting
+string catalyst_debug_error
+string catalyst_debug_open
+string catalyst_debug_stop
+string catalyst_devtools_open
+string catalyst_dismiss_button
+string catalyst_heap_capture
+string catalyst_hot_reloading
+string catalyst_hot_reloading_auto_disable
+string catalyst_hot_reloading_auto_enable
+string catalyst_hot_reloading_stop
+string catalyst_inspector
+string catalyst_inspector_stop
+string catalyst_loading_from_url
+string catalyst_open_flipper_error
+string catalyst_perf_monitor
+string catalyst_perf_monitor_stop
+string catalyst_reload
+string catalyst_reload_button
+string catalyst_reload_error
+string catalyst_report_button
+string catalyst_sample_profiler_disable
+string catalyst_sample_profiler_enable
+string catalyst_settings
+string catalyst_settings_title
+string combobox_description
+string header_description
+string image_description
+string imagebutton_description
+string link_description
+string menu_description
+string menubar_description
+string menuitem_description
+string progressbar_description
+string radiogroup_description
+string rn_tab_description
+string scrollbar_description
+string search_menu_title
+string spinbutton_description
+string state_busy_description
+string state_collapsed_description
+string state_expanded_description
+string state_mixed_description
+string state_off_description
+string state_on_description
+string state_unselected_description
+string status_bar_notification_info_overflow
+string summary_description
+string tablist_description
+string timer_description
+string toolbar_description
+style AlertDialog_AppCompat
+style AlertDialog_AppCompat_Light
+style Animation_AppCompat_Dialog
+style Animation_AppCompat_DropDownUp
+style Animation_AppCompat_Tooltip
+style Animation_Catalyst_LogBox
+style Animation_Catalyst_RedBox
+style Base_AlertDialog_AppCompat
+style Base_AlertDialog_AppCompat_Light
+style Base_Animation_AppCompat_Dialog
+style Base_Animation_AppCompat_DropDownUp
+style Base_Animation_AppCompat_Tooltip
+style Base_DialogWindowTitleBackground_AppCompat
+style Base_DialogWindowTitle_AppCompat
+style Base_TextAppearance_AppCompat
+style Base_TextAppearance_AppCompat_Body1
+style Base_TextAppearance_AppCompat_Body2
+style Base_TextAppearance_AppCompat_Button
+style Base_TextAppearance_AppCompat_Caption
+style Base_TextAppearance_AppCompat_Display1
+style Base_TextAppearance_AppCompat_Display2
+style Base_TextAppearance_AppCompat_Display3
+style Base_TextAppearance_AppCompat_Display4
+style Base_TextAppearance_AppCompat_Headline
+style Base_TextAppearance_AppCompat_Inverse
+style Base_TextAppearance_AppCompat_Large
+style Base_TextAppearance_AppCompat_Large_Inverse
+style Base_TextAppearance_AppCompat_Light_Widget_PopupMenu_Large
+style Base_TextAppearance_AppCompat_Light_Widget_PopupMenu_Small
+style Base_TextAppearance_AppCompat_Medium
+style Base_TextAppearance_AppCompat_Medium_Inverse
+style Base_TextAppearance_AppCompat_Menu
+style Base_TextAppearance_AppCompat_SearchResult
+style Base_TextAppearance_AppCompat_SearchResult_Subtitle
+style Base_TextAppearance_AppCompat_SearchResult_Title
+style Base_TextAppearance_AppCompat_Small
+style Base_TextAppearance_AppCompat_Small_Inverse
+style Base_TextAppearance_AppCompat_Subhead
+style Base_TextAppearance_AppCompat_Subhead_Inverse
+style Base_TextAppearance_AppCompat_Title
+style Base_TextAppearance_AppCompat_Title_Inverse
+style Base_TextAppearance_AppCompat_Tooltip
+style Base_TextAppearance_AppCompat_Widget_ActionBar_Menu
+style Base_TextAppearance_AppCompat_Widget_ActionBar_Subtitle
+style Base_TextAppearance_AppCompat_Widget_ActionBar_Subtitle_Inverse
+style Base_TextAppearance_AppCompat_Widget_ActionBar_Title
+style Base_TextAppearance_AppCompat_Widget_ActionBar_Title_Inverse
+style Base_TextAppearance_AppCompat_Widget_ActionMode_Subtitle
+style Base_TextAppearance_AppCompat_Widget_ActionMode_Title
+style Base_TextAppearance_AppCompat_Widget_Button
+style Base_TextAppearance_AppCompat_Widget_Button_Borderless_Colored
+style Base_TextAppearance_AppCompat_Widget_Button_Colored
+style Base_TextAppearance_AppCompat_Widget_Button_Inverse
+style Base_TextAppearance_AppCompat_Widget_DropDownItem
+style Base_TextAppearance_AppCompat_Widget_PopupMenu_Header
+style Base_TextAppearance_AppCompat_Widget_PopupMenu_Large
+style Base_TextAppearance_AppCompat_Widget_PopupMenu_Small
+style Base_TextAppearance_AppCompat_Widget_Switch
+style Base_TextAppearance_AppCompat_Widget_TextView_SpinnerItem
+style Base_TextAppearance_Widget_AppCompat_ExpandedMenu_Item
+style Base_TextAppearance_Widget_AppCompat_Toolbar_Subtitle
+style Base_TextAppearance_Widget_AppCompat_Toolbar_Title
+style Base_ThemeOverlay_AppCompat
+style Base_ThemeOverlay_AppCompat_ActionBar
+style Base_ThemeOverlay_AppCompat_Dark
+style Base_ThemeOverlay_AppCompat_Dark_ActionBar
+style Base_ThemeOverlay_AppCompat_Dialog
+style Base_ThemeOverlay_AppCompat_Dialog_Alert
+style Base_ThemeOverlay_AppCompat_Light
+style Base_Theme_AppCompat
+style Base_Theme_AppCompat_CompactMenu
+style Base_Theme_AppCompat_Dialog
+style Base_Theme_AppCompat_DialogWhenLarge
+style Base_Theme_AppCompat_Dialog_Alert
+style Base_Theme_AppCompat_Dialog_FixedSize
+style Base_Theme_AppCompat_Dialog_MinWidth
+style Base_Theme_AppCompat_Light
+style Base_Theme_AppCompat_Light_DarkActionBar
+style Base_Theme_AppCompat_Light_Dialog
+style Base_Theme_AppCompat_Light_DialogWhenLarge
+style Base_Theme_AppCompat_Light_Dialog_Alert
+style Base_Theme_AppCompat_Light_Dialog_FixedSize
+style Base_Theme_AppCompat_Light_Dialog_MinWidth
+style Base_V21_ThemeOverlay_AppCompat_Dialog
+style Base_V21_Theme_AppCompat
+style Base_V21_Theme_AppCompat_Dialog
+style Base_V21_Theme_AppCompat_Light
+style Base_V21_Theme_AppCompat_Light_Dialog
+style Base_V22_Theme_AppCompat
+style Base_V22_Theme_AppCompat_Light
+style Base_V23_Theme_AppCompat
+style Base_V23_Theme_AppCompat_Light
+style Base_V26_Theme_AppCompat
+style Base_V26_Theme_AppCompat_Light
+style Base_V26_Widget_AppCompat_Toolbar
+style Base_V28_Theme_AppCompat
+style Base_V28_Theme_AppCompat_Light
+style Base_V7_ThemeOverlay_AppCompat_Dialog
+style Base_V7_Theme_AppCompat
+style Base_V7_Theme_AppCompat_Dialog
+style Base_V7_Theme_AppCompat_Light
+style Base_V7_Theme_AppCompat_Light_Dialog
+style Base_V7_Widget_AppCompat_AutoCompleteTextView
+style Base_V7_Widget_AppCompat_EditText
+style Base_V7_Widget_AppCompat_Toolbar
+style Base_Widget_AppCompat_ActionBar
+style Base_Widget_AppCompat_ActionBar_Solid
+style Base_Widget_AppCompat_ActionBar_TabBar
+style Base_Widget_AppCompat_ActionBar_TabText
+style Base_Widget_AppCompat_ActionBar_TabView
+style Base_Widget_AppCompat_ActionButton
+style Base_Widget_AppCompat_ActionButton_CloseMode
+style Base_Widget_AppCompat_ActionButton_Overflow
+style Base_Widget_AppCompat_ActionMode
+style Base_Widget_AppCompat_ActivityChooserView
+style Base_Widget_AppCompat_AutoCompleteTextView
+style Base_Widget_AppCompat_Button
+style Base_Widget_AppCompat_ButtonBar
+style Base_Widget_AppCompat_ButtonBar_AlertDialog
+style Base_Widget_AppCompat_Button_Borderless
+style Base_Widget_AppCompat_Button_Borderless_Colored
+style Base_Widget_AppCompat_Button_ButtonBar_AlertDialog
+style Base_Widget_AppCompat_Button_Colored
+style Base_Widget_AppCompat_Button_Small
+style Base_Widget_AppCompat_CompoundButton_CheckBox
+style Base_Widget_AppCompat_CompoundButton_RadioButton
+style Base_Widget_AppCompat_CompoundButton_Switch
+style Base_Widget_AppCompat_DrawerArrowToggle
+style Base_Widget_AppCompat_DrawerArrowToggle_Common
+style Base_Widget_AppCompat_DropDownItem_Spinner
+style Base_Widget_AppCompat_EditText
+style Base_Widget_AppCompat_ImageButton
+style Base_Widget_AppCompat_Light_ActionBar
+style Base_Widget_AppCompat_Light_ActionBar_Solid
+style Base_Widget_AppCompat_Light_ActionBar_TabBar
+style Base_Widget_AppCompat_Light_ActionBar_TabText
+style Base_Widget_AppCompat_Light_ActionBar_TabText_Inverse
+style Base_Widget_AppCompat_Light_ActionBar_TabView
+style Base_Widget_AppCompat_Light_PopupMenu
+style Base_Widget_AppCompat_Light_PopupMenu_Overflow
+style Base_Widget_AppCompat_ListMenuView
+style Base_Widget_AppCompat_ListPopupWindow
+style Base_Widget_AppCompat_ListView
+style Base_Widget_AppCompat_ListView_DropDown
+style Base_Widget_AppCompat_ListView_Menu
+style Base_Widget_AppCompat_PopupMenu
+style Base_Widget_AppCompat_PopupMenu_Overflow
+style Base_Widget_AppCompat_PopupWindow
+style Base_Widget_AppCompat_ProgressBar
+style Base_Widget_AppCompat_ProgressBar_Horizontal
+style Base_Widget_AppCompat_RatingBar
+style Base_Widget_AppCompat_RatingBar_Indicator
+style Base_Widget_AppCompat_RatingBar_Small
+style Base_Widget_AppCompat_SearchView
+style Base_Widget_AppCompat_SearchView_ActionBar
+style Base_Widget_AppCompat_SeekBar
+style Base_Widget_AppCompat_SeekBar_Discrete
+style Base_Widget_AppCompat_Spinner
+style Base_Widget_AppCompat_Spinner_Underlined
+style Base_Widget_AppCompat_TextView_SpinnerItem
+style Base_Widget_AppCompat_Toolbar
+style Base_Widget_AppCompat_Toolbar_Button_Navigation
+style CalendarDatePickerDialog
+style CalendarDatePickerStyle
+style DialogAnimationFade
+style DialogAnimationSlide
+style Platform_AppCompat
+style Platform_AppCompat_Light
+style Platform_ThemeOverlay_AppCompat
+style Platform_ThemeOverlay_AppCompat_Dark
+style Platform_ThemeOverlay_AppCompat_Light
+style Platform_V21_AppCompat
+style Platform_V21_AppCompat_Light
+style Platform_V25_AppCompat
+style Platform_V25_AppCompat_Light
+style Platform_Widget_AppCompat_Spinner
+style RtlOverlay_DialogWindowTitle_AppCompat
+style RtlOverlay_Widget_AppCompat_ActionBar_TitleItem
+style RtlOverlay_Widget_AppCompat_DialogTitle_Icon
+style RtlOverlay_Widget_AppCompat_PopupMenuItem
+style RtlOverlay_Widget_AppCompat_PopupMenuItem_InternalGroup
+style RtlOverlay_Widget_AppCompat_PopupMenuItem_Shortcut
+style RtlOverlay_Widget_AppCompat_PopupMenuItem_SubmenuArrow
+style RtlOverlay_Widget_AppCompat_PopupMenuItem_Text
+style RtlOverlay_Widget_AppCompat_PopupMenuItem_Title
+style RtlOverlay_Widget_AppCompat_SearchView_MagIcon
+style RtlOverlay_Widget_AppCompat_Search_DropDown
+style RtlOverlay_Widget_AppCompat_Search_DropDown_Icon1
+style RtlOverlay_Widget_AppCompat_Search_DropDown_Icon2
+style RtlOverlay_Widget_AppCompat_Search_DropDown_Query
+style RtlOverlay_Widget_AppCompat_Search_DropDown_Text
+style RtlUnderlay_Widget_AppCompat_ActionButton
+style RtlUnderlay_Widget_AppCompat_ActionButton_Overflow
+style SpinnerDatePickerDialog
+style SpinnerDatePickerStyle
+style TextAppearance_AppCompat
+style TextAppearance_AppCompat_Body1
+style TextAppearance_AppCompat_Body2
+style TextAppearance_AppCompat_Button
+style TextAppearance_AppCompat_Caption
+style TextAppearance_AppCompat_Display1
+style TextAppearance_AppCompat_Display2
+style TextAppearance_AppCompat_Display3
+style TextAppearance_AppCompat_Display4
+style TextAppearance_AppCompat_Headline
+style TextAppearance_AppCompat_Inverse
+style TextAppearance_AppCompat_Large
+style TextAppearance_AppCompat_Large_Inverse
+style TextAppearance_AppCompat_Light_SearchResult_Subtitle
+style TextAppearance_AppCompat_Light_SearchResult_Title
+style TextAppearance_AppCompat_Light_Widget_PopupMenu_Large
+style TextAppearance_AppCompat_Light_Widget_PopupMenu_Small
+style TextAppearance_AppCompat_Medium
+style TextAppearance_AppCompat_Medium_Inverse
+style TextAppearance_AppCompat_Menu
+style TextAppearance_AppCompat_SearchResult_Subtitle
+style TextAppearance_AppCompat_SearchResult_Title
+style TextAppearance_AppCompat_Small
+style TextAppearance_AppCompat_Small_Inverse
+style TextAppearance_AppCompat_Subhead
+style TextAppearance_AppCompat_Subhead_Inverse
+style TextAppearance_AppCompat_Title
+style TextAppearance_AppCompat_Title_Inverse
+style TextAppearance_AppCompat_Tooltip
+style TextAppearance_AppCompat_Widget_ActionBar_Menu
+style TextAppearance_AppCompat_Widget_ActionBar_Subtitle
+style TextAppearance_AppCompat_Widget_ActionBar_Subtitle_Inverse
+style TextAppearance_AppCompat_Widget_ActionBar_Title
+style TextAppearance_AppCompat_Widget_ActionBar_Title_Inverse
+style TextAppearance_AppCompat_Widget_ActionMode_Subtitle
+style TextAppearance_AppCompat_Widget_ActionMode_Subtitle_Inverse
+style TextAppearance_AppCompat_Widget_ActionMode_Title
+style TextAppearance_AppCompat_Widget_ActionMode_Title_Inverse
+style TextAppearance_AppCompat_Widget_Button
+style TextAppearance_AppCompat_Widget_Button_Borderless_Colored
+style TextAppearance_AppCompat_Widget_Button_Colored
+style TextAppearance_AppCompat_Widget_Button_Inverse
+style TextAppearance_AppCompat_Widget_DropDownItem
+style TextAppearance_AppCompat_Widget_PopupMenu_Header
+style TextAppearance_AppCompat_Widget_PopupMenu_Large
+style TextAppearance_AppCompat_Widget_PopupMenu_Small
+style TextAppearance_AppCompat_Widget_Switch
+style TextAppearance_AppCompat_Widget_TextView_SpinnerItem
+style TextAppearance_Compat_Notification
+style TextAppearance_Compat_Notification_Info
+style TextAppearance_Compat_Notification_Line2
+style TextAppearance_Compat_Notification_Time
+style TextAppearance_Compat_Notification_Title
+style TextAppearance_Widget_AppCompat_ExpandedMenu_Item
+style TextAppearance_Widget_AppCompat_Toolbar_Subtitle
+style TextAppearance_Widget_AppCompat_Toolbar_Title
+style Theme
+style ThemeOverlay_AppCompat
+style ThemeOverlay_AppCompat_ActionBar
+style ThemeOverlay_AppCompat_Dark
+style ThemeOverlay_AppCompat_Dark_ActionBar
+style ThemeOverlay_AppCompat_Dialog
+style ThemeOverlay_AppCompat_Dialog_Alert
+style ThemeOverlay_AppCompat_Light
+style Theme_AppCompat
+style Theme_AppCompat_CompactMenu
+style Theme_AppCompat_DayNight
+style Theme_AppCompat_DayNight_DarkActionBar
+style Theme_AppCompat_DayNight_Dialog
+style Theme_AppCompat_DayNight_DialogWhenLarge
+style Theme_AppCompat_DayNight_Dialog_Alert
+style Theme_AppCompat_DayNight_Dialog_MinWidth
+style Theme_AppCompat_DayNight_NoActionBar
+style Theme_AppCompat_Dialog
+style Theme_AppCompat_DialogWhenLarge
+style Theme_AppCompat_Dialog_Alert
+style Theme_AppCompat_Dialog_MinWidth
+style Theme_AppCompat_Light
+style Theme_AppCompat_Light_DarkActionBar
+style Theme_AppCompat_Light_Dialog
+style Theme_AppCompat_Light_DialogWhenLarge
+style Theme_AppCompat_Light_Dialog_Alert
+style Theme_AppCompat_Light_Dialog_MinWidth
+style Theme_AppCompat_Light_NoActionBar
+style Theme_AppCompat_NoActionBar
+style Theme_AutofillInlineSuggestion
+style Theme_Catalyst
+style Theme_Catalyst_LogBox
+style Theme_Catalyst_RedBox
+style Theme_FullScreenDialog
+style Theme_FullScreenDialogAnimatedFade
+style Theme_FullScreenDialogAnimatedSlide
+style Theme_ReactNative_AppCompat_Light
+style Theme_ReactNative_AppCompat_Light_NoActionBar_FullScreen
+style Widget_AppCompat_ActionBar
+style Widget_AppCompat_ActionBar_Solid
+style Widget_AppCompat_ActionBar_TabBar
+style Widget_AppCompat_ActionBar_TabText
+style Widget_AppCompat_ActionBar_TabView
+style Widget_AppCompat_ActionButton
+style Widget_AppCompat_ActionButton_CloseMode
+style Widget_AppCompat_ActionButton_Overflow
+style Widget_AppCompat_ActionMode
+style Widget_AppCompat_ActivityChooserView
+style Widget_AppCompat_AutoCompleteTextView
+style Widget_AppCompat_Button
+style Widget_AppCompat_ButtonBar
+style Widget_AppCompat_ButtonBar_AlertDialog
+style Widget_AppCompat_Button_Borderless
+style Widget_AppCompat_Button_Borderless_Colored
+style Widget_AppCompat_Button_ButtonBar_AlertDialog
+style Widget_AppCompat_Button_Colored
+style Widget_AppCompat_Button_Small
+style Widget_AppCompat_CompoundButton_CheckBox
+style Widget_AppCompat_CompoundButton_RadioButton
+style Widget_AppCompat_CompoundButton_Switch
+style Widget_AppCompat_DrawerArrowToggle
+style Widget_AppCompat_DropDownItem_Spinner
+style Widget_AppCompat_EditText
+style Widget_AppCompat_ImageButton
+style Widget_AppCompat_Light_ActionBar
+style Widget_AppCompat_Light_ActionBar_Solid
+style Widget_AppCompat_Light_ActionBar_Solid_Inverse
+style Widget_AppCompat_Light_ActionBar_TabBar
+style Widget_AppCompat_Light_ActionBar_TabBar_Inverse
+style Widget_AppCompat_Light_ActionBar_TabText
+style Widget_AppCompat_Light_ActionBar_TabText_Inverse
+style Widget_AppCompat_Light_ActionBar_TabView
+style Widget_AppCompat_Light_ActionBar_TabView_Inverse
+style Widget_AppCompat_Light_ActionButton
+style Widget_AppCompat_Light_ActionButton_CloseMode
+style Widget_AppCompat_Light_ActionButton_Overflow
+style Widget_AppCompat_Light_ActionMode_Inverse
+style Widget_AppCompat_Light_ActivityChooserView
+style Widget_AppCompat_Light_AutoCompleteTextView
+style Widget_AppCompat_Light_DropDownItem_Spinner
+style Widget_AppCompat_Light_ListPopupWindow
+style Widget_AppCompat_Light_ListView_DropDown
+style Widget_AppCompat_Light_PopupMenu
+style Widget_AppCompat_Light_PopupMenu_Overflow
+style Widget_AppCompat_Light_SearchView
+style Widget_AppCompat_Light_Spinner_DropDown_ActionBar
+style Widget_AppCompat_ListMenuView
+style Widget_AppCompat_ListPopupWindow
+style Widget_AppCompat_ListView
+style Widget_AppCompat_ListView_DropDown
+style Widget_AppCompat_ListView_Menu
+style Widget_AppCompat_PopupMenu
+style Widget_AppCompat_PopupMenu_Overflow
+style Widget_AppCompat_PopupWindow
+style Widget_AppCompat_ProgressBar
+style Widget_AppCompat_ProgressBar_Horizontal
+style Widget_AppCompat_RatingBar
+style Widget_AppCompat_RatingBar_Indicator
+style Widget_AppCompat_RatingBar_Small
+style Widget_AppCompat_SearchView
+style Widget_AppCompat_SearchView_ActionBar
+style Widget_AppCompat_SeekBar
+style Widget_AppCompat_SeekBar_Discrete
+style Widget_AppCompat_Spinner
+style Widget_AppCompat_Spinner_DropDown
+style Widget_AppCompat_Spinner_DropDown_ActionBar
+style Widget_AppCompat_Spinner_Underlined
+style Widget_AppCompat_TextView_SpinnerItem
+style Widget_AppCompat_Toolbar
+style Widget_AppCompat_Toolbar_Button_Navigation
+style Widget_Autofill
+style Widget_Autofill_InlineSuggestionChip
+style Widget_Autofill_InlineSuggestionEndIconStyle
+style Widget_Autofill_InlineSuggestionStartIconStyle
+style Widget_Autofill_InlineSuggestionSubtitle
+style Widget_Autofill_InlineSuggestionTitle
+style Widget_Compat_NotificationActionContainer
+style Widget_Compat_NotificationActionText
+style Widget_Support_CoordinatorLayout
+style redboxButton
+styleable ActionBar background backgroundSplit backgroundStacked contentInsetEnd contentInsetEndWithActions contentInsetLeft contentInsetRight contentInsetStart contentInsetStartWithNavigation customNavigationLayout displayOptions divider elevation height hideOnContentScroll homeAsUpIndicator homeLayout icon indeterminateProgressStyle itemPadding logo navigationMode popupTheme progressBarPadding progressBarStyle subtitle subtitleTextStyle title titleTextStyle
+styleable ActionBarLayout android_layout_gravity
+styleable ActionMenuItemView android_minWidth
+styleable ActionMenuView
+styleable ActionMode background backgroundSplit closeItemLayout height subtitleTextStyle titleTextStyle
+styleable ActivityChooserView expandActivityOverflowButtonDrawable initialActivityCount
+styleable AlertDialog android_layout buttonIconDimen buttonPanelSideLayout listItemLayout listLayout multiChoiceItemLayout showTitle singleChoiceItemLayout
+styleable AnimatedStateListDrawableCompat android_constantSize android_dither android_enterFadeDuration android_exitFadeDuration android_variablePadding android_visible
+styleable AnimatedStateListDrawableItem android_drawable android_id
+styleable AnimatedStateListDrawableTransition android_drawable android_fromId android_reversible android_toId
+styleable AppCompatImageView android_src srcCompat tint tintMode
+styleable AppCompatSeekBar android_thumb tickMark tickMarkTint tickMarkTintMode
+styleable AppCompatTextHelper android_drawableBottom android_drawableEnd android_drawableLeft android_drawableRight android_drawableStart android_drawableTop android_textAppearance
+styleable AppCompatTextView android_textAppearance autoSizeMaxTextSize autoSizeMinTextSize autoSizePresetSizes autoSizeStepGranularity autoSizeTextType firstBaselineToTopHeight fontFamily lastBaselineToBottomHeight lineHeight textAllCaps
+styleable AppCompatTheme actionBarDivider actionBarItemBackground actionBarPopupTheme actionBarSize actionBarSplitStyle actionBarStyle actionBarTabBarStyle actionBarTabStyle actionBarTabTextStyle actionBarTheme actionBarWidgetTheme actionButtonStyle actionDropDownStyle actionMenuTextAppearance actionMenuTextColor actionModeBackground actionModeCloseButtonStyle actionModeCloseDrawable actionModeCopyDrawable actionModeCutDrawable actionModeFindDrawable actionModePasteDrawable actionModePopupWindowStyle actionModeSelectAllDrawable actionModeShareDrawable actionModeSplitBackground actionModeStyle actionModeWebSearchDrawable actionOverflowButtonStyle actionOverflowMenuStyle activityChooserViewStyle alertDialogButtonGroupStyle alertDialogCenterButtons alertDialogStyle alertDialogTheme android_windowAnimationStyle android_windowIsFloating autoCompleteTextViewStyle borderlessButtonStyle buttonBarButtonStyle buttonBarNegativeButtonStyle buttonBarNeutralButtonStyle buttonBarPositiveButtonStyle buttonBarStyle buttonStyle buttonStyleSmall checkboxStyle checkedTextViewStyle colorAccent colorBackgroundFloating colorButtonNormal colorControlActivated colorControlHighlight colorControlNormal colorError colorPrimary colorPrimaryDark colorSwitchThumbNormal controlBackground dialogCornerRadius dialogPreferredPadding dialogTheme dividerHorizontal dividerVertical dropDownListViewStyle dropdownListPreferredItemHeight editTextBackground editTextColor editTextStyle homeAsUpIndicator imageButtonStyle listChoiceBackgroundIndicator listDividerAlertDialog listMenuViewStyle listPopupWindowStyle listPreferredItemHeight listPreferredItemHeightLarge listPreferredItemHeightSmall listPreferredItemPaddingLeft listPreferredItemPaddingRight panelBackground panelMenuListTheme panelMenuListWidth popupMenuStyle popupWindowStyle radioButtonStyle ratingBarStyle ratingBarStyleIndicator ratingBarStyleSmall searchViewStyle seekBarStyle selectableItemBackground selectableItemBackgroundBorderless spinnerDropDownItemStyle spinnerStyle switchStyle textAppearanceLargePopupMenu textAppearanceListItem textAppearanceListItemSecondary textAppearanceListItemSmall textAppearancePopupMenuHeader textAppearanceSearchResultSubtitle textAppearanceSearchResultTitle textAppearanceSmallPopupMenu textColorAlertDialogListItem textColorSearchUrl toolbarNavigationButtonStyle toolbarStyle tooltipForegroundColor tooltipFrameBackground viewInflaterClass windowActionBar windowActionBarOverlay windowActionModeOverlay windowFixedHeightMajor windowFixedHeightMinor windowFixedWidthMajor windowFixedWidthMinor windowMinWidthMajor windowMinWidthMinor windowNoTitle
+styleable Autofill_InlineSuggestion autofillInlineSuggestionChip autofillInlineSuggestionEndIconStyle autofillInlineSuggestionStartIconStyle autofillInlineSuggestionSubtitle autofillInlineSuggestionTitle isAutofillInlineSuggestionTheme
+styleable ButtonBarLayout allowStacking
+styleable ColorStateListItem alpha android_alpha android_color
+styleable CompoundButton android_button buttonTint buttonTintMode
+styleable CoordinatorLayout keylines statusBarBackground
+styleable CoordinatorLayout_Layout android_layout_gravity layout_anchor layout_anchorGravity layout_behavior layout_dodgeInsetEdges layout_insetEdge layout_keyline
+styleable DrawerArrowToggle arrowHeadLength arrowShaftLength barLength color drawableSize gapBetweenBars spinBars thickness
+styleable FontFamily fontProviderAuthority fontProviderCerts fontProviderFetchStrategy fontProviderFetchTimeout fontProviderPackage fontProviderQuery
+styleable FontFamilyFont android_font android_fontStyle android_fontVariationSettings android_fontWeight android_ttcIndex font fontStyle fontVariationSettings fontWeight ttcIndex
+styleable GenericDraweeHierarchy actualImageScaleType backgroundImage fadeDuration failureImage failureImageScaleType overlayImage placeholderImage placeholderImageScaleType pressedStateOverlayImage progressBarAutoRotateInterval progressBarImage progressBarImageScaleType retryImage retryImageScaleType roundAsCircle roundBottomEnd roundBottomLeft roundBottomRight roundBottomStart roundTopEnd roundTopLeft roundTopRight roundTopStart roundWithOverlayColor roundedCornerRadius roundingBorderColor roundingBorderPadding roundingBorderWidth viewAspectRatio
+styleable GradientColor android_centerColor android_centerX android_centerY android_endColor android_endX android_endY android_gradientRadius android_startColor android_startX android_startY android_tileMode android_type
+styleable GradientColorItem android_color android_offset
+styleable LinearLayoutCompat android_baselineAligned android_baselineAlignedChildIndex android_gravity android_orientation android_weightSum divider dividerPadding measureWithLargestChild showDividers
+styleable LinearLayoutCompat_Layout android_layout_gravity android_layout_height android_layout_weight android_layout_width
+styleable ListPopupWindow android_dropDownHorizontalOffset android_dropDownVerticalOffset
+styleable MenuGroup android_checkableBehavior android_enabled android_id android_menuCategory android_orderInCategory android_visible
+styleable MenuItem actionLayout actionProviderClass actionViewClass alphabeticModifiers android_alphabeticShortcut android_checkable android_checked android_enabled android_icon android_id android_menuCategory android_numericShortcut android_onClick android_orderInCategory android_title android_titleCondensed android_visible contentDescription iconTint iconTintMode numericModifiers showAsAction tooltipText
+styleable MenuView android_headerBackground android_horizontalDivider android_itemBackground android_itemIconDisabledAlpha android_itemTextAppearance android_verticalDivider android_windowAnimationStyle preserveIconSpacing subMenuArrow
+styleable PopupWindow android_popupAnimationStyle android_popupBackground overlapAnchor
+styleable PopupWindowBackgroundState state_above_anchor
+styleable RecycleListView paddingBottomNoButtons paddingTopNoTitle
+styleable SearchView android_focusable android_imeOptions android_inputType android_maxWidth closeIcon commitIcon defaultQueryHint goIcon iconifiedByDefault layout queryBackground queryHint searchHintIcon searchIcon submitBackground suggestionRowLayout voiceIcon
+styleable SimpleDraweeView actualImageResource actualImageScaleType actualImageUri backgroundImage fadeDuration failureImage failureImageScaleType overlayImage placeholderImage placeholderImageScaleType pressedStateOverlayImage progressBarAutoRotateInterval progressBarImage progressBarImageScaleType retryImage retryImageScaleType roundAsCircle roundBottomEnd roundBottomLeft roundBottomRight roundBottomStart roundTopEnd roundTopLeft roundTopRight roundTopStart roundWithOverlayColor roundedCornerRadius roundingBorderColor roundingBorderPadding roundingBorderWidth viewAspectRatio
+styleable Spinner android_dropDownWidth android_entries android_popupBackground android_prompt popupTheme
+styleable StateListDrawable android_constantSize android_dither android_enterFadeDuration android_exitFadeDuration android_variablePadding android_visible
+styleable StateListDrawableItem android_drawable
+styleable SwitchCompat android_textOff android_textOn android_thumb showText splitTrack switchMinWidth switchPadding switchTextAppearance thumbTextPadding thumbTint thumbTintMode track trackTint trackTintMode
+styleable TextAppearance android_fontFamily android_shadowColor android_shadowDx android_shadowDy android_shadowRadius android_textColor android_textColorHint android_textColorLink android_textSize android_textStyle android_typeface fontFamily textAllCaps
+styleable Toolbar android_gravity android_minHeight buttonGravity collapseContentDescription collapseIcon contentInsetEnd contentInsetEndWithActions contentInsetLeft contentInsetRight contentInsetStart contentInsetStartWithNavigation logo logoDescription maxButtonHeight navigationContentDescription navigationIcon popupTheme subtitle subtitleTextAppearance subtitleTextColor title titleMargin titleMarginBottom titleMarginEnd titleMarginStart titleMarginTop titleMargins titleTextAppearance titleTextColor
+styleable View android_focusable android_theme paddingEnd paddingStart theme
+styleable ViewBackgroundHelper android_background backgroundTint backgroundTintMode
+styleable ViewStubCompat android_id android_inflatedId android_layout
+xml rn_dev_preferences
diff --git a/node_modules/react-native-tcp/android/build/outputs/logs/manifest-merger-debug-report.txt b/node_modules/react-native-tcp/android/build/outputs/logs/manifest-merger-debug-report.txt
new file mode 100644
index 0000000..5e7faf8
--- /dev/null
+++ b/node_modules/react-native-tcp/android/build/outputs/logs/manifest-merger-debug-report.txt
@@ -0,0 +1,29 @@
+-- Merging decision tree log ---
+manifest
+ADDED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:2:1-5:12
+INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:2:1-5:12
+INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:2:1-5:12
+	package
+		ADDED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:3:5-29
+		INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+		INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+	xmlns:android
+		ADDED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:2:11-69
+uses-permission#android.permission.INTERNET
+ADDED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:4:5-66
+	android:name
+		ADDED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml:4:22-64
+uses-sdk
+INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml reason: use-sdk injection requested
+INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+	android:targetSdkVersion
+		INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+		ADDED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+		INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+	android:minSdkVersion
+		INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+		ADDED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
+		INJECTED from /Users/osdnk/work/rainbow-priv/node_modules/react-native-tcp/android/src/main/AndroidManifest.xml
diff --git a/node_modules/react-native-tcp/android/build/tmp/compileDebugJavaWithJavac/previous-compilation-data.bin b/node_modules/react-native-tcp/android/build/tmp/compileDebugJavaWithJavac/previous-compilation-data.bin
new file mode 100644
index 0000000..1eec036
Binary files /dev/null and b/node_modules/react-native-tcp/android/build/tmp/compileDebugJavaWithJavac/previous-compilation-data.bin differ
diff --git a/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSocketManager.java b/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSocketManager.java
index df2007f..8353cd1 100644
--- a/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSocketManager.java
+++ b/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSocketManager.java
@@ -1,6 +1,6 @@
 package com.peel.react;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.SparseArray;
 
 import com.koushikdutta.async.AsyncNetworkSocket;
diff --git a/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSockets.java b/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSockets.java
index 1bc07d2..8e6d5d5 100644
--- a/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSockets.java
+++ b/node_modules/react-native-tcp/android/src/main/java/com/peel/react/TcpSockets.java
@@ -5,7 +5,7 @@
 
 package com.peel.react;
 
-import android.support.annotation.Nullable;
+import androidx.annotation.Nullable;
 import android.util.Base64;
 
 import com.facebook.common.logging.FLog;
diff --git a/node_modules/react-native-tcp/ios/CocoaAsyncSocket/GCDAsyncSocket.h b/node_modules/react-native-tcp/ios/CocoaAsyncSocket/GCDAsyncSocket.h
deleted file mode 100644
index 828951f..0000000
--- a/node_modules/react-native-tcp/ios/CocoaAsyncSocket/GCDAsyncSocket.h
+++ /dev/null
@@ -1,1210 +0,0 @@
-//  
-//  GCDAsyncSocket.h
-//  
-//  This class is in the public domain.
-//  Originally created by Robbie Hanson in Q3 2010.
-//  Updated and maintained by Deusty LLC and the Apple development community.
-//  
-//  https://github.com/robbiehanson/CocoaAsyncSocket
-//
-
-#import <Foundation/Foundation.h>
-#import <Security/Security.h>
-#import <Security/SecureTransport.h>
-#import <dispatch/dispatch.h>
-#import <Availability.h>
-
-#include <sys/socket.h> // AF_INET, AF_INET6
-
-@class GCDAsyncReadPacket;
-@class GCDAsyncWritePacket;
-@class GCDAsyncSocketPreBuffer;
-@protocol GCDAsyncSocketDelegate;
-
-NS_ASSUME_NONNULL_BEGIN
-
-extern NSString *const GCDAsyncSocketException;
-extern NSString *const GCDAsyncSocketErrorDomain;
-
-extern NSString *const GCDAsyncSocketQueueName;
-extern NSString *const GCDAsyncSocketThreadName;
-
-extern NSString *const GCDAsyncSocketManuallyEvaluateTrust;
-#if TARGET_OS_IPHONE
-extern NSString *const GCDAsyncSocketUseCFStreamForTLS;
-#endif
-#define GCDAsyncSocketSSLPeerName     (NSString *)kCFStreamSSLPeerName
-#define GCDAsyncSocketSSLCertificates (NSString *)kCFStreamSSLCertificates
-#define GCDAsyncSocketSSLIsServer     (NSString *)kCFStreamSSLIsServer
-extern NSString *const GCDAsyncSocketSSLPeerID;
-extern NSString *const GCDAsyncSocketSSLProtocolVersionMin;
-extern NSString *const GCDAsyncSocketSSLProtocolVersionMax;
-extern NSString *const GCDAsyncSocketSSLSessionOptionFalseStart;
-extern NSString *const GCDAsyncSocketSSLSessionOptionSendOneByteRecord;
-extern NSString *const GCDAsyncSocketSSLCipherSuites;
-#if !TARGET_OS_IPHONE
-extern NSString *const GCDAsyncSocketSSLDiffieHellmanParameters;
-#endif
-
-#define GCDAsyncSocketLoggingContext 65535
-
-
-typedef NS_ENUM(NSInteger, GCDAsyncSocketError) {
-	GCDAsyncSocketNoError = 0,           // Never used
-	GCDAsyncSocketBadConfigError,        // Invalid configuration
-	GCDAsyncSocketBadParamError,         // Invalid parameter was passed
-	GCDAsyncSocketConnectTimeoutError,   // A connect operation timed out
-	GCDAsyncSocketReadTimeoutError,      // A read operation timed out
-	GCDAsyncSocketWriteTimeoutError,     // A write operation timed out
-	GCDAsyncSocketReadMaxedOutError,     // Reached set maxLength without completing
-	GCDAsyncSocketClosedError,           // The remote peer closed the connection
-	GCDAsyncSocketOtherError,            // Description provided in userInfo
-};
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark -
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-
-@interface GCDAsyncSocket : NSObject
-
-/**
- * GCDAsyncSocket uses the standard delegate paradigm,
- * but executes all delegate callbacks on a given delegate dispatch queue.
- * This allows for maximum concurrency, while at the same time providing easy thread safety.
- * 
- * You MUST set a delegate AND delegate dispatch queue before attempting to
- * use the socket, or you will get an error.
- * 
- * The socket queue is optional.
- * If you pass NULL, GCDAsyncSocket will automatically create it's own socket queue.
- * If you choose to provide a socket queue, the socket queue must not be a concurrent queue.
- * If you choose to provide a socket queue, and the socket queue has a configured target queue,
- * then please see the discussion for the method markSocketQueueTargetQueue.
- * 
- * The delegate queue and socket queue can optionally be the same.
-**/
-- (instancetype)init;
-- (instancetype)initWithSocketQueue:(nullable dispatch_queue_t)sq;
-- (instancetype)initWithDelegate:(nullable id<GCDAsyncSocketDelegate>)aDelegate delegateQueue:(nullable dispatch_queue_t)dq;
-- (instancetype)initWithDelegate:(nullable id<GCDAsyncSocketDelegate>)aDelegate delegateQueue:(nullable dispatch_queue_t)dq socketQueue:(nullable dispatch_queue_t)sq;
-
-#pragma mark Configuration
-
-@property (atomic, weak, readwrite, nullable) id<GCDAsyncSocketDelegate> delegate;
-#if OS_OBJECT_USE_OBJC
-@property (atomic, strong, readwrite, nullable) dispatch_queue_t delegateQueue;
-#else
-@property (atomic, assign, readwrite, nullable) dispatch_queue_t delegateQueue;
-#endif
-
-- (void)getDelegate:(id<GCDAsyncSocketDelegate> __nullable * __nullable)delegatePtr delegateQueue:(dispatch_queue_t __nullable * __nullable)delegateQueuePtr;
-- (void)setDelegate:(nullable id<GCDAsyncSocketDelegate>)delegate delegateQueue:(nullable dispatch_queue_t)delegateQueue;
-
-/**
- * If you are setting the delegate to nil within the delegate's dealloc method,
- * you may need to use the synchronous versions below.
-**/
-- (void)synchronouslySetDelegate:(nullable id<GCDAsyncSocketDelegate>)delegate;
-- (void)synchronouslySetDelegateQueue:(nullable dispatch_queue_t)delegateQueue;
-- (void)synchronouslySetDelegate:(nullable id<GCDAsyncSocketDelegate>)delegate delegateQueue:(nullable dispatch_queue_t)delegateQueue;
-
-/**
- * By default, both IPv4 and IPv6 are enabled.
- * 
- * For accepting incoming connections, this means GCDAsyncSocket automatically supports both protocols,
- * and can simulataneously accept incoming connections on either protocol.
- * 
- * For outgoing connections, this means GCDAsyncSocket can connect to remote hosts running either protocol.
- * If a DNS lookup returns only IPv4 results, GCDAsyncSocket will automatically use IPv4.
- * If a DNS lookup returns only IPv6 results, GCDAsyncSocket will automatically use IPv6.
- * If a DNS lookup returns both IPv4 and IPv6 results, the preferred protocol will be chosen.
- * By default, the preferred protocol is IPv4, but may be configured as desired.
-**/
-
-@property (atomic, assign, readwrite, getter=isIPv4Enabled) BOOL IPv4Enabled;
-@property (atomic, assign, readwrite, getter=isIPv6Enabled) BOOL IPv6Enabled;
-
-@property (atomic, assign, readwrite, getter=isIPv4PreferredOverIPv6) BOOL IPv4PreferredOverIPv6;
-
-/** 
- * When connecting to both IPv4 and IPv6 using Happy Eyeballs (RFC 6555) https://tools.ietf.org/html/rfc6555
- * this is the delay between connecting to the preferred protocol and the fallback protocol.
- *
- * Defaults to 300ms.
-**/
-@property (atomic, assign, readwrite) NSTimeInterval alternateAddressDelay;
-
-/**
- * User data allows you to associate arbitrary information with the socket.
- * This data is not used internally by socket in any way.
-**/
-@property (atomic, strong, readwrite, nullable) id userData;
-
-#pragma mark Accepting
-
-/**
- * Tells the socket to begin listening and accepting connections on the given port.
- * When a connection is accepted, a new instance of GCDAsyncSocket will be spawned to handle it,
- * and the socket:didAcceptNewSocket: delegate method will be invoked.
- * 
- * The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)
-**/
-- (BOOL)acceptOnPort:(uint16_t)port error:(NSError **)errPtr;
-
-/**
- * This method is the same as acceptOnPort:error: with the
- * additional option of specifying which interface to listen on.
- * 
- * For example, you could specify that the socket should only accept connections over ethernet,
- * and not other interfaces such as wifi.
- * 
- * The interface may be specified by name (e.g. "en1" or "lo0") or by IP address (e.g. "192.168.4.34").
- * You may also use the special strings "localhost" or "loopback" to specify that
- * the socket only accept connections from the local machine.
- * 
- * You can see the list of interfaces via the command line utility "ifconfig",
- * or programmatically via the getifaddrs() function.
- * 
- * To accept connections on any interface pass nil, or simply use the acceptOnPort:error: method.
-**/
-- (BOOL)acceptOnInterface:(nullable NSString *)interface port:(uint16_t)port error:(NSError **)errPtr;
-
-/**
- * Tells the socket to begin listening and accepting connections on the unix domain at the given url.
- * When a connection is accepted, a new instance of GCDAsyncSocket will be spawned to handle it,
- * and the socket:didAcceptNewSocket: delegate method will be invoked.
- *
- * The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)
- **/
-- (BOOL)acceptOnUrl:(NSURL *)url error:(NSError **)errPtr;
-
-#pragma mark Connecting
-
-/**
- * Connects to the given host and port.
- * 
- * This method invokes connectToHost:onPort:viaInterface:withTimeout:error:
- * and uses the default interface, and no timeout.
-**/
-- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port error:(NSError **)errPtr;
-
-/**
- * Connects to the given host and port with an optional timeout.
- * 
- * This method invokes connectToHost:onPort:viaInterface:withTimeout:error: and uses the default interface.
-**/
-- (BOOL)connectToHost:(NSString *)host
-               onPort:(uint16_t)port
-          withTimeout:(NSTimeInterval)timeout
-                error:(NSError **)errPtr;
-
-/**
- * Connects to the given host & port, via the optional interface, with an optional timeout.
- * 
- * The host may be a domain name (e.g. "deusty.com") or an IP address string (e.g. "192.168.0.2").
- * The host may also be the special strings "localhost" or "loopback" to specify connecting
- * to a service on the local machine.
- * 
- * The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35").
- * The interface may also be used to specify the local port (see below).
- * 
- * To not time out use a negative time interval.
- * 
- * This method will return NO if an error is detected, and set the error pointer (if one was given).
- * Possible errors would be a nil host, invalid interface, or socket is already connected.
- * 
- * If no errors are detected, this method will start a background connect operation and immediately return YES.
- * The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.
- * 
- * Since this class supports queued reads and writes, you can immediately start reading and/or writing.
- * All read/write operations will be queued, and upon socket connection,
- * the operations will be dequeued and processed in order.
- * 
- * The interface may optionally contain a port number at the end of the string, separated by a colon.
- * This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end)
- * To specify both interface and local port: "en1:8082" or "192.168.4.35:2424".
- * To specify only local port: ":8082".
- * Please note this is an advanced feature, and is somewhat hidden on purpose.
- * You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection.
- * If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere.
- * Local ports do NOT need to match remote ports. In fact, they almost never do.
- * This feature is here for networking professionals using very advanced techniques.
-**/
-- (BOOL)connectToHost:(NSString *)host
-               onPort:(uint16_t)port
-         viaInterface:(nullable NSString *)interface
-          withTimeout:(NSTimeInterval)timeout
-                error:(NSError **)errPtr;
-
-/**
- * Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
- * For example, a NSData object returned from NSNetService's addresses method.
- * 
- * If you have an existing struct sockaddr you can convert it to a NSData object like so:
- * struct sockaddr sa  -> NSData *dsa = [NSData dataWithBytes:&remoteAddr length:remoteAddr.sa_len];
- * struct sockaddr *sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];
- * 
- * This method invokes connectToAdd
-**/
-- (BOOL)connectToAddress:(NSData *)remoteAddr error:(NSError **)errPtr;
-
-/**
- * This method is the same as connectToAddress:error: with an additional timeout option.
- * To not time out use a negative time interval, or simply use the connectToAddress:error: method.
-**/
-- (BOOL)connectToAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr;
-
-/**
- * Connects to the given address, using the specified interface and timeout.
- * 
- * The address is specified as a sockaddr structure wrapped in a NSData object.
- * For example, a NSData object returned from NSNetService's addresses method.
- * 
- * If you have an existing struct sockaddr you can convert it to a NSData object like so:
- * struct sockaddr sa  -> NSData *dsa = [NSData dataWithBytes:&remoteAddr length:remoteAddr.sa_len];
- * struct sockaddr *sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];
- * 
- * The interface may be a name (e.g. "en1" or "lo0") or the corresponding IP address (e.g. "192.168.4.35").
- * The interface may also be used to specify the local port (see below).
- * 
- * The timeout is optional. To not time out use a negative time interval.
- * 
- * This method will return NO if an error is detected, and set the error pointer (if one was given).
- * Possible errors would be a nil host, invalid interface, or socket is already connected.
- * 
- * If no errors are detected, this method will start a background connect operation and immediately return YES.
- * The delegate callbacks are used to notify you when the socket connects, or if the host was unreachable.
- * 
- * Since this class supports queued reads and writes, you can immediately start reading and/or writing.
- * All read/write operations will be queued, and upon socket connection,
- * the operations will be dequeued and processed in order.
- * 
- * The interface may optionally contain a port number at the end of the string, separated by a colon.
- * This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end)
- * To specify both interface and local port: "en1:8082" or "192.168.4.35:2424".
- * To specify only local port: ":8082".
- * Please note this is an advanced feature, and is somewhat hidden on purpose.
- * You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection.
- * If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere.
- * Local ports do NOT need to match remote ports. In fact, they almost never do.
- * This feature is here for networking professionals using very advanced techniques.
-**/
-- (BOOL)connectToAddress:(NSData *)remoteAddr
-            viaInterface:(nullable NSString *)interface
-             withTimeout:(NSTimeInterval)timeout
-                   error:(NSError **)errPtr;
-/**
- * Connects to the unix domain socket at the given url, using the specified timeout.
- */
-- (BOOL)connectToUrl:(NSURL *)url withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr;
-
-#pragma mark Disconnecting
-
-/**
- * Disconnects immediately (synchronously). Any pending reads or writes are dropped.
- * 
- * If the socket is not already disconnected, an invocation to the socketDidDisconnect:withError: delegate method
- * will be queued onto the delegateQueue asynchronously (behind any previously queued delegate methods).
- * In other words, the disconnected delegate method will be invoked sometime shortly after this method returns.
- * 
- * Please note the recommended way of releasing a GCDAsyncSocket instance (e.g. in a dealloc method)
- * [asyncSocket setDelegate:nil];
- * [asyncSocket disconnect];
- * [asyncSocket release];
- * 
- * If you plan on disconnecting the socket, and then immediately asking it to connect again,
- * you'll likely want to do so like this:
- * [asyncSocket setDelegate:nil];
- * [asyncSocket disconnect];
- * [asyncSocket setDelegate:self];
- * [asyncSocket connect...];
-**/
-- (void)disconnect;
-
-/**
- * Disconnects after all pending reads have completed.
- * After calling this, the read and write methods will do nothing.
- * The socket will disconnect even if there are still pending writes.
-**/
-- (void)disconnectAfterReading;
-
-/**
- * Disconnects after all pending writes have completed.
- * After calling this, the read and write methods will do nothing.
- * The socket will disconnect even if there are still pending reads.
-**/
-- (void)disconnectAfterWriting;
-
-/**
- * Disconnects after all pending reads and writes have completed.
- * After calling this, the read and write methods will do nothing.
-**/
-- (void)disconnectAfterReadingAndWriting;
-
-#pragma mark Diagnostics
-
-/**
- * Returns whether the socket is disconnected or connected.
- * 
- * A disconnected socket may be recycled.
- * That is, it can used again for connecting or listening.
- * 
- * If a socket is in the process of connecting, it may be neither disconnected nor connected.
-**/
-@property (atomic, readonly) BOOL isDisconnected;
-@property (atomic, readonly) BOOL isConnected;
-
-/**
- * Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
- * The host will be an IP address.
-**/
-@property (atomic, readonly, nullable) NSString *connectedHost;
-@property (atomic, readonly) uint16_t  connectedPort;
-@property (atomic, readonly, nullable) NSURL    *connectedUrl;
-
-@property (atomic, readonly, nullable) NSString *localHost;
-@property (atomic, readonly) uint16_t  localPort;
-
-/**
- * Returns the local or remote address to which this socket is connected,
- * specified as a sockaddr structure wrapped in a NSData object.
- * 
- * @seealso connectedHost
- * @seealso connectedPort
- * @seealso localHost
- * @seealso localPort
-**/
-@property (atomic, readonly, nullable) NSData *connectedAddress;
-@property (atomic, readonly, nullable) NSData *localAddress;
-
-/**
- * Returns whether the socket is IPv4 or IPv6.
- * An accepting socket may be both.
-**/
-@property (atomic, readonly) BOOL isIPv4;
-@property (atomic, readonly) BOOL isIPv6;
-
-/**
- * Returns whether or not the socket has been secured via SSL/TLS.
- * 
- * See also the startTLS method.
-**/
-@property (atomic, readonly) BOOL isSecure;
-
-#pragma mark Reading
-
-// The readData and writeData methods won't block (they are asynchronous).
-// 
-// When a read is complete the socket:didReadData:withTag: delegate method is dispatched on the delegateQueue.
-// When a write is complete the socket:didWriteDataWithTag: delegate method is dispatched on the delegateQueue.
-// 
-// You may optionally set a timeout for any read/write operation. (To not timeout, use a negative time interval.)
-// If a read/write opertion times out, the corresponding "socket:shouldTimeout..." delegate method
-// is called to optionally allow you to extend the timeout.
-// Upon a timeout, the "socket:didDisconnectWithError:" method is called
-// 
-// The tag is for your convenience.
-// You can use it as an array index, step number, state id, pointer, etc.
-
-/**
- * Reads the first available bytes that become available on the socket.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
-**/
-- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag;
-
-/**
- * Reads the first available bytes that become available on the socket.
- * The bytes will be appended to the given byte buffer starting at the given offset.
- * The given buffer will automatically be increased in size if needed.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * If the buffer if nil, the socket will create a buffer for you.
- * 
- * If the bufferOffset is greater than the length of the given buffer,
- * the method will do nothing, and the delegate will not be called.
- * 
- * If you pass a buffer, you must not alter it in any way while the socket is using it.
- * After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
- * That is, it will reference the bytes that were appended to the given buffer via
- * the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].
-**/
-- (void)readDataWithTimeout:(NSTimeInterval)timeout
-					 buffer:(nullable NSMutableData *)buffer
-			   bufferOffset:(NSUInteger)offset
-						tag:(long)tag;
-
-/**
- * Reads the first available bytes that become available on the socket.
- * The bytes will be appended to the given byte buffer starting at the given offset.
- * The given buffer will automatically be increased in size if needed.
- * A maximum of length bytes will be read.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * If the buffer if nil, a buffer will automatically be created for you.
- * If maxLength is zero, no length restriction is enforced.
- * 
- * If the bufferOffset is greater than the length of the given buffer,
- * the method will do nothing, and the delegate will not be called.
- * 
- * If you pass a buffer, you must not alter it in any way while the socket is using it.
- * After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
- * That is, it will reference the bytes that were appended to the given buffer  via
- * the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].
-**/
-- (void)readDataWithTimeout:(NSTimeInterval)timeout
-                     buffer:(nullable NSMutableData *)buffer
-               bufferOffset:(NSUInteger)offset
-                  maxLength:(NSUInteger)length
-                        tag:(long)tag;
-
-/**
- * Reads the given number of bytes.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * 
- * If the length is 0, this method does nothing and the delegate is not called.
-**/
-- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag;
-
-/**
- * Reads the given number of bytes.
- * The bytes will be appended to the given byte buffer starting at the given offset.
- * The given buffer will automatically be increased in size if needed.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * If the buffer if nil, a buffer will automatically be created for you.
- * 
- * If the length is 0, this method does nothing and the delegate is not called.
- * If the bufferOffset is greater than the length of the given buffer,
- * the method will do nothing, and the delegate will not be called.
- * 
- * If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.
- * After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
- * That is, it will reference the bytes that were appended to the given buffer via
- * the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].
-**/
-- (void)readDataToLength:(NSUInteger)length
-             withTimeout:(NSTimeInterval)timeout
-                  buffer:(nullable NSMutableData *)buffer
-            bufferOffset:(NSUInteger)offset
-                     tag:(long)tag;
-
-/**
- * Reads bytes until (and including) the passed "data" parameter, which acts as a separator.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * 
- * If you pass nil or zero-length data as the "data" parameter,
- * the method will do nothing (except maybe print a warning), and the delegate will not be called.
- * 
- * To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter.
- * If you're developing your own custom protocol, be sure your separator can not occur naturally as
- * part of the data between separators.
- * For example, imagine you want to send several small documents over a socket.
- * Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
- * In this particular example, it would be better to use a protocol similar to HTTP with
- * a header that includes the length of the document.
- * Also be careful that your separator cannot occur naturally as part of the encoding for a character.
- * 
- * The given data (separator) parameter should be immutable.
- * For performance reasons, the socket will retain it, not copy it.
- * So if it is immutable, don't modify it while the socket is using it.
-**/
-- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag;
-
-/**
- * Reads bytes until (and including) the passed "data" parameter, which acts as a separator.
- * The bytes will be appended to the given byte buffer starting at the given offset.
- * The given buffer will automatically be increased in size if needed.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * If the buffer if nil, a buffer will automatically be created for you.
- * 
- * If the bufferOffset is greater than the length of the given buffer,
- * the method will do nothing (except maybe print a warning), and the delegate will not be called.
- * 
- * If you pass a buffer, you must not alter it in any way while the socket is using it.
- * After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
- * That is, it will reference the bytes that were appended to the given buffer via
- * the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].
- * 
- * To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter.
- * If you're developing your own custom protocol, be sure your separator can not occur naturally as
- * part of the data between separators.
- * For example, imagine you want to send several small documents over a socket.
- * Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
- * In this particular example, it would be better to use a protocol similar to HTTP with
- * a header that includes the length of the document.
- * Also be careful that your separator cannot occur naturally as part of the encoding for a character.
- * 
- * The given data (separator) parameter should be immutable.
- * For performance reasons, the socket will retain it, not copy it.
- * So if it is immutable, don't modify it while the socket is using it.
-**/
-- (void)readDataToData:(NSData *)data
-           withTimeout:(NSTimeInterval)timeout
-                buffer:(nullable NSMutableData *)buffer
-          bufferOffset:(NSUInteger)offset
-                   tag:(long)tag;
-
-/**
- * Reads bytes until (and including) the passed "data" parameter, which acts as a separator.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * 
- * If maxLength is zero, no length restriction is enforced.
- * Otherwise if maxLength bytes are read without completing the read,
- * it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError.
- * The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.
- * 
- * If you pass nil or zero-length data as the "data" parameter,
- * the method will do nothing (except maybe print a warning), and the delegate will not be called.
- * If you pass a maxLength parameter that is less than the length of the data parameter,
- * the method will do nothing (except maybe print a warning), and the delegate will not be called.
- * 
- * To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter.
- * If you're developing your own custom protocol, be sure your separator can not occur naturally as
- * part of the data between separators.
- * For example, imagine you want to send several small documents over a socket.
- * Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
- * In this particular example, it would be better to use a protocol similar to HTTP with
- * a header that includes the length of the document.
- * Also be careful that your separator cannot occur naturally as part of the encoding for a character.
- * 
- * The given data (separator) parameter should be immutable.
- * For performance reasons, the socket will retain it, not copy it.
- * So if it is immutable, don't modify it while the socket is using it.
-**/
-- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout maxLength:(NSUInteger)length tag:(long)tag;
-
-/**
- * Reads bytes until (and including) the passed "data" parameter, which acts as a separator.
- * The bytes will be appended to the given byte buffer starting at the given offset.
- * The given buffer will automatically be increased in size if needed.
- * 
- * If the timeout value is negative, the read operation will not use a timeout.
- * If the buffer if nil, a buffer will automatically be created for you.
- * 
- * If maxLength is zero, no length restriction is enforced.
- * Otherwise if maxLength bytes are read without completing the read,
- * it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError.
- * The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.
- * 
- * If you pass a maxLength parameter that is less than the length of the data (separator) parameter,
- * the method will do nothing (except maybe print a warning), and the delegate will not be called.
- * If the bufferOffset is greater than the length of the given buffer,
- * the method will do nothing (except maybe print a warning), and the delegate will not be called.
- * 
- * If you pass a buffer, you must not alter it in any way while the socket is using it.
- * After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
- * That is, it will reference the bytes that were appended to the given buffer via
- * the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].
- * 
- * To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the "data" parameter.
- * If you're developing your own custom protocol, be sure your separator can not occur naturally as
- * part of the data between separators.
- * For example, imagine you want to send several small documents over a socket.
- * Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
- * In this particular example, it would be better to use a protocol similar to HTTP with
- * a header that includes the length of the document.
- * Also be careful that your separator cannot occur naturally as part of the encoding for a character.
- * 
- * The given data (separator) parameter should be immutable.
- * For performance reasons, the socket will retain it, not copy it.
- * So if it is immutable, don't modify it while the socket is using it.
-**/
-- (void)readDataToData:(NSData *)data
-           withTimeout:(NSTimeInterval)timeout
-                buffer:(nullable NSMutableData *)buffer
-          bufferOffset:(NSUInteger)offset
-             maxLength:(NSUInteger)length
-                   tag:(long)tag;
-
-/**
- * Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).
- * The parameters "tag", "done" and "total" will be filled in if they aren't NULL.
-**/
-- (float)progressOfReadReturningTag:(nullable long *)tagPtr bytesDone:(nullable NSUInteger *)donePtr total:(nullable NSUInteger *)totalPtr;
-
-#pragma mark Writing
-
-/**
- * Writes data to the socket, and calls the delegate when finished.
- * 
- * If you pass in nil or zero-length data, this method does nothing and the delegate will not be called.
- * If the timeout value is negative, the write operation will not use a timeout.
- * 
- * Thread-Safety Note:
- * If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
- * the socket is writing it. In other words, it's not safe to alter the data until after the delegate method
- * socket:didWriteDataWithTag: is invoked signifying that this particular write operation has completed.
- * This is due to the fact that GCDAsyncSocket does NOT copy the data. It simply retains it.
- * This is for performance reasons. Often times, if NSMutableData is passed, it is because
- * a request/response was built up in memory. Copying this data adds an unwanted/unneeded overhead.
- * If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
- * completes writing the bytes (which is NOT immediately after this method returns, but rather at a later time
- * when the delegate method notifies you), then you should first copy the bytes, and pass the copy to this method.
-**/
-- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag;
-
-/**
- * Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).
- * The parameters "tag", "done" and "total" will be filled in if they aren't NULL.
-**/
-- (float)progressOfWriteReturningTag:(nullable long *)tagPtr bytesDone:(nullable NSUInteger *)donePtr total:(nullable NSUInteger *)totalPtr;
-
-#pragma mark Security
-
-/**
- * Secures the connection using SSL/TLS.
- * 
- * This method may be called at any time, and the TLS handshake will occur after all pending reads and writes
- * are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing
- * the upgrade to TLS at the same time, without having to wait for the write to finish.
- * Any reads or writes scheduled after this method is called will occur over the secured connection.
- *
- * ==== The available TOP-LEVEL KEYS are:
- * 
- * - GCDAsyncSocketManuallyEvaluateTrust
- *     The value must be of type NSNumber, encapsulating a BOOL value.
- *     If you set this to YES, then the underlying SecureTransport system will not evaluate the SecTrustRef of the peer.
- *     Instead it will pause at the moment evaulation would typically occur,
- *     and allow us to handle the security evaluation however we see fit.
- *     So GCDAsyncSocket will invoke the delegate method socket:shouldTrustPeer: passing the SecTrustRef.
- *
- *     Note that if you set this option, then all other configuration keys are ignored.
- *     Evaluation will be completely up to you during the socket:didReceiveTrust:completionHandler: delegate method.
- *
- *     For more information on trust evaluation see:
- *     Apple's Technical Note TN2232 - HTTPS Server Trust Evaluation
- *     https://developer.apple.com/library/ios/technotes/tn2232/_index.html
- *     
- *     If unspecified, the default value is NO.
- *
- * - GCDAsyncSocketUseCFStreamForTLS (iOS only)
- *     The value must be of type NSNumber, encapsulating a BOOL value.
- *     By default GCDAsyncSocket will use the SecureTransport layer to perform encryption.
- *     This gives us more control over the security protocol (many more configuration options),
- *     plus it allows us to optimize things like sys calls and buffer allocation.
- *     
- *     However, if you absolutely must, you can instruct GCDAsyncSocket to use the old-fashioned encryption
- *     technique by going through the CFStream instead. So instead of using SecureTransport, GCDAsyncSocket
- *     will instead setup a CFRead/CFWriteStream. And then set the kCFStreamPropertySSLSettings property
- *     (via CFReadStreamSetProperty / CFWriteStreamSetProperty) and will pass the given options to this method.
- *     
- *     Thus all the other keys in the given dictionary will be ignored by GCDAsyncSocket,
- *     and will passed directly CFReadStreamSetProperty / CFWriteStreamSetProperty.
- *     For more infomation on these keys, please see the documentation for kCFStreamPropertySSLSettings.
- *
- *     If unspecified, the default value is NO.
- *
- * ==== The available CONFIGURATION KEYS are:
- *
- * - kCFStreamSSLPeerName
- *     The value must be of type NSString.
- *     It should match the name in the X.509 certificate given by the remote party.
- *     See Apple's documentation for SSLSetPeerDomainName.
- *
- * - kCFStreamSSLCertificates
- *     The value must be of type NSArray.
- *     See Apple's documentation for SSLSetCertificate.
- *
- * - kCFStreamSSLIsServer
- *     The value must be of type NSNumber, encapsulationg a BOOL value.
- *     See Apple's documentation for SSLCreateContext for iOS.
- *     This is optional for iOS. If not supplied, a NO value is the default.
- *     This is not needed for Mac OS X, and the value is ignored.
- *
- * - GCDAsyncSocketSSLPeerID
- *     The value must be of type NSData.
- *     You must set this value if you want to use TLS session resumption.
- *     See Apple's documentation for SSLSetPeerID.
- *
- * - GCDAsyncSocketSSLProtocolVersionMin
- * - GCDAsyncSocketSSLProtocolVersionMax
- *     The value(s) must be of type NSNumber, encapsulting a SSLProtocol value.
- *     See Apple's documentation for SSLSetProtocolVersionMin & SSLSetProtocolVersionMax.
- *     See also the SSLProtocol typedef.
- * 
- * - GCDAsyncSocketSSLSessionOptionFalseStart
- *     The value must be of type NSNumber, encapsulating a BOOL value.
- *     See Apple's documentation for kSSLSessionOptionFalseStart.
- * 
- * - GCDAsyncSocketSSLSessionOptionSendOneByteRecord
- *     The value must be of type NSNumber, encapsulating a BOOL value.
- *     See Apple's documentation for kSSLSessionOptionSendOneByteRecord.
- * 
- * - GCDAsyncSocketSSLCipherSuites
- *     The values must be of type NSArray.
- *     Each item within the array must be a NSNumber, encapsulating
- *     See Apple's documentation for SSLSetEnabledCiphers.
- *     See also the SSLCipherSuite typedef.
- *
- * - GCDAsyncSocketSSLDiffieHellmanParameters (Mac OS X only)
- *     The value must be of type NSData.
- *     See Apple's documentation for SSLSetDiffieHellmanParams.
- * 
- * ==== The following UNAVAILABLE KEYS are: (with throw an exception)
- * 
- * - kCFStreamSSLAllowsAnyRoot (UNAVAILABLE)
- *     You MUST use manual trust evaluation instead (see GCDAsyncSocketManuallyEvaluateTrust).
- *     Corresponding deprecated method: SSLSetAllowsAnyRoot
- * 
- * - kCFStreamSSLAllowsExpiredRoots (UNAVAILABLE)
- *     You MUST use manual trust evaluation instead (see GCDAsyncSocketManuallyEvaluateTrust).
- *     Corresponding deprecated method: SSLSetAllowsExpiredRoots
- *
- * - kCFStreamSSLAllowsExpiredCertificates (UNAVAILABLE)
- *     You MUST use manual trust evaluation instead (see GCDAsyncSocketManuallyEvaluateTrust).
- *     Corresponding deprecated method: SSLSetAllowsExpiredCerts
- *
- * - kCFStreamSSLValidatesCertificateChain (UNAVAILABLE)
- *     You MUST use manual trust evaluation instead (see GCDAsyncSocketManuallyEvaluateTrust).
- *     Corresponding deprecated method: SSLSetEnableCertVerify
- *
- * - kCFStreamSSLLevel (UNAVAILABLE)
- *     You MUST use GCDAsyncSocketSSLProtocolVersionMin & GCDAsyncSocketSSLProtocolVersionMin instead.
- *     Corresponding deprecated method: SSLSetProtocolVersionEnabled
- *
- * 
- * Please refer to Apple's documentation for corresponding SSLFunctions.
- *
- * If you pass in nil or an empty dictionary, the default settings will be used.
- * 
- * IMPORTANT SECURITY NOTE:
- * The default settings will check to make sure the remote party's certificate is signed by a
- * trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.
- * However it will not verify the name on the certificate unless you
- * give it a name to verify against via the kCFStreamSSLPeerName key.
- * The security implications of this are important to understand.
- * Imagine you are attempting to create a secure connection to MySecureServer.com,
- * but your socket gets directed to MaliciousServer.com because of a hacked DNS server.
- * If you simply use the default settings, and MaliciousServer.com has a valid certificate,
- * the default settings will not detect any problems since the certificate is valid.
- * To properly secure your connection in this particular scenario you
- * should set the kCFStreamSSLPeerName property to "MySecureServer.com".
- * 
- * You can also perform additional validation in socketDidSecure.
-**/
-- (void)startTLS:(nullable NSDictionary <NSString*,NSObject*>*)tlsSettings;
-
-#pragma mark Advanced
-
-/**
- * Traditionally sockets are not closed until the conversation is over.
- * However, it is technically possible for the remote enpoint to close its write stream.
- * Our socket would then be notified that there is no more data to be read,
- * but our socket would still be writeable and the remote endpoint could continue to receive our data.
- * 
- * The argument for this confusing functionality stems from the idea that a client could shut down its
- * write stream after sending a request to the server, thus notifying the server there are to be no further requests.
- * In practice, however, this technique did little to help server developers.
- * 
- * To make matters worse, from a TCP perspective there is no way to tell the difference from a read stream close
- * and a full socket close. They both result in the TCP stack receiving a FIN packet. The only way to tell
- * is by continuing to write to the socket. If it was only a read stream close, then writes will continue to work.
- * Otherwise an error will be occur shortly (when the remote end sends us a RST packet).
- * 
- * In addition to the technical challenges and confusion, many high level socket/stream API's provide
- * no support for dealing with the problem. If the read stream is closed, the API immediately declares the
- * socket to be closed, and shuts down the write stream as well. In fact, this is what Apple's CFStream API does.
- * It might sound like poor design at first, but in fact it simplifies development.
- * 
- * The vast majority of the time if the read stream is closed it's because the remote endpoint closed its socket.
- * Thus it actually makes sense to close the socket at this point.
- * And in fact this is what most networking developers want and expect to happen.
- * However, if you are writing a server that interacts with a plethora of clients,
- * you might encounter a client that uses the discouraged technique of shutting down its write stream.
- * If this is the case, you can set this property to NO,
- * and make use of the socketDidCloseReadStream delegate method.
- * 
- * The default value is YES.
-**/
-@property (atomic, assign, readwrite) BOOL autoDisconnectOnClosedReadStream;
-
-/**
- * GCDAsyncSocket maintains thread safety by using an internal serial dispatch_queue.
- * In most cases, the instance creates this queue itself.
- * However, to allow for maximum flexibility, the internal queue may be passed in the init method.
- * This allows for some advanced options such as controlling socket priority via target queues.
- * However, when one begins to use target queues like this, they open the door to some specific deadlock issues.
- * 
- * For example, imagine there are 2 queues:
- * dispatch_queue_t socketQueue;
- * dispatch_queue_t socketTargetQueue;
- * 
- * If you do this (pseudo-code):
- * socketQueue.targetQueue = socketTargetQueue;
- * 
- * Then all socketQueue operations will actually get run on the given socketTargetQueue.
- * This is fine and works great in most situations.
- * But if you run code directly from within the socketTargetQueue that accesses the socket,
- * you could potentially get deadlock. Imagine the following code:
- * 
- * - (BOOL)socketHasSomething
- * {
- *     __block BOOL result = NO;
- *     dispatch_block_t block = ^{
- *         result = [self someInternalMethodToBeRunOnlyOnSocketQueue];
- *     }
- *     if (is_executing_on_queue(socketQueue))
- *         block();
- *     else
- *         dispatch_sync(socketQueue, block);
- *     
- *     return result;
- * }
- * 
- * What happens if you call this method from the socketTargetQueue? The result is deadlock.
- * This is because the GCD API offers no mechanism to discover a queue's targetQueue.
- * Thus we have no idea if our socketQueue is configured with a targetQueue.
- * If we had this information, we could easily avoid deadlock.
- * But, since these API's are missing or unfeasible, you'll have to explicitly set it.
- * 
- * IF you pass a socketQueue via the init method,
- * AND you've configured the passed socketQueue with a targetQueue,
- * THEN you should pass the end queue in the target hierarchy.
- * 
- * For example, consider the following queue hierarchy:
- * socketQueue -> ipQueue -> moduleQueue
- *
- * This example demonstrates priority shaping within some server.
- * All incoming client connections from the same IP address are executed on the same target queue.
- * And all connections for a particular module are executed on the same target queue.
- * Thus, the priority of all networking for the entire module can be changed on the fly.
- * Additionally, networking traffic from a single IP cannot monopolize the module.
- * 
- * Here's how you would accomplish something like that:
- * - (dispatch_queue_t)newSocketQueueForConnectionFromAddress:(NSData *)address onSocket:(GCDAsyncSocket *)sock
- * {
- *     dispatch_queue_t socketQueue = dispatch_queue_create("", NULL);
- *     dispatch_queue_t ipQueue = [self ipQueueForAddress:address];
- *     
- *     dispatch_set_target_queue(socketQueue, ipQueue);
- *     dispatch_set_target_queue(iqQueue, moduleQueue);
- *     
- *     return socketQueue;
- * }
- * - (void)socket:(GCDAsyncSocket *)sock didAcceptNewSocket:(GCDAsyncSocket *)newSocket
- * {
- *     [clientConnections addObject:newSocket];
- *     [newSocket markSocketQueueTargetQueue:moduleQueue];
- * }
- * 
- * Note: This workaround is ONLY needed if you intend to execute code directly on the ipQueue or moduleQueue.
- * This is often NOT the case, as such queues are used solely for execution shaping.
-**/
-- (void)markSocketQueueTargetQueue:(dispatch_queue_t)socketQueuesPreConfiguredTargetQueue;
-- (void)unmarkSocketQueueTargetQueue:(dispatch_queue_t)socketQueuesPreviouslyConfiguredTargetQueue;
-
-/**
- * It's not thread-safe to access certain variables from outside the socket's internal queue.
- * 
- * For example, the socket file descriptor.
- * File descriptors are simply integers which reference an index in the per-process file table.
- * However, when one requests a new file descriptor (by opening a file or socket),
- * the file descriptor returned is guaranteed to be the lowest numbered unused descriptor.
- * So if we're not careful, the following could be possible:
- * 
- * - Thread A invokes a method which returns the socket's file descriptor.
- * - The socket is closed via the socket's internal queue on thread B.
- * - Thread C opens a file, and subsequently receives the file descriptor that was previously the socket's FD.
- * - Thread A is now accessing/altering the file instead of the socket.
- * 
- * In addition to this, other variables are not actually objects,
- * and thus cannot be retained/released or even autoreleased.
- * An example is the sslContext, of type SSLContextRef, which is actually a malloc'd struct.
- * 
- * Although there are internal variables that make it difficult to maintain thread-safety,
- * it is important to provide access to these variables
- * to ensure this class can be used in a wide array of environments.
- * This method helps to accomplish this by invoking the current block on the socket's internal queue.
- * The methods below can be invoked from within the block to access
- * those generally thread-unsafe internal variables in a thread-safe manner.
- * The given block will be invoked synchronously on the socket's internal queue.
- * 
- * If you save references to any protected variables and use them outside the block, you do so at your own peril.
-**/
-- (void)performBlock:(dispatch_block_t)block;
-
-/**
- * These methods are only available from within the context of a performBlock: invocation.
- * See the documentation for the performBlock: method above.
- * 
- * Provides access to the socket's file descriptor(s).
- * If the socket is a server socket (is accepting incoming connections),
- * it might actually have multiple internal socket file descriptors - one for IPv4 and one for IPv6.
-**/
-- (int)socketFD;
-- (int)socket4FD;
-- (int)socket6FD;
-
-#if TARGET_OS_IPHONE
-
-/**
- * These methods are only available from within the context of a performBlock: invocation.
- * See the documentation for the performBlock: method above.
- * 
- * Provides access to the socket's internal CFReadStream/CFWriteStream.
- * 
- * These streams are only used as workarounds for specific iOS shortcomings:
- * 
- * - Apple has decided to keep the SecureTransport framework private is iOS.
- *   This means the only supplied way to do SSL/TLS is via CFStream or some other API layered on top of it.
- *   Thus, in order to provide SSL/TLS support on iOS we are forced to rely on CFStream,
- *   instead of the preferred and faster and more powerful SecureTransport.
- * 
- * - If a socket doesn't have backgrounding enabled, and that socket is closed while the app is backgrounded,
- *   Apple only bothers to notify us via the CFStream API.
- *   The faster and more powerful GCD API isn't notified properly in this case.
- * 
- * See also: (BOOL)enableBackgroundingOnSocket
-**/
-- (nullable CFReadStreamRef)readStream;
-- (nullable CFWriteStreamRef)writeStream;
-
-/**
- * This method is only available from within the context of a performBlock: invocation.
- * See the documentation for the performBlock: method above.
- * 
- * Configures the socket to allow it to operate when the iOS application has been backgrounded.
- * In other words, this method creates a read & write stream, and invokes:
- * 
- * CFReadStreamSetProperty(readStream, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);
- * CFWriteStreamSetProperty(writeStream, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);
- * 
- * Returns YES if successful, NO otherwise.
- * 
- * Note: Apple does not officially support backgrounding server sockets.
- * That is, if your socket is accepting incoming connections, Apple does not officially support
- * allowing iOS applications to accept incoming connections while an app is backgrounded.
- * 
- * Example usage:
- * 
- * - (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port
- * {
- *     [asyncSocket performBlock:^{
- *         [asyncSocket enableBackgroundingOnSocket];
- *     }];
- * }
-**/
-- (BOOL)enableBackgroundingOnSocket;
-
-#endif
-
-/**
- * This method is only available from within the context of a performBlock: invocation.
- * See the documentation for the performBlock: method above.
- * 
- * Provides access to the socket's SSLContext, if SSL/TLS has been started on the socket.
-**/
-- (nullable SSLContextRef)sslContext;
-
-#pragma mark Utilities
-
-/**
- * The address lookup utility used by the class.
- * This method is synchronous, so it's recommended you use it on a background thread/queue.
- * 
- * The special strings "localhost" and "loopback" return the loopback address for IPv4 and IPv6.
- * 
- * @returns
- *   A mutable array with all IPv4 and IPv6 addresses returned by getaddrinfo.
- *   The addresses are specifically for TCP connections.
- *   You can filter the addresses, if needed, using the other utility methods provided by the class.
-**/
-+ (nullable NSMutableArray *)lookupHost:(NSString *)host port:(uint16_t)port error:(NSError **)errPtr;
-
-/**
- * Extracting host and port information from raw address data.
-**/
-
-+ (nullable NSString *)hostFromAddress:(NSData *)address;
-+ (uint16_t)portFromAddress:(NSData *)address;
-
-+ (BOOL)isIPv4Address:(NSData *)address;
-+ (BOOL)isIPv6Address:(NSData *)address;
-
-+ (BOOL)getHost:( NSString * __nullable * __nullable)hostPtr port:(nullable uint16_t *)portPtr fromAddress:(NSData *)address;
-
-+ (BOOL)getHost:(NSString * __nullable * __nullable)hostPtr port:(nullable uint16_t *)portPtr family:(nullable sa_family_t *)afPtr fromAddress:(NSData *)address;
-
-/**
- * A few common line separators, for use with the readDataToData:... methods.
-**/
-+ (NSData *)CRLFData;   // 0x0D0A
-+ (NSData *)CRData;     // 0x0D
-+ (NSData *)LFData;     // 0x0A
-+ (NSData *)ZeroData;   // 0x00
-
-@end
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark -
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-@protocol GCDAsyncSocketDelegate <NSObject>
-@optional
-
-/**
- * This method is called immediately prior to socket:didAcceptNewSocket:.
- * It optionally allows a listening socket to specify the socketQueue for a new accepted socket.
- * If this method is not implemented, or returns NULL, the new accepted socket will create its own default queue.
- * 
- * Since you cannot autorelease a dispatch_queue,
- * this method uses the "new" prefix in its name to specify that the returned queue has been retained.
- * 
- * Thus you could do something like this in the implementation:
- * return dispatch_queue_create("MyQueue", NULL);
- * 
- * If you are placing multiple sockets on the same queue,
- * then care should be taken to increment the retain count each time this method is invoked.
- * 
- * For example, your implementation might look something like this:
- * dispatch_retain(myExistingQueue);
- * return myExistingQueue;
-**/
-- (nullable dispatch_queue_t)newSocketQueueForConnectionFromAddress:(NSData *)address onSocket:(GCDAsyncSocket *)sock;
-
-/**
- * Called when a socket accepts a connection.
- * Another socket is automatically spawned to handle it.
- * 
- * You must retain the newSocket if you wish to handle the connection.
- * Otherwise the newSocket instance will be released and the spawned connection will be closed.
- * 
- * By default the new socket will have the same delegate and delegateQueue.
- * You may, of course, change this at any time.
-**/
-- (void)socket:(GCDAsyncSocket *)sock didAcceptNewSocket:(GCDAsyncSocket *)newSocket;
-
-/**
- * Called when a socket connects and is ready for reading and writing.
- * The host parameter will be an IP address, not a DNS name.
-**/
-- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port;
-
-/**
- * Called when a socket connects and is ready for reading and writing.
- * The host parameter will be an IP address, not a DNS name.
- **/
-- (void)socket:(GCDAsyncSocket *)sock didConnectToUrl:(NSURL *)url;
-
-/**
- * Called when a socket has completed reading the requested data into memory.
- * Not called if there is an error.
-**/
-- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag;
-
-/**
- * Called when a socket has read in data, but has not yet completed the read.
- * This would occur if using readToData: or readToLength: methods.
- * It may be used to for things such as updating progress bars.
-**/
-- (void)socket:(GCDAsyncSocket *)sock didReadPartialDataOfLength:(NSUInteger)partialLength tag:(long)tag;
-
-/**
- * Called when a socket has completed writing the requested data. Not called if there is an error.
-**/
-- (void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag;
-
-/**
- * Called when a socket has written some data, but has not yet completed the entire write.
- * It may be used to for things such as updating progress bars.
-**/
-- (void)socket:(GCDAsyncSocket *)sock didWritePartialDataOfLength:(NSUInteger)partialLength tag:(long)tag;
-
-/**
- * Called if a read operation has reached its timeout without completing.
- * This method allows you to optionally extend the timeout.
- * If you return a positive time interval (> 0) the read's timeout will be extended by the given amount.
- * If you don't implement this method, or return a non-positive time interval (<= 0) the read will timeout as usual.
- * 
- * The elapsed parameter is the sum of the original timeout, plus any additions previously added via this method.
- * The length parameter is the number of bytes that have been read so far for the read operation.
- * 
- * Note that this method may be called multiple times for a single read if you return positive numbers.
-**/
-- (NSTimeInterval)socket:(GCDAsyncSocket *)sock shouldTimeoutReadWithTag:(long)tag
-                                                                 elapsed:(NSTimeInterval)elapsed
-                                                               bytesDone:(NSUInteger)length;
-
-/**
- * Called if a write operation has reached its timeout without completing.
- * This method allows you to optionally extend the timeout.
- * If you return a positive time interval (> 0) the write's timeout will be extended by the given amount.
- * If you don't implement this method, or return a non-positive time interval (<= 0) the write will timeout as usual.
- * 
- * The elapsed parameter is the sum of the original timeout, plus any additions previously added via this method.
- * The length parameter is the number of bytes that have been written so far for the write operation.
- * 
- * Note that this method may be called multiple times for a single write if you return positive numbers.
-**/
-- (NSTimeInterval)socket:(GCDAsyncSocket *)sock shouldTimeoutWriteWithTag:(long)tag
-                                                                  elapsed:(NSTimeInterval)elapsed
-                                                                bytesDone:(NSUInteger)length;
-
-/**
- * Conditionally called if the read stream closes, but the write stream may still be writeable.
- * 
- * This delegate method is only called if autoDisconnectOnClosedReadStream has been set to NO.
- * See the discussion on the autoDisconnectOnClosedReadStream method for more information.
-**/
-- (void)socketDidCloseReadStream:(GCDAsyncSocket *)sock;
-
-/**
- * Called when a socket disconnects with or without error.
- * 
- * If you call the disconnect method, and the socket wasn't already disconnected,
- * then an invocation of this delegate method will be enqueued on the delegateQueue
- * before the disconnect method returns.
- * 
- * Note: If the GCDAsyncSocket instance is deallocated while it is still connected,
- * and the delegate is not also deallocated, then this method will be invoked,
- * but the sock parameter will be nil. (It must necessarily be nil since it is no longer available.)
- * This is a generally rare, but is possible if one writes code like this:
- * 
- * asyncSocket = nil; // I'm implicitly disconnecting the socket
- * 
- * In this case it may preferrable to nil the delegate beforehand, like this:
- * 
- * asyncSocket.delegate = nil; // Don't invoke my delegate method
- * asyncSocket = nil; // I'm implicitly disconnecting the socket
- * 
- * Of course, this depends on how your state machine is configured.
-**/
-- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(nullable NSError *)err;
-
-/**
- * Called after the socket has successfully completed SSL/TLS negotiation.
- * This method is not called unless you use the provided startTLS method.
- * 
- * If a SSL/TLS negotiation fails (invalid certificate, etc) then the socket will immediately close,
- * and the socketDidDisconnect:withError: delegate method will be called with the specific SSL error code.
-**/
-- (void)socketDidSecure:(GCDAsyncSocket *)sock;
-
-/**
- * Allows a socket delegate to hook into the TLS handshake and manually validate the peer it's connecting to.
- *
- * This is only called if startTLS is invoked with options that include:
- * - GCDAsyncSocketManuallyEvaluateTrust == YES
- *
- * Typically the delegate will use SecTrustEvaluate (and related functions) to properly validate the peer.
- * 
- * Note from Apple's documentation:
- *   Because [SecTrustEvaluate] might look on the network for certificates in the certificate chain,
- *   [it] might block while attempting network access. You should never call it from your main thread;
- *   call it only from within a function running on a dispatch queue or on a separate thread.
- * 
- * Thus this method uses a completionHandler block rather than a normal return value.
- * The completionHandler block is thread-safe, and may be invoked from a background queue/thread.
- * It is safe to invoke the completionHandler block even if the socket has been closed.
-**/
-- (void)socket:(GCDAsyncSocket *)sock didReceiveTrust:(SecTrustRef)trust
-                                    completionHandler:(void (^)(BOOL shouldTrustPeer))completionHandler;
-
-@end
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/react-native-tcp/ios/CocoaAsyncSocket/GCDAsyncSocket.m b/node_modules/react-native-tcp/ios/CocoaAsyncSocket/GCDAsyncSocket.m
deleted file mode 100644
index abf2a8a..0000000
--- a/node_modules/react-native-tcp/ios/CocoaAsyncSocket/GCDAsyncSocket.m
+++ /dev/null
@@ -1,8365 +0,0 @@
-//
-//  GCDAsyncSocket.m
-//  
-//  This class is in the public domain.
-//  Originally created by Robbie Hanson in Q4 2010.
-//  Updated and maintained by Deusty LLC and the Apple development community.
-//
-//  https://github.com/robbiehanson/CocoaAsyncSocket
-//
-
-#import "GCDAsyncSocket.h"
-
-#if TARGET_OS_IPHONE
-#import <CFNetwork/CFNetwork.h>
-#endif
-
-#import <TargetConditionals.h>
-#import <arpa/inet.h>
-#import <fcntl.h>
-#import <ifaddrs.h>
-#import <netdb.h>
-#import <netinet/in.h>
-#import <net/if.h>
-#import <sys/socket.h>
-#import <sys/types.h>
-#import <sys/ioctl.h>
-#import <sys/poll.h>
-#import <sys/uio.h>
-#import <sys/un.h>
-#import <unistd.h>
-
-#if ! __has_feature(objc_arc)
-#warning This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
-// For more information see: https://github.com/robbiehanson/CocoaAsyncSocket/wiki/ARC
-#endif
-
-
-#ifndef GCDAsyncSocketLoggingEnabled
-#define GCDAsyncSocketLoggingEnabled 0
-#endif
-
-#if GCDAsyncSocketLoggingEnabled
-
-// Logging Enabled - See log level below
-
-// Logging uses the CocoaLumberjack framework (which is also GCD based).
-// https://github.com/robbiehanson/CocoaLumberjack
-// 
-// It allows us to do a lot of logging without significantly slowing down the code.
-#import "DDLog.h"
-
-#define LogAsync   YES
-#define LogContext GCDAsyncSocketLoggingContext
-
-#define LogObjc(flg, frmt, ...) LOG_OBJC_MAYBE(LogAsync, logLevel, flg, LogContext, frmt, ##__VA_ARGS__)
-#define LogC(flg, frmt, ...)    LOG_C_MAYBE(LogAsync, logLevel, flg, LogContext, frmt, ##__VA_ARGS__)
-
-#define LogError(frmt, ...)     LogObjc(LOG_FLAG_ERROR,   (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-#define LogWarn(frmt, ...)      LogObjc(LOG_FLAG_WARN,    (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-#define LogInfo(frmt, ...)      LogObjc(LOG_FLAG_INFO,    (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-#define LogVerbose(frmt, ...)   LogObjc(LOG_FLAG_VERBOSE, (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-
-#define LogCError(frmt, ...)    LogC(LOG_FLAG_ERROR,   (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-#define LogCWarn(frmt, ...)     LogC(LOG_FLAG_WARN,    (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-#define LogCInfo(frmt, ...)     LogC(LOG_FLAG_INFO,    (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-#define LogCVerbose(frmt, ...)  LogC(LOG_FLAG_VERBOSE, (@"%@: " frmt), THIS_FILE, ##__VA_ARGS__)
-
-#define LogTrace()              LogObjc(LOG_FLAG_VERBOSE, @"%@: %@", THIS_FILE, THIS_METHOD)
-#define LogCTrace()             LogC(LOG_FLAG_VERBOSE, @"%@: %s", THIS_FILE, __FUNCTION__)
-
-#ifndef GCDAsyncSocketLogLevel
-#define GCDAsyncSocketLogLevel LOG_LEVEL_VERBOSE
-#endif
-
-// Log levels : off, error, warn, info, verbose
-static const int logLevel = GCDAsyncSocketLogLevel;
-
-#else
-
-// Logging Disabled
-
-#define LogError(frmt, ...)     {}
-#define LogWarn(frmt, ...)      {}
-#define LogInfo(frmt, ...)      {}
-#define LogVerbose(frmt, ...)   {}
-
-#define LogCError(frmt, ...)    {}
-#define LogCWarn(frmt, ...)     {}
-#define LogCInfo(frmt, ...)     {}
-#define LogCVerbose(frmt, ...)  {}
-
-#define LogTrace()              {}
-#define LogCTrace(frmt, ...)    {}
-
-#endif
-
-/**
- * Seeing a return statements within an inner block
- * can sometimes be mistaken for a return point of the enclosing method.
- * This makes inline blocks a bit easier to read.
-**/
-#define return_from_block  return
-
-/**
- * A socket file descriptor is really just an integer.
- * It represents the index of the socket within the kernel.
- * This makes invalid file descriptor comparisons easier to read.
-**/
-#define SOCKET_NULL -1
-
-
-NSString *const GCDAsyncSocketException = @"GCDAsyncSocketException";
-NSString *const GCDAsyncSocketErrorDomain = @"GCDAsyncSocketErrorDomain";
-
-NSString *const GCDAsyncSocketQueueName = @"GCDAsyncSocket";
-NSString *const GCDAsyncSocketThreadName = @"GCDAsyncSocket-CFStream";
-
-NSString *const GCDAsyncSocketManuallyEvaluateTrust = @"GCDAsyncSocketManuallyEvaluateTrust";
-#if TARGET_OS_IPHONE
-NSString *const GCDAsyncSocketUseCFStreamForTLS = @"GCDAsyncSocketUseCFStreamForTLS";
-#endif
-NSString *const GCDAsyncSocketSSLPeerID = @"GCDAsyncSocketSSLPeerID";
-NSString *const GCDAsyncSocketSSLProtocolVersionMin = @"GCDAsyncSocketSSLProtocolVersionMin";
-NSString *const GCDAsyncSocketSSLProtocolVersionMax = @"GCDAsyncSocketSSLProtocolVersionMax";
-NSString *const GCDAsyncSocketSSLSessionOptionFalseStart = @"GCDAsyncSocketSSLSessionOptionFalseStart";
-NSString *const GCDAsyncSocketSSLSessionOptionSendOneByteRecord = @"GCDAsyncSocketSSLSessionOptionSendOneByteRecord";
-NSString *const GCDAsyncSocketSSLCipherSuites = @"GCDAsyncSocketSSLCipherSuites";
-#if !TARGET_OS_IPHONE
-NSString *const GCDAsyncSocketSSLDiffieHellmanParameters = @"GCDAsyncSocketSSLDiffieHellmanParameters";
-#endif
-
-enum GCDAsyncSocketFlags
-{
-	kSocketStarted                 = 1 <<  0,  // If set, socket has been started (accepting/connecting)
-	kConnected                     = 1 <<  1,  // If set, the socket is connected
-	kForbidReadsWrites             = 1 <<  2,  // If set, no new reads or writes are allowed
-	kReadsPaused                   = 1 <<  3,  // If set, reads are paused due to possible timeout
-	kWritesPaused                  = 1 <<  4,  // If set, writes are paused due to possible timeout
-	kDisconnectAfterReads          = 1 <<  5,  // If set, disconnect after no more reads are queued
-	kDisconnectAfterWrites         = 1 <<  6,  // If set, disconnect after no more writes are queued
-	kSocketCanAcceptBytes          = 1 <<  7,  // If set, we know socket can accept bytes. If unset, it's unknown.
-	kReadSourceSuspended           = 1 <<  8,  // If set, the read source is suspended
-	kWriteSourceSuspended          = 1 <<  9,  // If set, the write source is suspended
-	kQueuedTLS                     = 1 << 10,  // If set, we've queued an upgrade to TLS
-	kStartingReadTLS               = 1 << 11,  // If set, we're waiting for TLS negotiation to complete
-	kStartingWriteTLS              = 1 << 12,  // If set, we're waiting for TLS negotiation to complete
-	kSocketSecure                  = 1 << 13,  // If set, socket is using secure communication via SSL/TLS
-	kSocketHasReadEOF              = 1 << 14,  // If set, we have read EOF from socket
-	kReadStreamClosed              = 1 << 15,  // If set, we've read EOF plus prebuffer has been drained
-	kDealloc                       = 1 << 16,  // If set, the socket is being deallocated
-#if TARGET_OS_IPHONE
-	kAddedStreamsToRunLoop         = 1 << 17,  // If set, CFStreams have been added to listener thread
-	kUsingCFStreamForTLS           = 1 << 18,  // If set, we're forced to use CFStream instead of SecureTransport
-	kSecureSocketHasBytesAvailable = 1 << 19,  // If set, CFReadStream has notified us of bytes available
-#endif
-};
-
-enum GCDAsyncSocketConfig
-{
-	kIPv4Disabled              = 1 << 0,  // If set, IPv4 is disabled
-	kIPv6Disabled              = 1 << 1,  // If set, IPv6 is disabled
-	kPreferIPv6                = 1 << 2,  // If set, IPv6 is preferred over IPv4
-	kAllowHalfDuplexConnection = 1 << 3,  // If set, the socket will stay open even if the read stream closes
-};
-
-#if TARGET_OS_IPHONE
-  static NSThread *cfstreamThread;  // Used for CFStreams
-
-
-  static uint64_t cfstreamThreadRetainCount;   // setup & teardown
-  static dispatch_queue_t cfstreamThreadSetupQueue; // setup & teardown
-#endif
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark -
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/**
- * A PreBuffer is used when there is more data available on the socket
- * than is being requested by current read request.
- * In this case we slurp up all data from the socket (to minimize sys calls),
- * and store additional yet unread data in a "prebuffer".
- * 
- * The prebuffer is entirely drained before we read from the socket again.
- * In other words, a large chunk of data is written is written to the prebuffer.
- * The prebuffer is then drained via a series of one or more reads (for subsequent read request(s)).
- * 
- * A ring buffer was once used for this purpose.
- * But a ring buffer takes up twice as much memory as needed (double the size for mirroring).
- * In fact, it generally takes up more than twice the needed size as everything has to be rounded up to vm_page_size.
- * And since the prebuffer is always completely drained after being written to, a full ring buffer isn't needed.
- * 
- * The current design is very simple and straight-forward, while also keeping memory requirements lower.
-**/
-
-@interface GCDAsyncSocketPreBuffer : NSObject
-{
-	uint8_t *preBuffer;
-	size_t preBufferSize;
-	
-	uint8_t *readPointer;
-	uint8_t *writePointer;
-}
-
-- (id)initWithCapacity:(size_t)numBytes;
-
-- (void)ensureCapacityForWrite:(size_t)numBytes;
-
-- (size_t)availableBytes;
-- (uint8_t *)readBuffer;
-
-- (void)getReadBuffer:(uint8_t **)bufferPtr availableBytes:(size_t *)availableBytesPtr;
-
-- (size_t)availableSpace;
-- (uint8_t *)writeBuffer;
-
-- (void)getWriteBuffer:(uint8_t **)bufferPtr availableSpace:(size_t *)availableSpacePtr;
-
-- (void)didRead:(size_t)bytesRead;
-- (void)didWrite:(size_t)bytesWritten;
-
-- (void)reset;
-
-@end
-
-@implementation GCDAsyncSocketPreBuffer
-
-- (id)initWithCapacity:(size_t)numBytes
-{
-	if ((self = [super init]))
-	{
-		preBufferSize = numBytes;
-		preBuffer = malloc(preBufferSize);
-		
-		readPointer = preBuffer;
-		writePointer = preBuffer;
-	}
-	return self;
-}
-
-- (void)dealloc
-{
-	if (preBuffer)
-		free(preBuffer);
-}
-
-- (void)ensureCapacityForWrite:(size_t)numBytes
-{
-	size_t availableSpace = [self availableSpace];
-	
-	if (numBytes > availableSpace)
-	{
-		size_t additionalBytes = numBytes - availableSpace;
-		
-		size_t newPreBufferSize = preBufferSize + additionalBytes;
-		uint8_t *newPreBuffer = realloc(preBuffer, newPreBufferSize);
-		
-		size_t readPointerOffset = readPointer - preBuffer;
-		size_t writePointerOffset = writePointer - preBuffer;
-		
-		preBuffer = newPreBuffer;
-		preBufferSize = newPreBufferSize;
-		
-		readPointer = preBuffer + readPointerOffset;
-		writePointer = preBuffer + writePointerOffset;
-	}
-}
-
-- (size_t)availableBytes
-{
-	return writePointer - readPointer;
-}
-
-- (uint8_t *)readBuffer
-{
-	return readPointer;
-}
-
-- (void)getReadBuffer:(uint8_t **)bufferPtr availableBytes:(size_t *)availableBytesPtr
-{
-	if (bufferPtr) *bufferPtr = readPointer;
-	if (availableBytesPtr) *availableBytesPtr = [self availableBytes];
-}
-
-- (void)didRead:(size_t)bytesRead
-{
-	readPointer += bytesRead;
-	
-	if (readPointer == writePointer)
-	{
-		// The prebuffer has been drained. Reset pointers.
-		readPointer  = preBuffer;
-		writePointer = preBuffer;
-	}
-}
-
-- (size_t)availableSpace
-{
-	return preBufferSize - (writePointer - preBuffer);
-}
-
-- (uint8_t *)writeBuffer
-{
-	return writePointer;
-}
-
-- (void)getWriteBuffer:(uint8_t **)bufferPtr availableSpace:(size_t *)availableSpacePtr
-{
-	if (bufferPtr) *bufferPtr = writePointer;
-	if (availableSpacePtr) *availableSpacePtr = [self availableSpace];
-}
-
-- (void)didWrite:(size_t)bytesWritten
-{
-	writePointer += bytesWritten;
-}
-
-- (void)reset
-{
-	readPointer  = preBuffer;
-	writePointer = preBuffer;
-}
-
-@end
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark -
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/**
- * The GCDAsyncReadPacket encompasses the instructions for any given read.
- * The content of a read packet allows the code to determine if we're:
- *  - reading to a certain length
- *  - reading to a certain separator
- *  - or simply reading the first chunk of available data
-**/
-@interface GCDAsyncReadPacket : NSObject
-{
-  @public
-	NSMutableData *buffer;
-	NSUInteger startOffset;
-	NSUInteger bytesDone;
-	NSUInteger maxLength;
-	NSTimeInterval timeout;
-	NSUInteger readLength;
-	NSData *term;
-	BOOL bufferOwner;
-	NSUInteger originalBufferLength;
-	long tag;
-}
-- (id)initWithData:(NSMutableData *)d
-       startOffset:(NSUInteger)s
-         maxLength:(NSUInteger)m
-           timeout:(NSTimeInterval)t
-        readLength:(NSUInteger)l
-        terminator:(NSData *)e
-               tag:(long)i;
-
-- (void)ensureCapacityForAdditionalDataOfLength:(NSUInteger)bytesToRead;
-
-- (NSUInteger)optimalReadLengthWithDefault:(NSUInteger)defaultValue shouldPreBuffer:(BOOL *)shouldPreBufferPtr;
-
-- (NSUInteger)readLengthForNonTermWithHint:(NSUInteger)bytesAvailable;
-- (NSUInteger)readLengthForTermWithHint:(NSUInteger)bytesAvailable shouldPreBuffer:(BOOL *)shouldPreBufferPtr;
-- (NSUInteger)readLengthForTermWithPreBuffer:(GCDAsyncSocketPreBuffer *)preBuffer found:(BOOL *)foundPtr;
-
-- (NSInteger)searchForTermAfterPreBuffering:(ssize_t)numBytes;
-
-@end
-
-@implementation GCDAsyncReadPacket
-
-- (id)initWithData:(NSMutableData *)d
-       startOffset:(NSUInteger)s
-         maxLength:(NSUInteger)m
-           timeout:(NSTimeInterval)t
-        readLength:(NSUInteger)l
-        terminator:(NSData *)e
-               tag:(long)i
-{
-	if((self = [super init]))
-	{
-		bytesDone = 0;
-		maxLength = m;
-		timeout = t;
-		readLength = l;
-		term = [e copy];
-		tag = i;
-		
-		if (d)
-		{
-			buffer = d;
-			startOffset = s;
-			bufferOwner = NO;
-			originalBufferLength = [d length];
-		}
-		else
-		{
-			if (readLength > 0)
-				buffer = [[NSMutableData alloc] initWithLength:readLength];
-			else
-				buffer = [[NSMutableData alloc] initWithLength:0];
-			
-			startOffset = 0;
-			bufferOwner = YES;
-			originalBufferLength = 0;
-		}
-	}
-	return self;
-}
-
-/**
- * Increases the length of the buffer (if needed) to ensure a read of the given size will fit.
-**/
-- (void)ensureCapacityForAdditionalDataOfLength:(NSUInteger)bytesToRead
-{
-	NSUInteger buffSize = [buffer length];
-	NSUInteger buffUsed = startOffset + bytesDone;
-	
-	NSUInteger buffSpace = buffSize - buffUsed;
-	
-	if (bytesToRead > buffSpace)
-	{
-		NSUInteger buffInc = bytesToRead - buffSpace;
-		
-		[buffer increaseLengthBy:buffInc];
-	}
-}
-
-/**
- * This method is used when we do NOT know how much data is available to be read from the socket.
- * This method returns the default value unless it exceeds the specified readLength or maxLength.
- * 
- * Furthermore, the shouldPreBuffer decision is based upon the packet type,
- * and whether the returned value would fit in the current buffer without requiring a resize of the buffer.
-**/
-- (NSUInteger)optimalReadLengthWithDefault:(NSUInteger)defaultValue shouldPreBuffer:(BOOL *)shouldPreBufferPtr
-{
-	NSUInteger result;
-	
-	if (readLength > 0)
-	{
-		// Read a specific length of data
-		
-		result = MIN(defaultValue, (readLength - bytesDone));
-		
-		// There is no need to prebuffer since we know exactly how much data we need to read.
-		// Even if the buffer isn't currently big enough to fit this amount of data,
-		// it would have to be resized eventually anyway.
-		
-		if (shouldPreBufferPtr)
-			*shouldPreBufferPtr = NO;
-	}
-	else
-	{
-		// Either reading until we find a specified terminator,
-		// or we're simply reading all available data.
-		// 
-		// In other words, one of:
-		// 
-		// - readDataToData packet
-		// - readDataWithTimeout packet
-		
-		if (maxLength > 0)
-			result =  MIN(defaultValue, (maxLength - bytesDone));
-		else
-			result = defaultValue;
-		
-		// Since we don't know the size of the read in advance,
-		// the shouldPreBuffer decision is based upon whether the returned value would fit
-		// in the current buffer without requiring a resize of the buffer.
-		// 
-		// This is because, in all likelyhood, the amount read from the socket will be less than the default value.
-		// Thus we should avoid over-allocating the read buffer when we can simply use the pre-buffer instead.
-		
-		if (shouldPreBufferPtr)
-		{
-			NSUInteger buffSize = [buffer length];
-			NSUInteger buffUsed = startOffset + bytesDone;
-			
-			NSUInteger buffSpace = buffSize - buffUsed;
-			
-			if (buffSpace >= result)
-				*shouldPreBufferPtr = NO;
-			else
-				*shouldPreBufferPtr = YES;
-		}
-	}
-	
-	return result;
-}
-
-/**
- * For read packets without a set terminator, returns the amount of data
- * that can be read without exceeding the readLength or maxLength.
- * 
- * The given parameter indicates the number of bytes estimated to be available on the socket,
- * which is taken into consideration during the calculation.
- * 
- * The given hint MUST be greater than zero.
-**/
-- (NSUInteger)readLengthForNonTermWithHint:(NSUInteger)bytesAvailable
-{
-	NSAssert(term == nil, @"This method does not apply to term reads");
-	NSAssert(bytesAvailable > 0, @"Invalid parameter: bytesAvailable");
-	
-	if (readLength > 0)
-	{
-		// Read a specific length of data
-		
-		return MIN(bytesAvailable, (readLength - bytesDone));
-		
-		// No need to avoid resizing the buffer.
-		// If the user provided their own buffer,
-		// and told us to read a certain length of data that exceeds the size of the buffer,
-		// then it is clear that our code will resize the buffer during the read operation.
-		// 
-		// This method does not actually do any resizing.
-		// The resizing will happen elsewhere if needed.
-	}
-	else
-	{
-		// Read all available data
-		
-		NSUInteger result = bytesAvailable;
-		
-		if (maxLength > 0)
-		{
-			result = MIN(result, (maxLength - bytesDone));
-		}
-		
-		// No need to avoid resizing the buffer.
-		// If the user provided their own buffer,
-		// and told us to read all available data without giving us a maxLength,
-		// then it is clear that our code might resize the buffer during the read operation.
-		// 
-		// This method does not actually do any resizing.
-		// The resizing will happen elsewhere if needed.
-		
-		return result;
-	}
-}
-
-/**
- * For read packets with a set terminator, returns the amount of data
- * that can be read without exceeding the maxLength.
- * 
- * The given parameter indicates the number of bytes estimated to be available on the socket,
- * which is taken into consideration during the calculation.
- * 
- * To optimize memory allocations, mem copies, and mem moves
- * the shouldPreBuffer boolean value will indicate if the data should be read into a prebuffer first,
- * or if the data can be read directly into the read packet's buffer.
-**/
-- (NSUInteger)readLengthForTermWithHint:(NSUInteger)bytesAvailable shouldPreBuffer:(BOOL *)shouldPreBufferPtr
-{
-	NSAssert(term != nil, @"This method does not apply to non-term reads");
-	NSAssert(bytesAvailable > 0, @"Invalid parameter: bytesAvailable");
-	
-	
-	NSUInteger result = bytesAvailable;
-	
-	if (maxLength > 0)
-	{
-		result = MIN(result, (maxLength - bytesDone));
-	}
-	
-	// Should the data be read into the read packet's buffer, or into a pre-buffer first?
-	// 
-	// One would imagine the preferred option is the faster one.
-	// So which one is faster?
-	// 
-	// Reading directly into the packet's buffer requires:
-	// 1. Possibly resizing packet buffer (malloc/realloc)
-	// 2. Filling buffer (read)
-	// 3. Searching for term (memcmp)
-	// 4. Possibly copying overflow into prebuffer (malloc/realloc, memcpy)
-	// 
-	// Reading into prebuffer first:
-	// 1. Possibly resizing prebuffer (malloc/realloc)
-	// 2. Filling buffer (read)
-	// 3. Searching for term (memcmp)
-	// 4. Copying underflow into packet buffer (malloc/realloc, memcpy)
-	// 5. Removing underflow from prebuffer (memmove)
-	// 
-	// Comparing the performance of the two we can see that reading
-	// data into the prebuffer first is slower due to the extra memove.
-	// 
-	// However:
-	// The implementation of NSMutableData is open source via core foundation's CFMutableData.
-	// Decreasing the length of a mutable data object doesn't cause a realloc.
-	// In other words, the capacity of a mutable data object can grow, but doesn't shrink.
-	// 
-	// This means the prebuffer will rarely need a realloc.
-	// The packet buffer, on the other hand, may often need a realloc.
-	// This is especially true if we are the buffer owner.
-	// Furthermore, if we are constantly realloc'ing the packet buffer,
-	// and then moving the overflow into the prebuffer,
-	// then we're consistently over-allocating memory for each term read.
-	// And now we get into a bit of a tradeoff between speed and memory utilization.
-	// 
-	// The end result is that the two perform very similarly.
-	// And we can answer the original question very simply by another means.
-	// 
-	// If we can read all the data directly into the packet's buffer without resizing it first,
-	// then we do so. Otherwise we use the prebuffer.
-	
-	if (shouldPreBufferPtr)
-	{
-		NSUInteger buffSize = [buffer length];
-		NSUInteger buffUsed = startOffset + bytesDone;
-		
-		if ((buffSize - buffUsed) >= result)
-			*shouldPreBufferPtr = NO;
-		else
-			*shouldPreBufferPtr = YES;
-	}
-	
-	return result;
-}
-
-/**
- * For read packets with a set terminator,
- * returns the amount of data that can be read from the given preBuffer,
- * without going over a terminator or the maxLength.
- * 
- * It is assumed the terminator has not already been read.
-**/
-- (NSUInteger)readLengthForTermWithPreBuffer:(GCDAsyncSocketPreBuffer *)preBuffer found:(BOOL *)foundPtr
-{
-	NSAssert(term != nil, @"This method does not apply to non-term reads");
-	NSAssert([preBuffer availableBytes] > 0, @"Invoked with empty pre buffer!");
-	
-	// We know that the terminator, as a whole, doesn't exist in our own buffer.
-	// But it is possible that a _portion_ of it exists in our buffer.
-	// So we're going to look for the terminator starting with a portion of our own buffer.
-	// 
-	// Example:
-	// 
-	// term length      = 3 bytes
-	// bytesDone        = 5 bytes
-	// preBuffer length = 5 bytes
-	// 
-	// If we append the preBuffer to our buffer,
-	// it would look like this:
-	// 
-	// ---------------------
-	// |B|B|B|B|B|P|P|P|P|P|
-	// ---------------------
-	// 
-	// So we start our search here:
-	// 
-	// ---------------------
-	// |B|B|B|B|B|P|P|P|P|P|
-	// -------^-^-^---------
-	// 
-	// And move forwards...
-	// 
-	// ---------------------
-	// |B|B|B|B|B|P|P|P|P|P|
-	// ---------^-^-^-------
-	// 
-	// Until we find the terminator or reach the end.
-	// 
-	// ---------------------
-	// |B|B|B|B|B|P|P|P|P|P|
-	// ---------------^-^-^-
-	
-	BOOL found = NO;
-	
-	NSUInteger termLength = [term length];
-	NSUInteger preBufferLength = [preBuffer availableBytes];
-	
-	if ((bytesDone + preBufferLength) < termLength)
-	{
-		// Not enough data for a full term sequence yet
-		return preBufferLength;
-	}
-	
-	NSUInteger maxPreBufferLength;
-	if (maxLength > 0) {
-		maxPreBufferLength = MIN(preBufferLength, (maxLength - bytesDone));
-		
-		// Note: maxLength >= termLength
-	}
-	else {
-		maxPreBufferLength = preBufferLength;
-	}
-	
-	uint8_t seq[termLength];
-	const void *termBuf = [term bytes];
-	
-	NSUInteger bufLen = MIN(bytesDone, (termLength - 1));
-	uint8_t *buf = (uint8_t *)[buffer mutableBytes] + startOffset + bytesDone - bufLen;
-	
-	NSUInteger preLen = termLength - bufLen;
-	const uint8_t *pre = [preBuffer readBuffer];
-	
-	NSUInteger loopCount = bufLen + maxPreBufferLength - termLength + 1; // Plus one. See example above.
-	
-	NSUInteger result = maxPreBufferLength;
-	
-	NSUInteger i;
-	for (i = 0; i < loopCount; i++)
-	{
-		if (bufLen > 0)
-		{
-			// Combining bytes from buffer and preBuffer
-			
-			memcpy(seq, buf, bufLen);
-			memcpy(seq + bufLen, pre, preLen);
-			
-			if (memcmp(seq, termBuf, termLength) == 0)
-			{
-				result = preLen;
-				found = YES;
-				break;
-			}
-			
-			buf++;
-			bufLen--;
-			preLen++;
-		}
-		else
-		{
-			// Comparing directly from preBuffer
-			
-			if (memcmp(pre, termBuf, termLength) == 0)
-			{
-				NSUInteger preOffset = pre - [preBuffer readBuffer]; // pointer arithmetic
-				
-				result = preOffset + termLength;
-				found = YES;
-				break;
-			}
-			
-			pre++;
-		}
-	}
-	
-	// There is no need to avoid resizing the buffer in this particular situation.
-	
-	if (foundPtr) *foundPtr = found;
-	return result;
-}
-
-/**
- * For read packets with a set terminator, scans the packet buffer for the term.
- * It is assumed the terminator had not been fully read prior to the new bytes.
- * 
- * If the term is found, the number of excess bytes after the term are returned.
- * If the term is not found, this method will return -1.
- * 
- * Note: A return value of zero means the term was found at the very end.
- * 
- * Prerequisites:
- * The given number of bytes have been added to the end of our buffer.
- * Our bytesDone variable has NOT been changed due to the prebuffered bytes.
-**/
-- (NSInteger)searchForTermAfterPreBuffering:(ssize_t)numBytes
-{
-	NSAssert(term != nil, @"This method does not apply to non-term reads");
-	
-	// The implementation of this method is very similar to the above method.
-	// See the above method for a discussion of the algorithm used here.
-	
-	uint8_t *buff = [buffer mutableBytes];
-	NSUInteger buffLength = bytesDone + numBytes;
-	
-	const void *termBuff = [term bytes];
-	NSUInteger termLength = [term length];
-	
-	// Note: We are dealing with unsigned integers,
-	// so make sure the math doesn't go below zero.
-	
-	NSUInteger i = ((buffLength - numBytes) >= termLength) ? (buffLength - numBytes - termLength + 1) : 0;
-	
-	while (i + termLength <= buffLength)
-	{
-		uint8_t *subBuffer = buff + startOffset + i;
-		
-		if (memcmp(subBuffer, termBuff, termLength) == 0)
-		{
-			return buffLength - (i + termLength);
-		}
-		
-		i++;
-	}
-	
-	return -1;
-}
-
-
-@end
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark -
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/**
- * The GCDAsyncWritePacket encompasses the instructions for any given write.
-**/
-@interface GCDAsyncWritePacket : NSObject
-{
-  @public
-	NSData *buffer;
-	NSUInteger bytesDone;
-	long tag;
-	NSTimeInterval timeout;
-}
-- (id)initWithData:(NSData *)d timeout:(NSTimeInterval)t tag:(long)i;
-@end
-
-@implementation GCDAsyncWritePacket
-
-- (id)initWithData:(NSData *)d timeout:(NSTimeInterval)t tag:(long)i
-{
-	if((self = [super init]))
-	{
-		buffer = d; // Retain not copy. For performance as documented in header file.
-		bytesDone = 0;
-		timeout = t;
-		tag = i;
-	}
-	return self;
-}
-
-
-@end
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark -
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/**
- * The GCDAsyncSpecialPacket encompasses special instructions for interruptions in the read/write queues.
- * This class my be altered to support more than just TLS in the future.
-**/
-@interface GCDAsyncSpecialPacket : NSObject
-{
-  @public
-	NSDictionary *tlsSettings;
-}
-- (id)initWithTLSSettings:(NSDictionary *)settings;
-@end
-
-@implementation GCDAsyncSpecialPacket
-
-- (id)initWithTLSSettings:(NSDictionary *)settings
-{
-	if((self = [super init]))
-	{
-		tlsSettings = [settings copy];
-	}
-	return self;
-}
-
-
-@end
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark -
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-@implementation GCDAsyncSocket
-{
-	uint32_t flags;
-	uint16_t config;
-	
-	__weak id<GCDAsyncSocketDelegate> delegate;
-	dispatch_queue_t delegateQueue;
-	
-	int socket4FD;
-	int socket6FD;
-	int socketUN;
-	NSURL *socketUrl;
-	int stateIndex;
-	NSData * connectInterface4;
-	NSData * connectInterface6;
-	NSData * connectInterfaceUN;
-	
-	dispatch_queue_t socketQueue;
-	
-	dispatch_source_t accept4Source;
-	dispatch_source_t accept6Source;
-	dispatch_source_t acceptUNSource;
-	dispatch_source_t connectTimer;
-	dispatch_source_t readSource;
-	dispatch_source_t writeSource;
-	dispatch_source_t readTimer;
-	dispatch_source_t writeTimer;
-	
-	NSMutableArray *readQueue;
-	NSMutableArray *writeQueue;
-	
-	GCDAsyncReadPacket *currentRead;
-	GCDAsyncWritePacket *currentWrite;
-	
-	unsigned long socketFDBytesAvailable;
-	
-	GCDAsyncSocketPreBuffer *preBuffer;
-		
-#if TARGET_OS_IPHONE
-	CFStreamClientContext streamContext;
-	CFReadStreamRef readStream;
-	CFWriteStreamRef writeStream;
-#endif
-	SSLContextRef sslContext;
-	GCDAsyncSocketPreBuffer *sslPreBuffer;
-	size_t sslWriteCachedLength;
-	OSStatus sslErrCode;
-    OSStatus lastSSLHandshakeError;
-	
-	void *IsOnSocketQueueOrTargetQueueKey;
-	
-	id userData;
-    NSTimeInterval alternateAddressDelay;
-}
-
-- (id)init
-{
-	return [self initWithDelegate:nil delegateQueue:NULL socketQueue:NULL];
-}
-
-- (id)initWithSocketQueue:(dispatch_queue_t)sq
-{
-	return [self initWithDelegate:nil delegateQueue:NULL socketQueue:sq];
-}
-
-- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq
-{
-	return [self initWithDelegate:aDelegate delegateQueue:dq socketQueue:NULL];
-}
-
-- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq
-{
-	if((self = [super init]))
-	{
-		delegate = aDelegate;
-		delegateQueue = dq;
-		
-		#if !OS_OBJECT_USE_OBJC
-		if (dq) dispatch_retain(dq);
-		#endif
-		
-		socket4FD = SOCKET_NULL;
-		socket6FD = SOCKET_NULL;
-		socketUN = SOCKET_NULL;
-		socketUrl = nil;
-		stateIndex = 0;
-		
-		if (sq)
-		{
-			NSAssert(sq != dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0),
-			         @"The given socketQueue parameter must not be a concurrent queue.");
-			NSAssert(sq != dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0),
-			         @"The given socketQueue parameter must not be a concurrent queue.");
-			NSAssert(sq != dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
-			         @"The given socketQueue parameter must not be a concurrent queue.");
-			
-			socketQueue = sq;
-			#if !OS_OBJECT_USE_OBJC
-			dispatch_retain(sq);
-			#endif
-		}
-		else
-		{
-			socketQueue = dispatch_queue_create([GCDAsyncSocketQueueName UTF8String], NULL);
-		}
-		
-		// The dispatch_queue_set_specific() and dispatch_get_specific() functions take a "void *key" parameter.
-		// From the documentation:
-		//
-		// > Keys are only compared as pointers and are never dereferenced.
-		// > Thus, you can use a pointer to a static variable for a specific subsystem or
-		// > any other value that allows you to identify the value uniquely.
-		//
-		// We're just going to use the memory address of an ivar.
-		// Specifically an ivar that is explicitly named for our purpose to make the code more readable.
-		//
-		// However, it feels tedious (and less readable) to include the "&" all the time:
-		// dispatch_get_specific(&IsOnSocketQueueOrTargetQueueKey)
-		//
-		// So we're going to make it so it doesn't matter if we use the '&' or not,
-		// by assigning the value of the ivar to the address of the ivar.
-		// Thus: IsOnSocketQueueOrTargetQueueKey == &IsOnSocketQueueOrTargetQueueKey;
-		
-		IsOnSocketQueueOrTargetQueueKey = &IsOnSocketQueueOrTargetQueueKey;
-		
-		void *nonNullUnusedPointer = (__bridge void *)self;
-		dispatch_queue_set_specific(socketQueue, IsOnSocketQueueOrTargetQueueKey, nonNullUnusedPointer, NULL);
-		
-		readQueue = [[NSMutableArray alloc] initWithCapacity:5];
-		currentRead = nil;
-		
-		writeQueue = [[NSMutableArray alloc] initWithCapacity:5];
-		currentWrite = nil;
-		
-		preBuffer = [[GCDAsyncSocketPreBuffer alloc] initWithCapacity:(1024 * 4)];
-        alternateAddressDelay = 0.3;
-	}
-	return self;
-}
-
-- (void)dealloc
-{
-	LogInfo(@"%@ - %@ (start)", THIS_METHOD, self);
-	
-	// Set dealloc flag.
-	// This is used by closeWithError to ensure we don't accidentally retain ourself.
-	flags |= kDealloc;
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		[self closeWithError:nil];
-	}
-	else
-	{
-		dispatch_sync(socketQueue, ^{
-			[self closeWithError:nil];
-		});
-	}
-	
-	delegate = nil;
-	
-	#if !OS_OBJECT_USE_OBJC
-	if (delegateQueue) dispatch_release(delegateQueue);
-	#endif
-	delegateQueue = NULL;
-	
-	#if !OS_OBJECT_USE_OBJC
-	if (socketQueue) dispatch_release(socketQueue);
-	#endif
-	socketQueue = NULL;
-	
-	LogInfo(@"%@ - %@ (finish)", THIS_METHOD, self);
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Configuration
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (id)delegate
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return delegate;
-	}
-	else
-	{
-		__block id result;
-		
-		dispatch_sync(socketQueue, ^{
-			result = delegate;
-		});
-		
-		return result;
-	}
-}
-
-- (void)setDelegate:(id)newDelegate synchronously:(BOOL)synchronously
-{
-	dispatch_block_t block = ^{
-		delegate = newDelegate;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey)) {
-		block();
-	}
-	else {
-		if (synchronously)
-			dispatch_sync(socketQueue, block);
-		else
-			dispatch_async(socketQueue, block);
-	}
-}
-
-- (void)setDelegate:(id)newDelegate
-{
-	[self setDelegate:newDelegate synchronously:NO];
-}
-
-- (void)synchronouslySetDelegate:(id)newDelegate
-{
-	[self setDelegate:newDelegate synchronously:YES];
-}
-
-- (dispatch_queue_t)delegateQueue
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return delegateQueue;
-	}
-	else
-	{
-		__block dispatch_queue_t result;
-		
-		dispatch_sync(socketQueue, ^{
-			result = delegateQueue;
-		});
-		
-		return result;
-	}
-}
-
-- (void)setDelegateQueue:(dispatch_queue_t)newDelegateQueue synchronously:(BOOL)synchronously
-{
-	dispatch_block_t block = ^{
-		
-		#if !OS_OBJECT_USE_OBJC
-		if (delegateQueue) dispatch_release(delegateQueue);
-		if (newDelegateQueue) dispatch_retain(newDelegateQueue);
-		#endif
-		
-		delegateQueue = newDelegateQueue;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey)) {
-		block();
-	}
-	else {
-		if (synchronously)
-			dispatch_sync(socketQueue, block);
-		else
-			dispatch_async(socketQueue, block);
-	}
-}
-
-- (void)setDelegateQueue:(dispatch_queue_t)newDelegateQueue
-{
-	[self setDelegateQueue:newDelegateQueue synchronously:NO];
-}
-
-- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)newDelegateQueue
-{
-	[self setDelegateQueue:newDelegateQueue synchronously:YES];
-}
-
-- (void)getDelegate:(id<GCDAsyncSocketDelegate> *)delegatePtr delegateQueue:(dispatch_queue_t *)delegateQueuePtr
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		if (delegatePtr) *delegatePtr = delegate;
-		if (delegateQueuePtr) *delegateQueuePtr = delegateQueue;
-	}
-	else
-	{
-		__block id dPtr = NULL;
-		__block dispatch_queue_t dqPtr = NULL;
-		
-		dispatch_sync(socketQueue, ^{
-			dPtr = delegate;
-			dqPtr = delegateQueue;
-		});
-		
-		if (delegatePtr) *delegatePtr = dPtr;
-		if (delegateQueuePtr) *delegateQueuePtr = dqPtr;
-	}
-}
-
-- (void)setDelegate:(id)newDelegate delegateQueue:(dispatch_queue_t)newDelegateQueue synchronously:(BOOL)synchronously
-{
-	dispatch_block_t block = ^{
-		
-		delegate = newDelegate;
-		
-		#if !OS_OBJECT_USE_OBJC
-		if (delegateQueue) dispatch_release(delegateQueue);
-		if (newDelegateQueue) dispatch_retain(newDelegateQueue);
-		#endif
-		
-		delegateQueue = newDelegateQueue;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey)) {
-		block();
-	}
-	else {
-		if (synchronously)
-			dispatch_sync(socketQueue, block);
-		else
-			dispatch_async(socketQueue, block);
-	}
-}
-
-- (void)setDelegate:(id)newDelegate delegateQueue:(dispatch_queue_t)newDelegateQueue
-{
-	[self setDelegate:newDelegate delegateQueue:newDelegateQueue synchronously:NO];
-}
-
-- (void)synchronouslySetDelegate:(id)newDelegate delegateQueue:(dispatch_queue_t)newDelegateQueue
-{
-	[self setDelegate:newDelegate delegateQueue:newDelegateQueue synchronously:YES];
-}
-
-- (BOOL)isIPv4Enabled
-{
-	// Note: YES means kIPv4Disabled is OFF
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return ((config & kIPv4Disabled) == 0);
-	}
-	else
-	{
-		__block BOOL result;
-		
-		dispatch_sync(socketQueue, ^{
-			result = ((config & kIPv4Disabled) == 0);
-		});
-		
-		return result;
-	}
-}
-
-- (void)setIPv4Enabled:(BOOL)flag
-{
-	// Note: YES means kIPv4Disabled is OFF
-	
-	dispatch_block_t block = ^{
-		
-		if (flag)
-			config &= ~kIPv4Disabled;
-		else
-			config |= kIPv4Disabled;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_async(socketQueue, block);
-}
-
-- (BOOL)isIPv6Enabled
-{
-	// Note: YES means kIPv6Disabled is OFF
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return ((config & kIPv6Disabled) == 0);
-	}
-	else
-	{
-		__block BOOL result;
-		
-		dispatch_sync(socketQueue, ^{
-			result = ((config & kIPv6Disabled) == 0);
-		});
-		
-		return result;
-	}
-}
-
-- (void)setIPv6Enabled:(BOOL)flag
-{
-	// Note: YES means kIPv6Disabled is OFF
-	
-	dispatch_block_t block = ^{
-		
-		if (flag)
-			config &= ~kIPv6Disabled;
-		else
-			config |= kIPv6Disabled;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_async(socketQueue, block);
-}
-
-- (BOOL)isIPv4PreferredOverIPv6
-{
-	// Note: YES means kPreferIPv6 is OFF
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return ((config & kPreferIPv6) == 0);
-	}
-	else
-	{
-		__block BOOL result;
-		
-		dispatch_sync(socketQueue, ^{
-			result = ((config & kPreferIPv6) == 0);
-		});
-		
-		return result;
-	}
-}
-
-- (void)setIPv4PreferredOverIPv6:(BOOL)flag
-{
-	// Note: YES means kPreferIPv6 is OFF
-	
-	dispatch_block_t block = ^{
-		
-		if (flag)
-			config &= ~kPreferIPv6;
-		else
-			config |= kPreferIPv6;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_async(socketQueue, block);
-}
-
-- (NSTimeInterval) alternateAddressDelay {
-    __block NSTimeInterval delay;
-    dispatch_block_t block = ^{
-        delay = alternateAddressDelay;
-    };
-    if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-        block();
-    else
-        dispatch_sync(socketQueue, block);
-    return delay;
-}
-
-- (void) setAlternateAddressDelay:(NSTimeInterval)delay {
-    dispatch_block_t block = ^{
-        alternateAddressDelay = delay;
-    };
-    if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-        block();
-    else
-        dispatch_async(socketQueue, block);
-}
-
-- (id)userData
-{
-	__block id result = nil;
-	
-	dispatch_block_t block = ^{
-		
-		result = userData;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	return result;
-}
-
-- (void)setUserData:(id)arbitraryUserData
-{
-	dispatch_block_t block = ^{
-		
-		if (userData != arbitraryUserData)
-		{
-			userData = arbitraryUserData;
-		}
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_async(socketQueue, block);
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Accepting
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (BOOL)acceptOnPort:(uint16_t)port error:(NSError **)errPtr
-{
-	return [self acceptOnInterface:nil port:port error:errPtr];
-}
-
-- (BOOL)acceptOnInterface:(NSString *)inInterface port:(uint16_t)port error:(NSError **)errPtr
-{
-	LogTrace();
-	
-	// Just in-case interface parameter is immutable.
-	NSString *interface = [inInterface copy];
-	
-	__block BOOL result = NO;
-	__block NSError *err = nil;
-	
-	// CreateSocket Block
-	// This block will be invoked within the dispatch block below.
-	
-	int(^createSocket)(int, NSData*) = ^int (int domain, NSData *interfaceAddr) {
-		
-		int socketFD = socket(domain, SOCK_STREAM, 0);
-		
-		if (socketFD == SOCKET_NULL)
-		{
-			NSString *reason = @"Error in socket() function";
-			err = [self errnoErrorWithReason:reason];
-			
-			return SOCKET_NULL;
-		}
-		
-		int status;
-		
-		// Set socket options
-		
-		status = fcntl(socketFD, F_SETFL, O_NONBLOCK);
-		if (status == -1)
-		{
-			NSString *reason = @"Error enabling non-blocking IO on socket (fcntl)";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		int reuseOn = 1;
-		status = setsockopt(socketFD, SOL_SOCKET, SO_REUSEADDR, &reuseOn, sizeof(reuseOn));
-		if (status == -1)
-		{
-			NSString *reason = @"Error enabling address reuse (setsockopt)";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		// Bind socket
-		
-		status = bind(socketFD, (const struct sockaddr *)[interfaceAddr bytes], (socklen_t)[interfaceAddr length]);
-		if (status == -1)
-		{
-			NSString *reason = @"Error in bind() function";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		// Listen
-		
-		status = listen(socketFD, 1024);
-		if (status == -1)
-		{
-			NSString *reason = @"Error in listen() function";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		return socketFD;
-	};
-	
-	// Create dispatch block and run on socketQueue
-	
-	dispatch_block_t block = ^{ @autoreleasepool {
-		
-		if (delegate == nil) // Must have delegate set
-		{
-			NSString *msg = @"Attempting to accept without a delegate. Set a delegate first.";
-			err = [self badConfigError:msg];
-			
-			return_from_block;
-		}
-		
-		if (delegateQueue == NULL) // Must have delegate queue set
-		{
-			NSString *msg = @"Attempting to accept without a delegate queue. Set a delegate queue first.";
-			err = [self badConfigError:msg];
-			
-			return_from_block;
-		}
-		
-		BOOL isIPv4Disabled = (config & kIPv4Disabled) ? YES : NO;
-		BOOL isIPv6Disabled = (config & kIPv6Disabled) ? YES : NO;
-		
-		if (isIPv4Disabled && isIPv6Disabled) // Must have IPv4 or IPv6 enabled
-		{
-			NSString *msg = @"Both IPv4 and IPv6 have been disabled. Must enable at least one protocol first.";
-			err = [self badConfigError:msg];
-			
-			return_from_block;
-		}
-		
-		if (![self isDisconnected]) // Must be disconnected
-		{
-			NSString *msg = @"Attempting to accept while connected or accepting connections. Disconnect first.";
-			err = [self badConfigError:msg];
-			
-			return_from_block;
-		}
-		
-		// Clear queues (spurious read/write requests post disconnect)
-		[readQueue removeAllObjects];
-		[writeQueue removeAllObjects];
-		
-		// Resolve interface from description
-		
-		NSMutableData *interface4 = nil;
-		NSMutableData *interface6 = nil;
-		
-		[self getInterfaceAddress4:&interface4 address6:&interface6 fromDescription:interface port:port];
-		
-		if ((interface4 == nil) && (interface6 == nil))
-		{
-			NSString *msg = @"Unknown interface. Specify valid interface by name (e.g. \"en1\") or IP address.";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		if (isIPv4Disabled && (interface6 == nil))
-		{
-			NSString *msg = @"IPv4 has been disabled and specified interface doesn't support IPv6.";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		if (isIPv6Disabled && (interface4 == nil))
-		{
-			NSString *msg = @"IPv6 has been disabled and specified interface doesn't support IPv4.";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		BOOL enableIPv4 = !isIPv4Disabled && (interface4 != nil);
-		BOOL enableIPv6 = !isIPv6Disabled && (interface6 != nil);
-		
-		// Create sockets, configure, bind, and listen
-		
-		if (enableIPv4)
-		{
-			LogVerbose(@"Creating IPv4 socket");
-			socket4FD = createSocket(AF_INET, interface4);
-			
-			if (socket4FD == SOCKET_NULL)
-			{
-				return_from_block;
-			}
-		}
-		
-		if (enableIPv6)
-		{
-			LogVerbose(@"Creating IPv6 socket");
-			
-			if (enableIPv4 && (port == 0))
-			{
-				// No specific port was specified, so we allowed the OS to pick an available port for us.
-				// Now we need to make sure the IPv6 socket listens on the same port as the IPv4 socket.
-				
-				struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)[interface6 mutableBytes];
-				addr6->sin6_port = htons([self localPort4]);
-			}
-			
-			socket6FD = createSocket(AF_INET6, interface6);
-			
-			if (socket6FD == SOCKET_NULL)
-			{
-				if (socket4FD != SOCKET_NULL)
-				{
-					LogVerbose(@"close(socket4FD)");
-					close(socket4FD);
-				}
-				
-				return_from_block;
-			}
-		}
-		
-		// Create accept sources
-		
-		if (enableIPv4)
-		{
-			accept4Source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socket4FD, 0, socketQueue);
-			
-			int socketFD = socket4FD;
-			dispatch_source_t acceptSource = accept4Source;
-			
-			__weak GCDAsyncSocket *weakSelf = self;
-			
-			dispatch_source_set_event_handler(accept4Source, ^{ @autoreleasepool {
-			#pragma clang diagnostic push
-			#pragma clang diagnostic warning "-Wimplicit-retain-self"
-				
-				__strong GCDAsyncSocket *strongSelf = weakSelf;
-				if (strongSelf == nil) return_from_block;
-				
-				LogVerbose(@"event4Block");
-				
-				unsigned long i = 0;
-				unsigned long numPendingConnections = dispatch_source_get_data(acceptSource);
-				
-				LogVerbose(@"numPendingConnections: %lu", numPendingConnections);
-				
-				while ([strongSelf doAccept:socketFD] && (++i < numPendingConnections));
-				
-			#pragma clang diagnostic pop
-			}});
-			
-			
-			dispatch_source_set_cancel_handler(accept4Source, ^{
-			#pragma clang diagnostic push
-			#pragma clang diagnostic warning "-Wimplicit-retain-self"
-				
-				#if !OS_OBJECT_USE_OBJC
-				LogVerbose(@"dispatch_release(accept4Source)");
-				dispatch_release(acceptSource);
-				#endif
-				
-				LogVerbose(@"close(socket4FD)");
-				close(socketFD);
-			
-			#pragma clang diagnostic pop
-			});
-			
-			LogVerbose(@"dispatch_resume(accept4Source)");
-			dispatch_resume(accept4Source);
-		}
-		
-		if (enableIPv6)
-		{
-			accept6Source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socket6FD, 0, socketQueue);
-			
-			int socketFD = socket6FD;
-			dispatch_source_t acceptSource = accept6Source;
-			
-			__weak GCDAsyncSocket *weakSelf = self;
-			
-			dispatch_source_set_event_handler(accept6Source, ^{ @autoreleasepool {
-			#pragma clang diagnostic push
-			#pragma clang diagnostic warning "-Wimplicit-retain-self"
-				
-				__strong GCDAsyncSocket *strongSelf = weakSelf;
-				if (strongSelf == nil) return_from_block;
-				
-				LogVerbose(@"event6Block");
-				
-				unsigned long i = 0;
-				unsigned long numPendingConnections = dispatch_source_get_data(acceptSource);
-				
-				LogVerbose(@"numPendingConnections: %lu", numPendingConnections);
-				
-				while ([strongSelf doAccept:socketFD] && (++i < numPendingConnections));
-				
-			#pragma clang diagnostic pop
-			}});
-			
-			dispatch_source_set_cancel_handler(accept6Source, ^{
-			#pragma clang diagnostic push
-			#pragma clang diagnostic warning "-Wimplicit-retain-self"
-				
-				#if !OS_OBJECT_USE_OBJC
-				LogVerbose(@"dispatch_release(accept6Source)");
-				dispatch_release(acceptSource);
-				#endif
-				
-				LogVerbose(@"close(socket6FD)");
-				close(socketFD);
-				
-			#pragma clang diagnostic pop
-			});
-			
-			LogVerbose(@"dispatch_resume(accept6Source)");
-			dispatch_resume(accept6Source);
-		}
-		
-		flags |= kSocketStarted;
-		
-		result = YES;
-	}};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	if (result == NO)
-	{
-		LogInfo(@"Error in accept: %@", err);
-		
-		if (errPtr)
-			*errPtr = err;
-	}
-	
-	return result;
-}
-
-- (BOOL)acceptOnUrl:(NSURL *)url error:(NSError **)errPtr;
-{
-	LogTrace();
-	
-	__block BOOL result = NO;
-	__block NSError *err = nil;
-	
-	// CreateSocket Block
-	// This block will be invoked within the dispatch block below.
-	
-	int(^createSocket)(int, NSData*) = ^int (int domain, NSData *interfaceAddr) {
-		
-		int socketFD = socket(domain, SOCK_STREAM, 0);
-		
-		if (socketFD == SOCKET_NULL)
-		{
-			NSString *reason = @"Error in socket() function";
-			err = [self errnoErrorWithReason:reason];
-			
-			return SOCKET_NULL;
-		}
-		
-		int status;
-		
-		// Set socket options
-		
-		status = fcntl(socketFD, F_SETFL, O_NONBLOCK);
-		if (status == -1)
-		{
-			NSString *reason = @"Error enabling non-blocking IO on socket (fcntl)";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		int reuseOn = 1;
-		status = setsockopt(socketFD, SOL_SOCKET, SO_REUSEADDR, &reuseOn, sizeof(reuseOn));
-		if (status == -1)
-		{
-			NSString *reason = @"Error enabling address reuse (setsockopt)";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		// Bind socket
-		
-		status = bind(socketFD, (const struct sockaddr *)[interfaceAddr bytes], (socklen_t)[interfaceAddr length]);
-		if (status == -1)
-		{
-			NSString *reason = @"Error in bind() function";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		// Listen
-		
-		status = listen(socketFD, 1024);
-		if (status == -1)
-		{
-			NSString *reason = @"Error in listen() function";
-			err = [self errnoErrorWithReason:reason];
-			
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-			return SOCKET_NULL;
-		}
-		
-		return socketFD;
-	};
-	
-	// Create dispatch block and run on socketQueue
-	
-	dispatch_block_t block = ^{ @autoreleasepool {
-		
-		if (delegate == nil) // Must have delegate set
-		{
-			NSString *msg = @"Attempting to accept without a delegate. Set a delegate first.";
-			err = [self badConfigError:msg];
-			
-			return_from_block;
-		}
-		
-		if (delegateQueue == NULL) // Must have delegate queue set
-		{
-			NSString *msg = @"Attempting to accept without a delegate queue. Set a delegate queue first.";
-			err = [self badConfigError:msg];
-			
-			return_from_block;
-		}
-		
-		if (![self isDisconnected]) // Must be disconnected
-		{
-			NSString *msg = @"Attempting to accept while connected or accepting connections. Disconnect first.";
-			err = [self badConfigError:msg];
-			
-			return_from_block;
-		}
-		
-		// Clear queues (spurious read/write requests post disconnect)
-		[readQueue removeAllObjects];
-		[writeQueue removeAllObjects];
-		
-		// Remove a previous socket
-		
-		NSError *error = nil;
-		NSFileManager *fileManager = [NSFileManager defaultManager];
-		if ([fileManager fileExistsAtPath:url.path]) {
-			if (![[NSFileManager defaultManager] removeItemAtURL:url error:&error]) {
-				NSString *msg = @"Could not remove previous unix domain socket at given url.";
-				err = [self otherError:msg];
-				
-				return_from_block;
-			}
-		}
-		
-		// Resolve interface from description
-		
-		NSData *interface = [self getInterfaceAddressFromUrl:url];
-		
-		if (interface == nil)
-		{
-			NSString *msg = @"Invalid unix domain url. Specify a valid file url that does not exist (e.g. \"file:///tmp/socket\")";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		// Create sockets, configure, bind, and listen
-		
-		LogVerbose(@"Creating unix domain socket");
-		socketUN = createSocket(AF_UNIX, interface);
-		
-		if (socketUN == SOCKET_NULL)
-		{
-			return_from_block;
-		}
-		
-		socketUrl = url;
-		
-		// Create accept sources
-		
-		acceptUNSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socketUN, 0, socketQueue);
-		
-		int socketFD = socketUN;
-		dispatch_source_t acceptSource = acceptUNSource;
-		
-		dispatch_source_set_event_handler(acceptUNSource, ^{ @autoreleasepool {
-			
-			LogVerbose(@"eventUNBlock");
-			
-			unsigned long i = 0;
-			unsigned long numPendingConnections = dispatch_source_get_data(acceptSource);
-			
-			LogVerbose(@"numPendingConnections: %lu", numPendingConnections);
-			
-			while ([self doAccept:socketFD] && (++i < numPendingConnections));
-		}});
-		
-		dispatch_source_set_cancel_handler(acceptUNSource, ^{
-			
-#if NEEDS_DISPATCH_RETAIN_RELEASE
-			LogVerbose(@"dispatch_release(accept4Source)");
-			dispatch_release(acceptSource);
-#endif
-			
-			LogVerbose(@"close(socket4FD)");
-			close(socketFD);
-		});
-		
-		LogVerbose(@"dispatch_resume(accept4Source)");
-		dispatch_resume(acceptUNSource);
-		
-		flags |= kSocketStarted;
-		
-		result = YES;
-	}};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	if (result == NO)
-	{
-		LogInfo(@"Error in accept: %@", err);
-		
-		if (errPtr)
-			*errPtr = err;
-	}
-	
-	return result;	
-}
-
-- (BOOL)doAccept:(int)parentSocketFD
-{
-	LogTrace();
-	
-	int socketType;
-	int childSocketFD;
-	NSData *childSocketAddress;
-	
-	if (parentSocketFD == socket4FD)
-	{
-		socketType = 0;
-		
-		struct sockaddr_in addr;
-		socklen_t addrLen = sizeof(addr);
-		
-		childSocketFD = accept(parentSocketFD, (struct sockaddr *)&addr, &addrLen);
-		
-		if (childSocketFD == -1)
-		{
-			LogWarn(@"Accept failed with error: %@", [self errnoError]);
-			return NO;
-		}
-		
-		childSocketAddress = [NSData dataWithBytes:&addr length:addrLen];
-	}
-	else if (parentSocketFD == socket6FD)
-	{
-		socketType = 1;
-		
-		struct sockaddr_in6 addr;
-		socklen_t addrLen = sizeof(addr);
-		
-		childSocketFD = accept(parentSocketFD, (struct sockaddr *)&addr, &addrLen);
-		
-		if (childSocketFD == -1)
-		{
-			LogWarn(@"Accept failed with error: %@", [self errnoError]);
-			return NO;
-		}
-		
-		childSocketAddress = [NSData dataWithBytes:&addr length:addrLen];
-	}
-	else // if (parentSocketFD == socketUN)
-	{
-		socketType = 2;
-		
-		struct sockaddr_un addr;
-		socklen_t addrLen = sizeof(addr);
-		
-		childSocketFD = accept(parentSocketFD, (struct sockaddr *)&addr, &addrLen);
-		
-		if (childSocketFD == -1)
-		{
-			LogWarn(@"Accept failed with error: %@", [self errnoError]);
-			return NO;
-		}
-		
-		childSocketAddress = [NSData dataWithBytes:&addr length:addrLen];
-	}
-	
-	// Enable non-blocking IO on the socket
-	
-	int result = fcntl(childSocketFD, F_SETFL, O_NONBLOCK);
-	if (result == -1)
-	{
-		LogWarn(@"Error enabling non-blocking IO on accepted socket (fcntl)");
-		return NO;
-	}
-	
-	// Prevent SIGPIPE signals
-	
-	int nosigpipe = 1;
-	setsockopt(childSocketFD, SOL_SOCKET, SO_NOSIGPIPE, &nosigpipe, sizeof(nosigpipe));
-	
-	// Notify delegate
-	
-	if (delegateQueue)
-	{
-		__strong id theDelegate = delegate;
-		
-		dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-			// Query delegate for custom socket queue
-			
-			dispatch_queue_t childSocketQueue = NULL;
-			
-			if ([theDelegate respondsToSelector:@selector(newSocketQueueForConnectionFromAddress:onSocket:)])
-			{
-				childSocketQueue = [theDelegate newSocketQueueForConnectionFromAddress:childSocketAddress
-				                                                              onSocket:self];
-			}
-			
-			// Create GCDAsyncSocket instance for accepted socket
-			
-			GCDAsyncSocket *acceptedSocket = [[[self class] alloc] initWithDelegate:theDelegate
-																	  delegateQueue:delegateQueue
-																		socketQueue:childSocketQueue];
-			
-			if (socketType == 0)
-				acceptedSocket->socket4FD = childSocketFD;
-			else if (socketType == 1)
-				acceptedSocket->socket6FD = childSocketFD;
-			else
-				acceptedSocket->socketUN = childSocketFD;
-			
-			acceptedSocket->flags = (kSocketStarted | kConnected);
-			
-			// Setup read and write sources for accepted socket
-			
-			dispatch_async(acceptedSocket->socketQueue, ^{ @autoreleasepool {
-				
-				[acceptedSocket setupReadAndWriteSourcesForNewlyConnectedSocket:childSocketFD];
-			}});
-			
-			// Notify delegate
-			
-			if ([theDelegate respondsToSelector:@selector(socket:didAcceptNewSocket:)])
-			{
-				[theDelegate socket:self didAcceptNewSocket:acceptedSocket];
-			}
-			
-			// Release the socket queue returned from the delegate (it was retained by acceptedSocket)
-			#if !OS_OBJECT_USE_OBJC
-			if (childSocketQueue) dispatch_release(childSocketQueue);
-			#endif
-			
-			// The accepted socket should have been retained by the delegate.
-			// Otherwise it gets properly released when exiting the block.
-		}});
-	}
-	
-	return YES;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Connecting
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/**
- * This method runs through the various checks required prior to a connection attempt.
- * It is shared between the connectToHost and connectToAddress methods.
- * 
-**/
-- (BOOL)preConnectWithInterface:(NSString *)interface error:(NSError **)errPtr
-{
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	if (delegate == nil) // Must have delegate set
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Attempting to connect without a delegate. Set a delegate first.";
-			*errPtr = [self badConfigError:msg];
-		}
-		return NO;
-	}
-	
-	if (delegateQueue == NULL) // Must have delegate queue set
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Attempting to connect without a delegate queue. Set a delegate queue first.";
-			*errPtr = [self badConfigError:msg];
-		}
-		return NO;
-	}
-	
-	if (![self isDisconnected]) // Must be disconnected
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Attempting to connect while connected or accepting connections. Disconnect first.";
-			*errPtr = [self badConfigError:msg];
-		}
-		return NO;
-	}
-	
-	BOOL isIPv4Disabled = (config & kIPv4Disabled) ? YES : NO;
-	BOOL isIPv6Disabled = (config & kIPv6Disabled) ? YES : NO;
-	
-	if (isIPv4Disabled && isIPv6Disabled) // Must have IPv4 or IPv6 enabled
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Both IPv4 and IPv6 have been disabled. Must enable at least one protocol first.";
-			*errPtr = [self badConfigError:msg];
-		}
-		return NO;
-	}
-	
-	if (interface)
-	{
-		NSMutableData *interface4 = nil;
-		NSMutableData *interface6 = nil;
-		
-		[self getInterfaceAddress4:&interface4 address6:&interface6 fromDescription:interface port:0];
-		
-		if ((interface4 == nil) && (interface6 == nil))
-		{
-			if (errPtr)
-			{
-				NSString *msg = @"Unknown interface. Specify valid interface by name (e.g. \"en1\") or IP address.";
-				*errPtr = [self badParamError:msg];
-			}
-			return NO;
-		}
-		
-		if (isIPv4Disabled && (interface6 == nil))
-		{
-			if (errPtr)
-			{
-				NSString *msg = @"IPv4 has been disabled and specified interface doesn't support IPv6.";
-				*errPtr = [self badParamError:msg];
-			}
-			return NO;
-		}
-		
-		if (isIPv6Disabled && (interface4 == nil))
-		{
-			if (errPtr)
-			{
-				NSString *msg = @"IPv6 has been disabled and specified interface doesn't support IPv4.";
-				*errPtr = [self badParamError:msg];
-			}
-			return NO;
-		}
-		
-		connectInterface4 = interface4;
-		connectInterface6 = interface6;
-	}
-	
-	// Clear queues (spurious read/write requests post disconnect)
-	[readQueue removeAllObjects];
-	[writeQueue removeAllObjects];
-	
-	return YES;
-}
-
-- (BOOL)preConnectWithUrl:(NSURL *)url error:(NSError **)errPtr
-{
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	if (delegate == nil) // Must have delegate set
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Attempting to connect without a delegate. Set a delegate first.";
-			*errPtr = [self badConfigError:msg];
-		}
-		return NO;
-	}
-	
-	if (delegateQueue == NULL) // Must have delegate queue set
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Attempting to connect without a delegate queue. Set a delegate queue first.";
-			*errPtr = [self badConfigError:msg];
-		}
-		return NO;
-	}
-	
-	if (![self isDisconnected]) // Must be disconnected
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Attempting to connect while connected or accepting connections. Disconnect first.";
-			*errPtr = [self badConfigError:msg];
-		}
-		return NO;
-	}
-	
-	NSData *interface = [self getInterfaceAddressFromUrl:url];
-	
-	if (interface == nil)
-	{
-		if (errPtr)
-		{
-			NSString *msg = @"Unknown interface. Specify valid interface by name (e.g. \"en1\") or IP address.";
-			*errPtr = [self badParamError:msg];
-		}
-		return NO;
-	}
-	
-	connectInterfaceUN = interface;
-	
-	// Clear queues (spurious read/write requests post disconnect)
-	[readQueue removeAllObjects];
-	[writeQueue removeAllObjects];
-	
-	return YES;
-}
-
-- (BOOL)connectToHost:(NSString*)host onPort:(uint16_t)port error:(NSError **)errPtr
-{
-	return [self connectToHost:host onPort:port withTimeout:-1 error:errPtr];
-}
-
-- (BOOL)connectToHost:(NSString *)host
-               onPort:(uint16_t)port
-          withTimeout:(NSTimeInterval)timeout
-                error:(NSError **)errPtr
-{
-	return [self connectToHost:host onPort:port viaInterface:nil withTimeout:timeout error:errPtr];
-}
-
-- (BOOL)connectToHost:(NSString *)inHost
-               onPort:(uint16_t)port
-         viaInterface:(NSString *)inInterface
-          withTimeout:(NSTimeInterval)timeout
-                error:(NSError **)errPtr
-{
-	LogTrace();
-	
-	// Just in case immutable objects were passed
-	NSString *host = [inHost copy];
-	NSString *interface = [inInterface copy];
-	
-	__block BOOL result = NO;
-	__block NSError *preConnectErr = nil;
-	
-	dispatch_block_t block = ^{ @autoreleasepool {
-		
-		// Check for problems with host parameter
-		
-		if ([host length] == 0)
-		{
-			NSString *msg = @"Invalid host parameter (nil or \"\"). Should be a domain name or IP address string.";
-			preConnectErr = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		// Run through standard pre-connect checks
-		
-		if (![self preConnectWithInterface:interface error:&preConnectErr])
-		{
-			return_from_block;
-		}
-		
-		// We've made it past all the checks.
-		// It's time to start the connection process.
-		
-		flags |= kSocketStarted;
-		
-		LogVerbose(@"Dispatching DNS lookup...");
-		
-		// It's possible that the given host parameter is actually a NSMutableString.
-		// So we want to copy it now, within this block that will be executed synchronously.
-		// This way the asynchronous lookup block below doesn't have to worry about it changing.
-		
-		NSString *hostCpy = [host copy];
-		
-		int aStateIndex = stateIndex;
-		__weak GCDAsyncSocket *weakSelf = self;
-		
-		dispatch_queue_t globalConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
-		dispatch_async(globalConcurrentQueue, ^{ @autoreleasepool {
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-			
-			NSError *lookupErr = nil;
-			NSMutableArray *addresses = [[self class] lookupHost:hostCpy port:port error:&lookupErr];
-			
-			__strong GCDAsyncSocket *strongSelf = weakSelf;
-			if (strongSelf == nil) return_from_block;
-			
-			if (lookupErr)
-			{
-				dispatch_async(strongSelf->socketQueue, ^{ @autoreleasepool {
-					
-					[strongSelf lookup:aStateIndex didFail:lookupErr];
-				}});
-			}
-			else
-			{
-				NSData *address4 = nil;
-				NSData *address6 = nil;
-				
-				for (NSData *address in addresses)
-				{
-					if (!address4 && [[self class] isIPv4Address:address])
-					{
-						address4 = address;
-					}
-					else if (!address6 && [[self class] isIPv6Address:address])
-					{
-						address6 = address;
-					}
-				}
-				
-				dispatch_async(strongSelf->socketQueue, ^{ @autoreleasepool {
-					
-					[strongSelf lookup:aStateIndex didSucceedWithAddress4:address4 address6:address6];
-				}});
-			}
-			
-		#pragma clang diagnostic pop
-		}});
-		
-		[self startConnectTimeout:timeout];
-		
-		result = YES;
-	}};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	
-	if (errPtr) *errPtr = preConnectErr;
-	return result;
-}
-
-- (BOOL)connectToAddress:(NSData *)remoteAddr error:(NSError **)errPtr
-{
-	return [self connectToAddress:remoteAddr viaInterface:nil withTimeout:-1 error:errPtr];
-}
-
-- (BOOL)connectToAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr
-{
-	return [self connectToAddress:remoteAddr viaInterface:nil withTimeout:timeout error:errPtr];
-}
-
-- (BOOL)connectToAddress:(NSData *)inRemoteAddr
-            viaInterface:(NSString *)inInterface
-             withTimeout:(NSTimeInterval)timeout
-                   error:(NSError **)errPtr
-{
-	LogTrace();
-	
-	// Just in case immutable objects were passed
-	NSData *remoteAddr = [inRemoteAddr copy];
-	NSString *interface = [inInterface copy];
-	
-	__block BOOL result = NO;
-	__block NSError *err = nil;
-	
-	dispatch_block_t block = ^{ @autoreleasepool {
-		
-		// Check for problems with remoteAddr parameter
-		
-		NSData *address4 = nil;
-		NSData *address6 = nil;
-		
-		if ([remoteAddr length] >= sizeof(struct sockaddr))
-		{
-			const struct sockaddr *sockaddr = (const struct sockaddr *)[remoteAddr bytes];
-			
-			if (sockaddr->sa_family == AF_INET)
-			{
-				if ([remoteAddr length] == sizeof(struct sockaddr_in))
-				{
-					address4 = remoteAddr;
-				}
-			}
-			else if (sockaddr->sa_family == AF_INET6)
-			{
-				if ([remoteAddr length] == sizeof(struct sockaddr_in6))
-				{
-					address6 = remoteAddr;
-				}
-			}
-		}
-		
-		if ((address4 == nil) && (address6 == nil))
-		{
-			NSString *msg = @"A valid IPv4 or IPv6 address was not given";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		BOOL isIPv4Disabled = (config & kIPv4Disabled) ? YES : NO;
-		BOOL isIPv6Disabled = (config & kIPv6Disabled) ? YES : NO;
-		
-		if (isIPv4Disabled && (address4 != nil))
-		{
-			NSString *msg = @"IPv4 has been disabled and an IPv4 address was passed.";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		if (isIPv6Disabled && (address6 != nil))
-		{
-			NSString *msg = @"IPv6 has been disabled and an IPv6 address was passed.";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		// Run through standard pre-connect checks
-		
-		if (![self preConnectWithInterface:interface error:&err])
-		{
-			return_from_block;
-		}
-		
-		// We've made it past all the checks.
-		// It's time to start the connection process.
-		
-		if (![self connectWithAddress4:address4 address6:address6 error:&err])
-		{
-			return_from_block;
-		}
-		
-		flags |= kSocketStarted;
-		
-		[self startConnectTimeout:timeout];
-		
-		result = YES;
-	}};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	if (result == NO)
-	{
-		if (errPtr)
-			*errPtr = err;
-	}
-	
-	return result;
-}
-
-- (BOOL)connectToUrl:(NSURL *)url withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr;
-{
-	LogTrace();
-	
-	__block BOOL result = NO;
-	__block NSError *err = nil;
-	
-	dispatch_block_t block = ^{ @autoreleasepool {
-		
-		// Check for problems with host parameter
-		
-		if ([url.path length] == 0)
-		{
-			NSString *msg = @"Invalid unix domain socket url.";
-			err = [self badParamError:msg];
-			
-			return_from_block;
-		}
-		
-		// Run through standard pre-connect checks
-		
-		if (![self preConnectWithUrl:url error:&err])
-		{
-			return_from_block;
-		}
-		
-		// We've made it past all the checks.
-		// It's time to start the connection process.
-		
-		flags |= kSocketStarted;
-		
-		// Start the normal connection process
-		
-		NSError *connectError = nil;
-		if (![self connectWithAddressUN:connectInterfaceUN error:&connectError])
-		{
-			[self closeWithError:connectError];
-			
-			return_from_block;
-		}
-
-		[self startConnectTimeout:timeout];
-		
-		result = YES;
-	}};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	if (result == NO)
-	{
-		if (errPtr)
-			*errPtr = err;
-	}
-	
-	return result;
-}
-
-- (void)lookup:(int)aStateIndex didSucceedWithAddress4:(NSData *)address4 address6:(NSData *)address6
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	NSAssert(address4 || address6, @"Expected at least one valid address");
-	
-	if (aStateIndex != stateIndex)
-	{
-		LogInfo(@"Ignoring lookupDidSucceed, already disconnected");
-		
-		// The connect operation has been cancelled.
-		// That is, socket was disconnected, or connection has already timed out.
-		return;
-	}
-	
-	// Check for problems
-	
-	BOOL isIPv4Disabled = (config & kIPv4Disabled) ? YES : NO;
-	BOOL isIPv6Disabled = (config & kIPv6Disabled) ? YES : NO;
-	
-	if (isIPv4Disabled && (address6 == nil))
-	{
-		NSString *msg = @"IPv4 has been disabled and DNS lookup found no IPv6 address.";
-		
-		[self closeWithError:[self otherError:msg]];
-		return;
-	}
-	
-	if (isIPv6Disabled && (address4 == nil))
-	{
-		NSString *msg = @"IPv6 has been disabled and DNS lookup found no IPv4 address.";
-		
-		[self closeWithError:[self otherError:msg]];
-		return;
-	}
-	
-	// Start the normal connection process
-	
-	NSError *err = nil;
-	if (![self connectWithAddress4:address4 address6:address6 error:&err])
-	{
-		[self closeWithError:err];
-	}
-}
-
-/**
- * This method is called if the DNS lookup fails.
- * This method is executed on the socketQueue.
- * 
- * Since the DNS lookup executed synchronously on a global concurrent queue,
- * the original connection request may have already been cancelled or timed-out by the time this method is invoked.
- * The lookupIndex tells us whether the lookup is still valid or not.
-**/
-- (void)lookup:(int)aStateIndex didFail:(NSError *)error
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	
-	if (aStateIndex != stateIndex)
-	{
-		LogInfo(@"Ignoring lookup:didFail: - already disconnected");
-		
-		// The connect operation has been cancelled.
-		// That is, socket was disconnected, or connection has already timed out.
-		return;
-	}
-	
-	[self endConnectTimeout];
-	[self closeWithError:error];
-}
-
-- (BOOL)bindSocket:(int)socketFD toInterface:(NSData *)connectInterface error:(NSError **)errPtr
-{
-    // Bind the socket to the desired interface (if needed)
-    
-    if (connectInterface)
-    {
-        LogVerbose(@"Binding socket...");
-        
-        if ([[self class] portFromAddress:connectInterface] > 0)
-        {
-            // Since we're going to be binding to a specific port,
-            // we should turn on reuseaddr to allow us to override sockets in time_wait.
-            
-            int reuseOn = 1;
-            setsockopt(socketFD, SOL_SOCKET, SO_REUSEADDR, &reuseOn, sizeof(reuseOn));
-        }
-        
-        const struct sockaddr *interfaceAddr = (const struct sockaddr *)[connectInterface bytes];
-        
-        int result = bind(socketFD, interfaceAddr, (socklen_t)[connectInterface length]);
-        if (result != 0)
-        {
-            if (errPtr)
-                *errPtr = [self errnoErrorWithReason:@"Error in bind() function"];
-            
-            return NO;
-        }
-    }
-    
-    return YES;
-}
-
-- (int)createSocket:(int)family connectInterface:(NSData *)connectInterface errPtr:(NSError **)errPtr
-{
-    int socketFD = socket(family, SOCK_STREAM, 0);
-    
-    if (socketFD == SOCKET_NULL)
-    {
-        if (errPtr)
-            *errPtr = [self errnoErrorWithReason:@"Error in socket() function"];
-        
-        return socketFD;
-    }
-    
-    if (![self bindSocket:socketFD toInterface:connectInterface error:errPtr])
-    {
-        [self closeSocket:socketFD];
-        
-        return SOCKET_NULL;
-    }
-    
-    // Prevent SIGPIPE signals
-    
-    int nosigpipe = 1;
-    setsockopt(socketFD, SOL_SOCKET, SO_NOSIGPIPE, &nosigpipe, sizeof(nosigpipe));
-    
-    return socketFD;
-}
-
-- (void)connectSocket:(int)socketFD address:(NSData *)address stateIndex:(int)aStateIndex
-{
-    // If there already is a socket connected, we close socketFD and return
-    if (self.isConnected)
-    {
-        [self closeSocket:socketFD];
-        return;
-    }
-    
-    // Start the connection process in a background queue
-    
-    __weak GCDAsyncSocket *weakSelf = self;
-    
-    dispatch_queue_t globalConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
-    dispatch_async(globalConcurrentQueue, ^{
-#pragma clang diagnostic push
-#pragma clang diagnostic warning "-Wimplicit-retain-self"
-        
-        int result = connect(socketFD, (const struct sockaddr *)[address bytes], (socklen_t)[address length]);
-        
-        __strong GCDAsyncSocket *strongSelf = weakSelf;
-        if (strongSelf == nil) return_from_block;
-        
-        dispatch_async(strongSelf->socketQueue, ^{ @autoreleasepool {
-            
-            if (strongSelf.isConnected)
-            {
-                [strongSelf closeSocket:socketFD];
-                return_from_block;
-            }
-            
-            if (result == 0)
-            {
-                [self closeUnusedSocket:socketFD];
-                
-                [strongSelf didConnect:aStateIndex];
-            }
-            else
-            {
-                [strongSelf closeSocket:socketFD];
-                
-                // If there are no more sockets trying to connect, we inform the error to the delegate
-                if (strongSelf.socket4FD == SOCKET_NULL && strongSelf.socket6FD == SOCKET_NULL)
-                {
-                    NSError *error = [strongSelf errnoErrorWithReason:@"Error in connect() function"];
-                    [strongSelf didNotConnect:aStateIndex error:error];
-                }
-            }
-        }});
-        
-#pragma clang diagnostic pop
-    });
-    
-    LogVerbose(@"Connecting...");
-}
-
-- (void)closeSocket:(int)socketFD
-{
-    if (socketFD != SOCKET_NULL &&
-        (socketFD == socket6FD || socketFD == socket4FD))
-    {
-        close(socketFD);
-        
-        if (socketFD == socket4FD)
-        {
-            LogVerbose(@"close(socket4FD)");
-            socket4FD = SOCKET_NULL;
-        }
-        else if (socketFD == socket6FD)
-        {
-            LogVerbose(@"close(socket6FD)");
-            socket6FD = SOCKET_NULL;
-        }
-    }
-}
-
-- (void)closeUnusedSocket:(int)usedSocketFD
-{
-    if (usedSocketFD != socket4FD)
-    {
-        [self closeSocket:socket4FD];
-    }
-    else if (usedSocketFD != socket6FD)
-    {
-        [self closeSocket:socket6FD];
-    }
-}
-
-- (BOOL)connectWithAddress4:(NSData *)address4 address6:(NSData *)address6 error:(NSError **)errPtr
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	LogVerbose(@"IPv4: %@:%hu", [[self class] hostFromAddress:address4], [[self class] portFromAddress:address4]);
-	LogVerbose(@"IPv6: %@:%hu", [[self class] hostFromAddress:address6], [[self class] portFromAddress:address6]);
-	
-	// Determine socket type
-	
-	BOOL preferIPv6 = (config & kPreferIPv6) ? YES : NO;
-	
-	// Create and bind the sockets
-    
-    if (address4)
-    {
-        LogVerbose(@"Creating IPv4 socket");
-        
-        socket4FD = [self createSocket:AF_INET connectInterface:connectInterface4 errPtr:errPtr];
-    }
-    
-    if (address6)
-    {
-        LogVerbose(@"Creating IPv6 socket");
-        
-        socket6FD = [self createSocket:AF_INET6 connectInterface:connectInterface6 errPtr:errPtr];
-    }
-    
-    if (socket4FD == SOCKET_NULL && socket6FD == SOCKET_NULL)
-    {
-        return NO;
-    }
-	
-	int socketFD, alternateSocketFD;
-	NSData *address, *alternateAddress;
-	
-    if ((preferIPv6 && socket6FD != SOCKET_NULL) || socket4FD == SOCKET_NULL)
-    {
-        socketFD = socket6FD;
-        alternateSocketFD = socket4FD;
-        address = address6;
-        alternateAddress = address4;
-    }
-    else
-    {
-        socketFD = socket4FD;
-        alternateSocketFD = socket6FD;
-        address = address4;
-        alternateAddress = address6;
-    }
-
-    int aStateIndex = stateIndex;
-    
-    [self connectSocket:socketFD address:address stateIndex:aStateIndex];
-    
-    if (alternateAddress)
-    {
-        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(alternateAddressDelay * NSEC_PER_SEC)), socketQueue, ^{
-            [self connectSocket:alternateSocketFD address:alternateAddress stateIndex:aStateIndex];
-        });
-    }
-	
-	return YES;
-}
-
-- (BOOL)connectWithAddressUN:(NSData *)address error:(NSError **)errPtr
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	// Create the socket
-	
-	int socketFD;
-	
-	LogVerbose(@"Creating unix domain socket");
-	
-	socketUN = socket(AF_UNIX, SOCK_STREAM, 0);
-	
-	socketFD = socketUN;
-	
-	if (socketFD == SOCKET_NULL)
-	{
-		if (errPtr)
-			*errPtr = [self errnoErrorWithReason:@"Error in socket() function"];
-		
-		return NO;
-	}
-	
-	// Bind the socket to the desired interface (if needed)
-	
-	LogVerbose(@"Binding socket...");
-	
-	int reuseOn = 1;
-	setsockopt(socketFD, SOL_SOCKET, SO_REUSEADDR, &reuseOn, sizeof(reuseOn));
-
-//	const struct sockaddr *interfaceAddr = (const struct sockaddr *)[address bytes];
-//	
-//	int result = bind(socketFD, interfaceAddr, (socklen_t)[address length]);
-//	if (result != 0)
-//	{
-//		if (errPtr)
-//			*errPtr = [self errnoErrorWithReason:@"Error in bind() function"];
-//		
-//		return NO;
-//	}
-	
-	// Prevent SIGPIPE signals
-	
-	int nosigpipe = 1;
-	setsockopt(socketFD, SOL_SOCKET, SO_NOSIGPIPE, &nosigpipe, sizeof(nosigpipe));
-	
-	// Start the connection process in a background queue
-	
-	int aStateIndex = stateIndex;
-	
-	dispatch_queue_t globalConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
-	dispatch_async(globalConcurrentQueue, ^{
-		
-		const struct sockaddr *addr = (const struct sockaddr *)[address bytes];
-		int result = connect(socketFD, addr, addr->sa_len);
-		if (result == 0)
-		{
-			dispatch_async(socketQueue, ^{ @autoreleasepool {
-				
-				[self didConnect:aStateIndex];
-			}});
-		}
-		else
-		{
-			// TODO: Bad file descriptor
-			perror("connect");
-			NSError *error = [self errnoErrorWithReason:@"Error in connect() function"];
-			
-			dispatch_async(socketQueue, ^{ @autoreleasepool {
-				
-				[self didNotConnect:aStateIndex error:error];
-			}});
-		}
-	});
-	
-	LogVerbose(@"Connecting...");
-	
-	return YES;
-}
-
-- (void)didConnect:(int)aStateIndex
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	
-	if (aStateIndex != stateIndex)
-	{
-		LogInfo(@"Ignoring didConnect, already disconnected");
-		
-		// The connect operation has been cancelled.
-		// That is, socket was disconnected, or connection has already timed out.
-		return;
-	}
-	
-	flags |= kConnected;
-	
-	[self endConnectTimeout];
-	
-	#if TARGET_OS_IPHONE
-	// The endConnectTimeout method executed above incremented the stateIndex.
-	aStateIndex = stateIndex;
-	#endif
-	
-	// Setup read/write streams (as workaround for specific shortcomings in the iOS platform)
-	// 
-	// Note:
-	// There may be configuration options that must be set by the delegate before opening the streams.
-	// The primary example is the kCFStreamNetworkServiceTypeVoIP flag, which only works on an unopened stream.
-	// 
-	// Thus we wait until after the socket:didConnectToHost:port: delegate method has completed.
-	// This gives the delegate time to properly configure the streams if needed.
-	
-	dispatch_block_t SetupStreamsPart1 = ^{
-		#if TARGET_OS_IPHONE
-		
-		if (![self createReadAndWriteStream])
-		{
-			[self closeWithError:[self otherError:@"Error creating CFStreams"]];
-			return;
-		}
-		
-		if (![self registerForStreamCallbacksIncludingReadWrite:NO])
-		{
-			[self closeWithError:[self otherError:@"Error in CFStreamSetClient"]];
-			return;
-		}
-		
-		#endif
-	};
-	dispatch_block_t SetupStreamsPart2 = ^{
-		#if TARGET_OS_IPHONE
-		
-		if (aStateIndex != stateIndex)
-		{
-			// The socket has been disconnected.
-			return;
-		}
-		
-		if (![self addStreamsToRunLoop])
-		{
-			[self closeWithError:[self otherError:@"Error in CFStreamScheduleWithRunLoop"]];
-			return;
-		}
-		
-		if (![self openStreams])
-		{
-			[self closeWithError:[self otherError:@"Error creating CFStreams"]];
-			return;
-		}
-		
-		#endif
-	};
-	
-	// Notify delegate
-	
-	NSString *host = [self connectedHost];
-	uint16_t port = [self connectedPort];
-	NSURL *url = [self connectedUrl];
-	
-	__strong id theDelegate = delegate;
-
-	if (delegateQueue && host != nil && [theDelegate respondsToSelector:@selector(socket:didConnectToHost:port:)])
-	{
-		SetupStreamsPart1();
-		
-		dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-			[theDelegate socket:self didConnectToHost:host port:port];
-			
-			dispatch_async(socketQueue, ^{ @autoreleasepool {
-				
-				SetupStreamsPart2();
-			}});
-		}});
-	}
-	else if (delegateQueue && url != nil && [theDelegate respondsToSelector:@selector(socket:didConnectToUrl:)])
-	{
-		SetupStreamsPart1();
-		
-		dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-			[theDelegate socket:self didConnectToUrl:url];
-			
-			dispatch_async(socketQueue, ^{ @autoreleasepool {
-				
-				SetupStreamsPart2();
-			}});
-		}});
-	}
-	else
-	{
-		SetupStreamsPart1();
-		SetupStreamsPart2();
-	}
-		
-	// Get the connected socket
-	
-	int socketFD = (socket4FD != SOCKET_NULL) ? socket4FD : (socket6FD != SOCKET_NULL) ? socket6FD : socketUN;
-	
-	// Enable non-blocking IO on the socket
-	
-	int result = fcntl(socketFD, F_SETFL, O_NONBLOCK);
-	if (result == -1)
-	{
-		NSString *errMsg = @"Error enabling non-blocking IO on socket (fcntl)";
-		[self closeWithError:[self otherError:errMsg]];
-		
-		return;
-	}
-	
-	// Setup our read/write sources
-	
-	[self setupReadAndWriteSourcesForNewlyConnectedSocket:socketFD];
-	
-	// Dequeue any pending read/write requests
-	
-	[self maybeDequeueRead];
-	[self maybeDequeueWrite];
-}
-
-- (void)didNotConnect:(int)aStateIndex error:(NSError *)error
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	
-	if (aStateIndex != stateIndex)
-	{
-		LogInfo(@"Ignoring didNotConnect, already disconnected");
-		
-		// The connect operation has been cancelled.
-		// That is, socket was disconnected, or connection has already timed out.
-		return;
-	}
-	
-	[self closeWithError:error];
-}
-
-- (void)startConnectTimeout:(NSTimeInterval)timeout
-{
-	if (timeout >= 0.0)
-	{
-		connectTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, socketQueue);
-		
-		__weak GCDAsyncSocket *weakSelf = self;
-		
-		dispatch_source_set_event_handler(connectTimer, ^{ @autoreleasepool {
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-		
-			__strong GCDAsyncSocket *strongSelf = weakSelf;
-			if (strongSelf == nil) return_from_block;
-			
-			[strongSelf doConnectTimeout];
-			
-		#pragma clang diagnostic pop
-		}});
-		
-		#if !OS_OBJECT_USE_OBJC
-		dispatch_source_t theConnectTimer = connectTimer;
-		dispatch_source_set_cancel_handler(connectTimer, ^{
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-			
-			LogVerbose(@"dispatch_release(connectTimer)");
-			dispatch_release(theConnectTimer);
-			
-		#pragma clang diagnostic pop
-		});
-		#endif
-		
-		dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC));
-		dispatch_source_set_timer(connectTimer, tt, DISPATCH_TIME_FOREVER, 0);
-		
-		dispatch_resume(connectTimer);
-	}
-}
-
-- (void)endConnectTimeout
-{
-	LogTrace();
-	
-	if (connectTimer)
-	{
-		dispatch_source_cancel(connectTimer);
-		connectTimer = NULL;
-	}
-	
-	// Increment stateIndex.
-	// This will prevent us from processing results from any related background asynchronous operations.
-	// 
-	// Note: This should be called from close method even if connectTimer is NULL.
-	// This is because one might disconnect a socket prior to a successful connection which had no timeout.
-	
-	stateIndex++;
-	
-	if (connectInterface4)
-	{
-		connectInterface4 = nil;
-	}
-	if (connectInterface6)
-	{
-		connectInterface6 = nil;
-	}
-}
-
-- (void)doConnectTimeout
-{
-	LogTrace();
-	
-	[self endConnectTimeout];
-	[self closeWithError:[self connectTimeoutError]];
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Disconnecting
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (void)closeWithError:(NSError *)error
-{
-	LogTrace();
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	[self endConnectTimeout];
-	
-	if (currentRead != nil)  [self endCurrentRead];
-	if (currentWrite != nil) [self endCurrentWrite];
-	
-	[readQueue removeAllObjects];
-	[writeQueue removeAllObjects];
-	
-	[preBuffer reset];
-	
-	#if TARGET_OS_IPHONE
-	{
-		if (readStream || writeStream)
-		{
-			[self removeStreamsFromRunLoop];
-			
-			if (readStream)
-			{
-				CFReadStreamSetClient(readStream, kCFStreamEventNone, NULL, NULL);
-				CFReadStreamClose(readStream);
-				CFRelease(readStream);
-				readStream = NULL;
-			}
-			if (writeStream)
-			{
-				CFWriteStreamSetClient(writeStream, kCFStreamEventNone, NULL, NULL);
-				CFWriteStreamClose(writeStream);
-				CFRelease(writeStream);
-				writeStream = NULL;
-			}
-		}
-	}
-	#endif
-	
-	[sslPreBuffer reset];
-	sslErrCode = lastSSLHandshakeError = noErr;
-	
-	if (sslContext)
-	{
-		// Getting a linker error here about the SSLx() functions?
-		// You need to add the Security Framework to your application.
-		
-		SSLClose(sslContext);
-		
-		#if TARGET_OS_IPHONE || (__MAC_OS_X_VERSION_MIN_REQUIRED >= 1080)
-		CFRelease(sslContext);
-		#else
-		SSLDisposeContext(sslContext);
-		#endif
-		
-		sslContext = NULL;
-	}
-	
-	// For some crazy reason (in my opinion), cancelling a dispatch source doesn't
-	// invoke the cancel handler if the dispatch source is paused.
-	// So we have to unpause the source if needed.
-	// This allows the cancel handler to be run, which in turn releases the source and closes the socket.
-	
-	if (!accept4Source && !accept6Source && !acceptUNSource && !readSource && !writeSource)
-	{
-		LogVerbose(@"manually closing close");
-
-		if (socket4FD != SOCKET_NULL)
-		{
-			LogVerbose(@"close(socket4FD)");
-			close(socket4FD);
-			socket4FD = SOCKET_NULL;
-		}
-
-		if (socket6FD != SOCKET_NULL)
-		{
-			LogVerbose(@"close(socket6FD)");
-			close(socket6FD);
-			socket6FD = SOCKET_NULL;
-		}
-		
-		if (socketUN != SOCKET_NULL)
-		{
-			LogVerbose(@"close(socketUN)");
-			close(socketUN);
-			socketUN = SOCKET_NULL;
-			unlink(socketUrl.path.fileSystemRepresentation);
-			socketUrl = nil;
-		}
-	}
-	else
-	{
-		if (accept4Source)
-		{
-			LogVerbose(@"dispatch_source_cancel(accept4Source)");
-			dispatch_source_cancel(accept4Source);
-			
-			// We never suspend accept4Source
-			
-			accept4Source = NULL;
-		}
-		
-		if (accept6Source)
-		{
-			LogVerbose(@"dispatch_source_cancel(accept6Source)");
-			dispatch_source_cancel(accept6Source);
-			
-			// We never suspend accept6Source
-			
-			accept6Source = NULL;
-		}
-		
-		if (acceptUNSource)
-		{
-			LogVerbose(@"dispatch_source_cancel(acceptUNSource)");
-			dispatch_source_cancel(acceptUNSource);
-			
-			// We never suspend acceptUNSource
-			
-			acceptUNSource = NULL;
-		}
-	
-		if (readSource)
-		{
-			LogVerbose(@"dispatch_source_cancel(readSource)");
-			dispatch_source_cancel(readSource);
-			
-			[self resumeReadSource];
-			
-			readSource = NULL;
-		}
-		
-		if (writeSource)
-		{
-			LogVerbose(@"dispatch_source_cancel(writeSource)");
-			dispatch_source_cancel(writeSource);
-			
-			[self resumeWriteSource];
-			
-			writeSource = NULL;
-		}
-		
-		// The sockets will be closed by the cancel handlers of the corresponding source
-		
-		socket4FD = SOCKET_NULL;
-		socket6FD = SOCKET_NULL;
-		socketUN = SOCKET_NULL;
-	}
-	
-	// If the client has passed the connect/accept method, then the connection has at least begun.
-	// Notify delegate that it is now ending.
-	BOOL shouldCallDelegate = (flags & kSocketStarted) ? YES : NO;
-	BOOL isDeallocating = (flags & kDealloc) ? YES : NO;
-	
-	// Clear stored socket info and all flags (config remains as is)
-	socketFDBytesAvailable = 0;
-	flags = 0;
-	sslWriteCachedLength = 0;
-	
-	if (shouldCallDelegate)
-	{
-		__strong id theDelegate = delegate;
-		__strong id theSelf = isDeallocating ? nil : self;
-		
-		if (delegateQueue && [theDelegate respondsToSelector: @selector(socketDidDisconnect:withError:)])
-		{
-			dispatch_async(delegateQueue, ^{ @autoreleasepool {
-				
-				[theDelegate socketDidDisconnect:theSelf withError:error];
-			}});
-		}	
-	}
-}
-
-- (void)disconnect
-{
-	dispatch_block_t block = ^{ @autoreleasepool {
-		
-		if (flags & kSocketStarted)
-		{
-			[self closeWithError:nil];
-		}
-	}};
-	
-	// Synchronous disconnection, as documented in the header file
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-}
-
-- (void)disconnectAfterReading
-{
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		if (flags & kSocketStarted)
-		{
-			flags |= (kForbidReadsWrites | kDisconnectAfterReads);
-			[self maybeClose];
-		}
-	}});
-}
-
-- (void)disconnectAfterWriting
-{
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		if (flags & kSocketStarted)
-		{
-			flags |= (kForbidReadsWrites | kDisconnectAfterWrites);
-			[self maybeClose];
-		}
-	}});
-}
-
-- (void)disconnectAfterReadingAndWriting
-{
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		if (flags & kSocketStarted)
-		{
-			flags |= (kForbidReadsWrites | kDisconnectAfterReads | kDisconnectAfterWrites);
-			[self maybeClose];
-		}
-	}});
-}
-
-/**
- * Closes the socket if possible.
- * That is, if all writes have completed, and we're set to disconnect after writing,
- * or if all reads have completed, and we're set to disconnect after reading.
-**/
-- (void)maybeClose
-{
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	BOOL shouldClose = NO;
-	
-	if (flags & kDisconnectAfterReads)
-	{
-		if (([readQueue count] == 0) && (currentRead == nil))
-		{
-			if (flags & kDisconnectAfterWrites)
-			{
-				if (([writeQueue count] == 0) && (currentWrite == nil))
-				{
-					shouldClose = YES;
-				}
-			}
-			else
-			{
-				shouldClose = YES;
-			}
-		}
-	}
-	else if (flags & kDisconnectAfterWrites)
-	{
-		if (([writeQueue count] == 0) && (currentWrite == nil))
-		{
-			shouldClose = YES;
-		}
-	}
-	
-	if (shouldClose)
-	{
-		[self closeWithError:nil];
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Errors
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (NSError *)badConfigError:(NSString *)errMsg
-{
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketBadConfigError userInfo:userInfo];
-}
-
-- (NSError *)badParamError:(NSString *)errMsg
-{
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketBadParamError userInfo:userInfo];
-}
-
-+ (NSError *)gaiError:(int)gai_error
-{
-	NSString *errMsg = [NSString stringWithCString:gai_strerror(gai_error) encoding:NSASCIIStringEncoding];
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:@"kCFStreamErrorDomainNetDB" code:gai_error userInfo:userInfo];
-}
-
-- (NSError *)errnoErrorWithReason:(NSString *)reason
-{
-	NSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObjectsAndKeys:errMsg, NSLocalizedDescriptionKey,
-	                                                                    reason, NSLocalizedFailureReasonErrorKey, nil];
-	
-	return [NSError errorWithDomain:NSPOSIXErrorDomain code:errno userInfo:userInfo];
-}
-
-- (NSError *)errnoError
-{
-	NSString *errMsg = [NSString stringWithUTF8String:strerror(errno)];
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:NSPOSIXErrorDomain code:errno userInfo:userInfo];
-}
-
-- (NSError *)sslError:(OSStatus)ssl_error
-{
-	NSString *msg = @"Error code definition can be found in Apple's SecureTransport.h";
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:msg forKey:NSLocalizedRecoverySuggestionErrorKey];
-	
-	return [NSError errorWithDomain:@"kCFStreamErrorDomainSSL" code:ssl_error userInfo:userInfo];
-}
-
-- (NSError *)connectTimeoutError
-{
-	NSString *errMsg = NSLocalizedStringWithDefaultValue(@"GCDAsyncSocketConnectTimeoutError",
-	                                                     @"GCDAsyncSocket", [NSBundle mainBundle],
-	                                                     @"Attempt to connect to host timed out", nil);
-	
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketConnectTimeoutError userInfo:userInfo];
-}
-
-/**
- * Returns a standard AsyncSocket maxed out error.
-**/
-- (NSError *)readMaxedOutError
-{
-	NSString *errMsg = NSLocalizedStringWithDefaultValue(@"GCDAsyncSocketReadMaxedOutError",
-														 @"GCDAsyncSocket", [NSBundle mainBundle],
-														 @"Read operation reached set maximum length", nil);
-	
-	NSDictionary *info = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketReadMaxedOutError userInfo:info];
-}
-
-/**
- * Returns a standard AsyncSocket write timeout error.
-**/
-- (NSError *)readTimeoutError
-{
-	NSString *errMsg = NSLocalizedStringWithDefaultValue(@"GCDAsyncSocketReadTimeoutError",
-	                                                     @"GCDAsyncSocket", [NSBundle mainBundle],
-	                                                     @"Read operation timed out", nil);
-	
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketReadTimeoutError userInfo:userInfo];
-}
-
-/**
- * Returns a standard AsyncSocket write timeout error.
-**/
-- (NSError *)writeTimeoutError
-{
-	NSString *errMsg = NSLocalizedStringWithDefaultValue(@"GCDAsyncSocketWriteTimeoutError",
-	                                                     @"GCDAsyncSocket", [NSBundle mainBundle],
-	                                                     @"Write operation timed out", nil);
-	
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketWriteTimeoutError userInfo:userInfo];
-}
-
-- (NSError *)connectionClosedError
-{
-	NSString *errMsg = NSLocalizedStringWithDefaultValue(@"GCDAsyncSocketClosedError",
-	                                                     @"GCDAsyncSocket", [NSBundle mainBundle],
-	                                                     @"Socket closed by remote peer", nil);
-	
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketClosedError userInfo:userInfo];
-}
-
-- (NSError *)otherError:(NSString *)errMsg
-{
-	NSDictionary *userInfo = [NSDictionary dictionaryWithObject:errMsg forKey:NSLocalizedDescriptionKey];
-	
-	return [NSError errorWithDomain:GCDAsyncSocketErrorDomain code:GCDAsyncSocketOtherError userInfo:userInfo];
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Diagnostics
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (BOOL)isDisconnected
-{
-	__block BOOL result = NO;
-	
-	dispatch_block_t block = ^{
-		result = (flags & kSocketStarted) ? NO : YES;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	return result;
-}
-
-- (BOOL)isConnected
-{
-	__block BOOL result = NO;
-	
-	dispatch_block_t block = ^{
-		result = (flags & kConnected) ? YES : NO;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	return result;
-}
-
-- (NSString *)connectedHost
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		if (socket4FD != SOCKET_NULL)
-			return [self connectedHostFromSocket4:socket4FD];
-		if (socket6FD != SOCKET_NULL)
-			return [self connectedHostFromSocket6:socket6FD];
-		
-		return nil;
-	}
-	else
-	{
-		__block NSString *result = nil;
-		
-		dispatch_sync(socketQueue, ^{ @autoreleasepool {
-			
-			if (socket4FD != SOCKET_NULL)
-				result = [self connectedHostFromSocket4:socket4FD];
-			else if (socket6FD != SOCKET_NULL)
-				result = [self connectedHostFromSocket6:socket6FD];
-		}});
-		
-		return result;
-	}
-}
-
-- (uint16_t)connectedPort
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		if (socket4FD != SOCKET_NULL)
-			return [self connectedPortFromSocket4:socket4FD];
-		if (socket6FD != SOCKET_NULL)
-			return [self connectedPortFromSocket6:socket6FD];
-		
-		return 0;
-	}
-	else
-	{
-		__block uint16_t result = 0;
-		
-		dispatch_sync(socketQueue, ^{
-			// No need for autorelease pool
-			
-			if (socket4FD != SOCKET_NULL)
-				result = [self connectedPortFromSocket4:socket4FD];
-			else if (socket6FD != SOCKET_NULL)
-				result = [self connectedPortFromSocket6:socket6FD];
-		});
-		
-		return result;
-	}
-}
-
-- (NSURL *)connectedUrl
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		if (socketUN != SOCKET_NULL)
-			return [self connectedUrlFromSocketUN:socketUN];
-		
-		return nil;
-	}
-	else
-	{
-		__block NSURL *result = nil;
-		
-		dispatch_sync(socketQueue, ^{ @autoreleasepool {
-			
-			if (socketUN != SOCKET_NULL)
-				result = [self connectedUrlFromSocketUN:socketUN];
-		}});
-		
-		return result;
-	}
-}
-
-- (NSString *)localHost
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		if (socket4FD != SOCKET_NULL)
-			return [self localHostFromSocket4:socket4FD];
-		if (socket6FD != SOCKET_NULL)
-			return [self localHostFromSocket6:socket6FD];
-		
-		return nil;
-	}
-	else
-	{
-		__block NSString *result = nil;
-		
-		dispatch_sync(socketQueue, ^{ @autoreleasepool {
-			
-			if (socket4FD != SOCKET_NULL)
-				result = [self localHostFromSocket4:socket4FD];
-			else if (socket6FD != SOCKET_NULL)
-				result = [self localHostFromSocket6:socket6FD];
-		}});
-		
-		return result;
-	}
-}
-
-- (uint16_t)localPort
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		if (socket4FD != SOCKET_NULL)
-			return [self localPortFromSocket4:socket4FD];
-		if (socket6FD != SOCKET_NULL)
-			return [self localPortFromSocket6:socket6FD];
-		
-		return 0;
-	}
-	else
-	{
-		__block uint16_t result = 0;
-		
-		dispatch_sync(socketQueue, ^{
-			// No need for autorelease pool
-			
-			if (socket4FD != SOCKET_NULL)
-				result = [self localPortFromSocket4:socket4FD];
-			else if (socket6FD != SOCKET_NULL)
-				result = [self localPortFromSocket6:socket6FD];
-		});
-		
-		return result;
-	}
-}
-
-- (NSString *)connectedHost4
-{
-	if (socket4FD != SOCKET_NULL)
-		return [self connectedHostFromSocket4:socket4FD];
-	
-	return nil;
-}
-
-- (NSString *)connectedHost6
-{
-	if (socket6FD != SOCKET_NULL)
-		return [self connectedHostFromSocket6:socket6FD];
-	
-	return nil;
-}
-
-- (uint16_t)connectedPort4
-{
-	if (socket4FD != SOCKET_NULL)
-		return [self connectedPortFromSocket4:socket4FD];
-	
-	return 0;
-}
-
-- (uint16_t)connectedPort6
-{
-	if (socket6FD != SOCKET_NULL)
-		return [self connectedPortFromSocket6:socket6FD];
-	
-	return 0;
-}
-
-- (NSString *)localHost4
-{
-	if (socket4FD != SOCKET_NULL)
-		return [self localHostFromSocket4:socket4FD];
-	
-	return nil;
-}
-
-- (NSString *)localHost6
-{
-	if (socket6FD != SOCKET_NULL)
-		return [self localHostFromSocket6:socket6FD];
-	
-	return nil;
-}
-
-- (uint16_t)localPort4
-{
-	if (socket4FD != SOCKET_NULL)
-		return [self localPortFromSocket4:socket4FD];
-	
-	return 0;
-}
-
-- (uint16_t)localPort6
-{
-	if (socket6FD != SOCKET_NULL)
-		return [self localPortFromSocket6:socket6FD];
-	
-	return 0;
-}
-
-- (NSString *)connectedHostFromSocket4:(int)socketFD
-{
-	struct sockaddr_in sockaddr4;
-	socklen_t sockaddr4len = sizeof(sockaddr4);
-	
-	if (getpeername(socketFD, (struct sockaddr *)&sockaddr4, &sockaddr4len) < 0)
-	{
-		return nil;
-	}
-	return [[self class] hostFromSockaddr4:&sockaddr4];
-}
-
-- (NSString *)connectedHostFromSocket6:(int)socketFD
-{
-	struct sockaddr_in6 sockaddr6;
-	socklen_t sockaddr6len = sizeof(sockaddr6);
-	
-	if (getpeername(socketFD, (struct sockaddr *)&sockaddr6, &sockaddr6len) < 0)
-	{
-		return nil;
-	}
-	return [[self class] hostFromSockaddr6:&sockaddr6];
-}
-
-- (uint16_t)connectedPortFromSocket4:(int)socketFD
-{
-	struct sockaddr_in sockaddr4;
-	socklen_t sockaddr4len = sizeof(sockaddr4);
-	
-	if (getpeername(socketFD, (struct sockaddr *)&sockaddr4, &sockaddr4len) < 0)
-	{
-		return 0;
-	}
-	return [[self class] portFromSockaddr4:&sockaddr4];
-}
-
-- (uint16_t)connectedPortFromSocket6:(int)socketFD
-{
-	struct sockaddr_in6 sockaddr6;
-	socklen_t sockaddr6len = sizeof(sockaddr6);
-	
-	if (getpeername(socketFD, (struct sockaddr *)&sockaddr6, &sockaddr6len) < 0)
-	{
-		return 0;
-	}
-	return [[self class] portFromSockaddr6:&sockaddr6];
-}
-
-- (NSURL *)connectedUrlFromSocketUN:(int)socketFD
-{
-	struct sockaddr_un sockaddr;
-	socklen_t sockaddrlen = sizeof(sockaddr);
-	
-	if (getpeername(socketFD, (struct sockaddr *)&sockaddr, &sockaddrlen) < 0)
-	{
-		return 0;
-	}
-	return [[self class] urlFromSockaddrUN:&sockaddr];
-}
-
-- (NSString *)localHostFromSocket4:(int)socketFD
-{
-	struct sockaddr_in sockaddr4;
-	socklen_t sockaddr4len = sizeof(sockaddr4);
-	
-	if (getsockname(socketFD, (struct sockaddr *)&sockaddr4, &sockaddr4len) < 0)
-	{
-		return nil;
-	}
-	return [[self class] hostFromSockaddr4:&sockaddr4];
-}
-
-- (NSString *)localHostFromSocket6:(int)socketFD
-{
-	struct sockaddr_in6 sockaddr6;
-	socklen_t sockaddr6len = sizeof(sockaddr6);
-	
-	if (getsockname(socketFD, (struct sockaddr *)&sockaddr6, &sockaddr6len) < 0)
-	{
-		return nil;
-	}
-	return [[self class] hostFromSockaddr6:&sockaddr6];
-}
-
-- (uint16_t)localPortFromSocket4:(int)socketFD
-{
-	struct sockaddr_in sockaddr4;
-	socklen_t sockaddr4len = sizeof(sockaddr4);
-	
-	if (getsockname(socketFD, (struct sockaddr *)&sockaddr4, &sockaddr4len) < 0)
-	{
-		return 0;
-	}
-	return [[self class] portFromSockaddr4:&sockaddr4];
-}
-
-- (uint16_t)localPortFromSocket6:(int)socketFD
-{
-	struct sockaddr_in6 sockaddr6;
-	socklen_t sockaddr6len = sizeof(sockaddr6);
-	
-	if (getsockname(socketFD, (struct sockaddr *)&sockaddr6, &sockaddr6len) < 0)
-	{
-		return 0;
-	}
-	return [[self class] portFromSockaddr6:&sockaddr6];
-}
-
-- (NSData *)connectedAddress
-{
-	__block NSData *result = nil;
-	
-	dispatch_block_t block = ^{
-		if (socket4FD != SOCKET_NULL)
-		{
-			struct sockaddr_in sockaddr4;
-			socklen_t sockaddr4len = sizeof(sockaddr4);
-			
-			if (getpeername(socket4FD, (struct sockaddr *)&sockaddr4, &sockaddr4len) == 0)
-			{
-				result = [[NSData alloc] initWithBytes:&sockaddr4 length:sockaddr4len];
-			}
-		}
-		
-		if (socket6FD != SOCKET_NULL)
-		{
-			struct sockaddr_in6 sockaddr6;
-			socklen_t sockaddr6len = sizeof(sockaddr6);
-			
-			if (getpeername(socket6FD, (struct sockaddr *)&sockaddr6, &sockaddr6len) == 0)
-			{
-				result = [[NSData alloc] initWithBytes:&sockaddr6 length:sockaddr6len];
-			}
-		}
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	return result;
-}
-
-- (NSData *)localAddress
-{
-	__block NSData *result = nil;
-	
-	dispatch_block_t block = ^{
-		if (socket4FD != SOCKET_NULL)
-		{
-			struct sockaddr_in sockaddr4;
-			socklen_t sockaddr4len = sizeof(sockaddr4);
-			
-			if (getsockname(socket4FD, (struct sockaddr *)&sockaddr4, &sockaddr4len) == 0)
-			{
-				result = [[NSData alloc] initWithBytes:&sockaddr4 length:sockaddr4len];
-			}
-		}
-		
-		if (socket6FD != SOCKET_NULL)
-		{
-			struct sockaddr_in6 sockaddr6;
-			socklen_t sockaddr6len = sizeof(sockaddr6);
-			
-			if (getsockname(socket6FD, (struct sockaddr *)&sockaddr6, &sockaddr6len) == 0)
-			{
-				result = [[NSData alloc] initWithBytes:&sockaddr6 length:sockaddr6len];
-			}
-		}
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	return result;
-}
-
-- (BOOL)isIPv4
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return (socket4FD != SOCKET_NULL);
-	}
-	else
-	{
-		__block BOOL result = NO;
-		
-		dispatch_sync(socketQueue, ^{
-			result = (socket4FD != SOCKET_NULL);
-		});
-		
-		return result;
-	}
-}
-
-- (BOOL)isIPv6
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return (socket6FD != SOCKET_NULL);
-	}
-	else
-	{
-		__block BOOL result = NO;
-		
-		dispatch_sync(socketQueue, ^{
-			result = (socket6FD != SOCKET_NULL);
-		});
-		
-		return result;
-	}
-}
-
-- (BOOL)isSecure
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return (flags & kSocketSecure) ? YES : NO;
-	}
-	else
-	{
-		__block BOOL result;
-		
-		dispatch_sync(socketQueue, ^{
-			result = (flags & kSocketSecure) ? YES : NO;
-		});
-		
-		return result;
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Utilities
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/**
- * Finds the address of an interface description.
- * An inteface description may be an interface name (en0, en1, lo0) or corresponding IP (192.168.4.34).
- * 
- * The interface description may optionally contain a port number at the end, separated by a colon.
- * If a non-zero port parameter is provided, any port number in the interface description is ignored.
- * 
- * The returned value is a 'struct sockaddr' wrapped in an NSMutableData object.
-**/
-- (void)getInterfaceAddress4:(NSMutableData **)interfaceAddr4Ptr
-                    address6:(NSMutableData **)interfaceAddr6Ptr
-             fromDescription:(NSString *)interfaceDescription
-                        port:(uint16_t)port
-{
-	NSMutableData *addr4 = nil;
-	NSMutableData *addr6 = nil;
-	
-	NSString *interface = nil;
-	
-	NSArray *components = [interfaceDescription componentsSeparatedByString:@":"];
-	if ([components count] > 0)
-	{
-		NSString *temp = [components objectAtIndex:0];
-		if ([temp length] > 0)
-		{
-			interface = temp;
-		}
-	}
-	if ([components count] > 1 && port == 0)
-	{
-		long portL = strtol([[components objectAtIndex:1] UTF8String], NULL, 10);
-		
-		if (portL > 0 && portL <= UINT16_MAX)
-		{
-			port = (uint16_t)portL;
-		}
-	}
-	
-	if (interface == nil)
-	{
-		// ANY address
-		
-		struct sockaddr_in sockaddr4;
-		memset(&sockaddr4, 0, sizeof(sockaddr4));
-		
-		sockaddr4.sin_len         = sizeof(sockaddr4);
-		sockaddr4.sin_family      = AF_INET;
-		sockaddr4.sin_port        = htons(port);
-		sockaddr4.sin_addr.s_addr = htonl(INADDR_ANY);
-		
-		struct sockaddr_in6 sockaddr6;
-		memset(&sockaddr6, 0, sizeof(sockaddr6));
-		
-		sockaddr6.sin6_len       = sizeof(sockaddr6);
-		sockaddr6.sin6_family    = AF_INET6;
-		sockaddr6.sin6_port      = htons(port);
-		sockaddr6.sin6_addr      = in6addr_any;
-		
-		addr4 = [NSMutableData dataWithBytes:&sockaddr4 length:sizeof(sockaddr4)];
-		addr6 = [NSMutableData dataWithBytes:&sockaddr6 length:sizeof(sockaddr6)];
-	}
-	else if ([interface isEqualToString:@"localhost"] || [interface isEqualToString:@"loopback"])
-	{
-		// LOOPBACK address
-		
-		struct sockaddr_in sockaddr4;
-		memset(&sockaddr4, 0, sizeof(sockaddr4));
-		
-		sockaddr4.sin_len         = sizeof(sockaddr4);
-		sockaddr4.sin_family      = AF_INET;
-		sockaddr4.sin_port        = htons(port);
-		sockaddr4.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-		
-		struct sockaddr_in6 sockaddr6;
-		memset(&sockaddr6, 0, sizeof(sockaddr6));
-		
-		sockaddr6.sin6_len       = sizeof(sockaddr6);
-		sockaddr6.sin6_family    = AF_INET6;
-		sockaddr6.sin6_port      = htons(port);
-		sockaddr6.sin6_addr      = in6addr_loopback;
-		
-		addr4 = [NSMutableData dataWithBytes:&sockaddr4 length:sizeof(sockaddr4)];
-		addr6 = [NSMutableData dataWithBytes:&sockaddr6 length:sizeof(sockaddr6)];
-	}
-	else
-	{
-		const char *iface = [interface UTF8String];
-		
-		struct ifaddrs *addrs;
-		const struct ifaddrs *cursor;
-		
-		if ((getifaddrs(&addrs) == 0))
-		{
-			cursor = addrs;
-			while (cursor != NULL)
-			{
-				if ((addr4 == nil) && (cursor->ifa_addr->sa_family == AF_INET))
-				{
-					// IPv4
-					
-					struct sockaddr_in nativeAddr4;
-					memcpy(&nativeAddr4, cursor->ifa_addr, sizeof(nativeAddr4));
-					
-					if (strcmp(cursor->ifa_name, iface) == 0)
-					{
-						// Name match
-						
-						nativeAddr4.sin_port = htons(port);
-						
-						addr4 = [NSMutableData dataWithBytes:&nativeAddr4 length:sizeof(nativeAddr4)];
-					}
-					else
-					{
-						char ip[INET_ADDRSTRLEN];
-						
-						const char *conversion = inet_ntop(AF_INET, &nativeAddr4.sin_addr, ip, sizeof(ip));
-						
-						if ((conversion != NULL) && (strcmp(ip, iface) == 0))
-						{
-							// IP match
-							
-							nativeAddr4.sin_port = htons(port);
-							
-							addr4 = [NSMutableData dataWithBytes:&nativeAddr4 length:sizeof(nativeAddr4)];
-						}
-					}
-				}
-				else if ((addr6 == nil) && (cursor->ifa_addr->sa_family == AF_INET6))
-				{
-					// IPv6
-					
-					struct sockaddr_in6 nativeAddr6;
-					memcpy(&nativeAddr6, cursor->ifa_addr, sizeof(nativeAddr6));
-					
-					if (strcmp(cursor->ifa_name, iface) == 0)
-					{
-						// Name match
-						
-						nativeAddr6.sin6_port = htons(port);
-						
-						addr6 = [NSMutableData dataWithBytes:&nativeAddr6 length:sizeof(nativeAddr6)];
-					}
-					else
-					{
-						char ip[INET6_ADDRSTRLEN];
-						
-						const char *conversion = inet_ntop(AF_INET6, &nativeAddr6.sin6_addr, ip, sizeof(ip));
-						
-						if ((conversion != NULL) && (strcmp(ip, iface) == 0))
-						{
-							// IP match
-							
-							nativeAddr6.sin6_port = htons(port);
-							
-							addr6 = [NSMutableData dataWithBytes:&nativeAddr6 length:sizeof(nativeAddr6)];
-						}
-					}
-				}
-				
-				cursor = cursor->ifa_next;
-			}
-			
-			freeifaddrs(addrs);
-		}
-	}
-	
-	if (interfaceAddr4Ptr) *interfaceAddr4Ptr = addr4;
-	if (interfaceAddr6Ptr) *interfaceAddr6Ptr = addr6;
-}
-
-- (NSData *)getInterfaceAddressFromUrl:(NSURL *)url;
-{
-	NSString *path = url.path;
-	if (path.length == 0) {
-		return nil;
-	}
-	
-    struct sockaddr_un nativeAddr;
-    nativeAddr.sun_family = AF_UNIX;
-    strlcpy(nativeAddr.sun_path, path.fileSystemRepresentation, sizeof(nativeAddr.sun_path));
-    nativeAddr.sun_len = SUN_LEN(&nativeAddr);
-    NSData *interface = [NSData dataWithBytes:&nativeAddr length:sizeof(struct sockaddr_un)];
-	
-	return interface;
-}
-
-- (void)setupReadAndWriteSourcesForNewlyConnectedSocket:(int)socketFD
-{
-	readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socketFD, 0, socketQueue);
-	writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE, socketFD, 0, socketQueue);
-	
-	// Setup event handlers
-	
-	__weak GCDAsyncSocket *weakSelf = self;
-	
-	dispatch_source_set_event_handler(readSource, ^{ @autoreleasepool {
-	#pragma clang diagnostic push
-	#pragma clang diagnostic warning "-Wimplicit-retain-self"
-		
-		__strong GCDAsyncSocket *strongSelf = weakSelf;
-		if (strongSelf == nil) return_from_block;
-		
-		LogVerbose(@"readEventBlock");
-		
-		strongSelf->socketFDBytesAvailable = dispatch_source_get_data(strongSelf->readSource);
-		LogVerbose(@"socketFDBytesAvailable: %lu", strongSelf->socketFDBytesAvailable);
-		
-		if (strongSelf->socketFDBytesAvailable > 0)
-			[strongSelf doReadData];
-		else
-			[strongSelf doReadEOF];
-		
-	#pragma clang diagnostic pop
-	}});
-	
-	dispatch_source_set_event_handler(writeSource, ^{ @autoreleasepool {
-	#pragma clang diagnostic push
-	#pragma clang diagnostic warning "-Wimplicit-retain-self"
-		
-		__strong GCDAsyncSocket *strongSelf = weakSelf;
-		if (strongSelf == nil) return_from_block;
-		
-		LogVerbose(@"writeEventBlock");
-		
-		strongSelf->flags |= kSocketCanAcceptBytes;
-		[strongSelf doWriteData];
-		
-	#pragma clang diagnostic pop
-	}});
-	
-	// Setup cancel handlers
-	
-	__block int socketFDRefCount = 2;
-	
-	#if !OS_OBJECT_USE_OBJC
-	dispatch_source_t theReadSource = readSource;
-	dispatch_source_t theWriteSource = writeSource;
-	#endif
-	
-	dispatch_source_set_cancel_handler(readSource, ^{
-	#pragma clang diagnostic push
-	#pragma clang diagnostic warning "-Wimplicit-retain-self"
-		
-		LogVerbose(@"readCancelBlock");
-		
-		#if !OS_OBJECT_USE_OBJC
-		LogVerbose(@"dispatch_release(readSource)");
-		dispatch_release(theReadSource);
-		#endif
-		
-		if (--socketFDRefCount == 0)
-		{
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-		}
-		
-	#pragma clang diagnostic pop
-	});
-	
-	dispatch_source_set_cancel_handler(writeSource, ^{
-	#pragma clang diagnostic push
-	#pragma clang diagnostic warning "-Wimplicit-retain-self"
-		
-		LogVerbose(@"writeCancelBlock");
-		
-		#if !OS_OBJECT_USE_OBJC
-		LogVerbose(@"dispatch_release(writeSource)");
-		dispatch_release(theWriteSource);
-		#endif
-		
-		if (--socketFDRefCount == 0)
-		{
-			LogVerbose(@"close(socketFD)");
-			close(socketFD);
-		}
-		
-	#pragma clang diagnostic pop
-	});
-	
-	// We will not be able to read until data arrives.
-	// But we should be able to write immediately.
-	
-	socketFDBytesAvailable = 0;
-	flags &= ~kReadSourceSuspended;
-	
-	LogVerbose(@"dispatch_resume(readSource)");
-	dispatch_resume(readSource);
-	
-	flags |= kSocketCanAcceptBytes;
-	flags |= kWriteSourceSuspended;
-}
-
-- (BOOL)usingCFStreamForTLS
-{
-	#if TARGET_OS_IPHONE
-	
-	if ((flags & kSocketSecure) && (flags & kUsingCFStreamForTLS))
-	{
-		// The startTLS method was given the GCDAsyncSocketUseCFStreamForTLS flag.
-		
-		return YES;
-	}
-	
-	#endif
-	
-	return NO;
-}
-
-- (BOOL)usingSecureTransportForTLS
-{
-	// Invoking this method is equivalent to ![self usingCFStreamForTLS] (just more readable)
-	
-	#if TARGET_OS_IPHONE
-	
-	if ((flags & kSocketSecure) && (flags & kUsingCFStreamForTLS))
-	{
-		// The startTLS method was given the GCDAsyncSocketUseCFStreamForTLS flag.
-		
-		return NO;
-	}
-	
-	#endif
-	
-	return YES;
-}
-
-- (void)suspendReadSource
-{
-	if (!(flags & kReadSourceSuspended))
-	{
-		LogVerbose(@"dispatch_suspend(readSource)");
-		
-		dispatch_suspend(readSource);
-		flags |= kReadSourceSuspended;
-	}
-}
-
-- (void)resumeReadSource
-{
-	if (flags & kReadSourceSuspended)
-	{
-		LogVerbose(@"dispatch_resume(readSource)");
-		
-		dispatch_resume(readSource);
-		flags &= ~kReadSourceSuspended;
-	}
-}
-
-- (void)suspendWriteSource
-{
-	if (!(flags & kWriteSourceSuspended))
-	{
-		LogVerbose(@"dispatch_suspend(writeSource)");
-		
-		dispatch_suspend(writeSource);
-		flags |= kWriteSourceSuspended;
-	}
-}
-
-- (void)resumeWriteSource
-{
-	if (flags & kWriteSourceSuspended)
-	{
-		LogVerbose(@"dispatch_resume(writeSource)");
-		
-		dispatch_resume(writeSource);
-		flags &= ~kWriteSourceSuspended;
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Reading
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag
-{
-	[self readDataWithTimeout:timeout buffer:nil bufferOffset:0 maxLength:0 tag:tag];
-}
-
-- (void)readDataWithTimeout:(NSTimeInterval)timeout
-                     buffer:(NSMutableData *)buffer
-               bufferOffset:(NSUInteger)offset
-                        tag:(long)tag
-{
-	[self readDataWithTimeout:timeout buffer:buffer bufferOffset:offset maxLength:0 tag:tag];
-}
-
-- (void)readDataWithTimeout:(NSTimeInterval)timeout
-                     buffer:(NSMutableData *)buffer
-               bufferOffset:(NSUInteger)offset
-                  maxLength:(NSUInteger)length
-                        tag:(long)tag
-{
-	if (offset > [buffer length]) {
-		LogWarn(@"Cannot read: offset > [buffer length]");
-		return;
-	}
-	
-	GCDAsyncReadPacket *packet = [[GCDAsyncReadPacket alloc] initWithData:buffer
-	                                                          startOffset:offset
-	                                                            maxLength:length
-	                                                              timeout:timeout
-	                                                           readLength:0
-	                                                           terminator:nil
-	                                                                  tag:tag];
-	
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		LogTrace();
-		
-		if ((flags & kSocketStarted) && !(flags & kForbidReadsWrites))
-		{
-			[readQueue addObject:packet];
-			[self maybeDequeueRead];
-		}
-	}});
-	
-	// Do not rely on the block being run in order to release the packet,
-	// as the queue might get released without the block completing.
-}
-
-- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag
-{
-	[self readDataToLength:length withTimeout:timeout buffer:nil bufferOffset:0 tag:tag];
-}
-
-- (void)readDataToLength:(NSUInteger)length
-             withTimeout:(NSTimeInterval)timeout
-                  buffer:(NSMutableData *)buffer
-            bufferOffset:(NSUInteger)offset
-                     tag:(long)tag
-{
-	if (length == 0) {
-		LogWarn(@"Cannot read: length == 0");
-		return;
-	}
-	if (offset > [buffer length]) {
-		LogWarn(@"Cannot read: offset > [buffer length]");
-		return;
-	}
-	
-	GCDAsyncReadPacket *packet = [[GCDAsyncReadPacket alloc] initWithData:buffer
-	                                                          startOffset:offset
-	                                                            maxLength:0
-	                                                              timeout:timeout
-	                                                           readLength:length
-	                                                           terminator:nil
-	                                                                  tag:tag];
-	
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		LogTrace();
-		
-		if ((flags & kSocketStarted) && !(flags & kForbidReadsWrites))
-		{
-			[readQueue addObject:packet];
-			[self maybeDequeueRead];
-		}
-	}});
-	
-	// Do not rely on the block being run in order to release the packet,
-	// as the queue might get released without the block completing.
-}
-
-- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag
-{
-	[self readDataToData:data withTimeout:timeout buffer:nil bufferOffset:0 maxLength:0 tag:tag];
-}
-
-- (void)readDataToData:(NSData *)data
-           withTimeout:(NSTimeInterval)timeout
-                buffer:(NSMutableData *)buffer
-          bufferOffset:(NSUInteger)offset
-                   tag:(long)tag
-{
-	[self readDataToData:data withTimeout:timeout buffer:buffer bufferOffset:offset maxLength:0 tag:tag];
-}
-
-- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout maxLength:(NSUInteger)length tag:(long)tag
-{
-	[self readDataToData:data withTimeout:timeout buffer:nil bufferOffset:0 maxLength:length tag:tag];
-}
-
-- (void)readDataToData:(NSData *)data
-           withTimeout:(NSTimeInterval)timeout
-                buffer:(NSMutableData *)buffer
-          bufferOffset:(NSUInteger)offset
-             maxLength:(NSUInteger)maxLength
-                   tag:(long)tag
-{
-	if ([data length] == 0) {
-		LogWarn(@"Cannot read: [data length] == 0");
-		return;
-	}
-	if (offset > [buffer length]) {
-		LogWarn(@"Cannot read: offset > [buffer length]");
-		return;
-	}
-	if (maxLength > 0 && maxLength < [data length]) {
-		LogWarn(@"Cannot read: maxLength > 0 && maxLength < [data length]");
-		return;
-	}
-	
-	GCDAsyncReadPacket *packet = [[GCDAsyncReadPacket alloc] initWithData:buffer
-	                                                          startOffset:offset
-	                                                            maxLength:maxLength
-	                                                              timeout:timeout
-	                                                           readLength:0
-	                                                           terminator:data
-	                                                                  tag:tag];
-	
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		LogTrace();
-		
-		if ((flags & kSocketStarted) && !(flags & kForbidReadsWrites))
-		{
-			[readQueue addObject:packet];
-			[self maybeDequeueRead];
-		}
-	}});
-	
-	// Do not rely on the block being run in order to release the packet,
-	// as the queue might get released without the block completing.
-}
-
-- (float)progressOfReadReturningTag:(long *)tagPtr bytesDone:(NSUInteger *)donePtr total:(NSUInteger *)totalPtr
-{
-	__block float result = 0.0F;
-	
-	dispatch_block_t block = ^{
-		
-		if (!currentRead || ![currentRead isKindOfClass:[GCDAsyncReadPacket class]])
-		{
-			// We're not reading anything right now.
-			
-			if (tagPtr != NULL)   *tagPtr = 0;
-			if (donePtr != NULL)  *donePtr = 0;
-			if (totalPtr != NULL) *totalPtr = 0;
-			
-			result = NAN;
-		}
-		else
-		{
-			// It's only possible to know the progress of our read if we're reading to a certain length.
-			// If we're reading to data, we of course have no idea when the data will arrive.
-			// If we're reading to timeout, then we have no idea when the next chunk of data will arrive.
-			
-			NSUInteger done = currentRead->bytesDone;
-			NSUInteger total = currentRead->readLength;
-			
-			if (tagPtr != NULL)   *tagPtr = currentRead->tag;
-			if (donePtr != NULL)  *donePtr = done;
-			if (totalPtr != NULL) *totalPtr = total;
-			
-			if (total > 0)
-				result = (float)done / (float)total;
-			else
-				result = 1.0F;
-		}
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	return result;
-}
-
-/**
- * This method starts a new read, if needed.
- * 
- * It is called when:
- * - a user requests a read
- * - after a read request has finished (to handle the next request)
- * - immediately after the socket opens to handle any pending requests
- * 
- * This method also handles auto-disconnect post read/write completion.
-**/
-- (void)maybeDequeueRead
-{
-	LogTrace();
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	// If we're not currently processing a read AND we have an available read stream
-	if ((currentRead == nil) && (flags & kConnected))
-	{
-		if ([readQueue count] > 0)
-		{
-			// Dequeue the next object in the write queue
-			currentRead = [readQueue objectAtIndex:0];
-			[readQueue removeObjectAtIndex:0];
-			
-			
-			if ([currentRead isKindOfClass:[GCDAsyncSpecialPacket class]])
-			{
-				LogVerbose(@"Dequeued GCDAsyncSpecialPacket");
-				
-				// Attempt to start TLS
-				flags |= kStartingReadTLS;
-				
-				// This method won't do anything unless both kStartingReadTLS and kStartingWriteTLS are set
-				[self maybeStartTLS];
-			}
-			else
-			{
-				LogVerbose(@"Dequeued GCDAsyncReadPacket");
-				
-				// Setup read timer (if needed)
-				[self setupReadTimerWithTimeout:currentRead->timeout];
-				
-				// Immediately read, if possible
-				[self doReadData];
-			}
-		}
-		else if (flags & kDisconnectAfterReads)
-		{
-			if (flags & kDisconnectAfterWrites)
-			{
-				if (([writeQueue count] == 0) && (currentWrite == nil))
-				{
-					[self closeWithError:nil];
-				}
-			}
-			else
-			{
-				[self closeWithError:nil];
-			}
-		}
-		else if (flags & kSocketSecure)
-		{
-			[self flushSSLBuffers];
-			
-			// Edge case:
-			// 
-			// We just drained all data from the ssl buffers,
-			// and all known data from the socket (socketFDBytesAvailable).
-			// 
-			// If we didn't get any data from this process,
-			// then we may have reached the end of the TCP stream.
-			// 
-			// Be sure callbacks are enabled so we're notified about a disconnection.
-			
-			if ([preBuffer availableBytes] == 0)
-			{
-				if ([self usingCFStreamForTLS]) {
-					// Callbacks never disabled
-				}
-				else {
-					[self resumeReadSource];
-				}
-			}
-		}
-	}
-}
-
-- (void)flushSSLBuffers
-{
-	LogTrace();
-	
-	NSAssert((flags & kSocketSecure), @"Cannot flush ssl buffers on non-secure socket");
-	
-	if ([preBuffer availableBytes] > 0)
-	{
-		// Only flush the ssl buffers if the prebuffer is empty.
-		// This is to avoid growing the prebuffer inifinitely large.
-		
-		return;
-	}
-	
-	#if TARGET_OS_IPHONE
-	
-	if ([self usingCFStreamForTLS])
-	{
-		if ((flags & kSecureSocketHasBytesAvailable) && CFReadStreamHasBytesAvailable(readStream))
-		{
-			LogVerbose(@"%@ - Flushing ssl buffers into prebuffer...", THIS_METHOD);
-			
-			CFIndex defaultBytesToRead = (1024 * 4);
-			
-			[preBuffer ensureCapacityForWrite:defaultBytesToRead];
-			
-			uint8_t *buffer = [preBuffer writeBuffer];
-			
-			CFIndex result = CFReadStreamRead(readStream, buffer, defaultBytesToRead);
-			LogVerbose(@"%@ - CFReadStreamRead(): result = %i", THIS_METHOD, (int)result);
-			
-			if (result > 0)
-			{
-				[preBuffer didWrite:result];
-			}
-			
-			flags &= ~kSecureSocketHasBytesAvailable;
-		}
-		
-		return;
-	}
-	
-	#endif
-	
-	__block NSUInteger estimatedBytesAvailable = 0;
-	
-	dispatch_block_t updateEstimatedBytesAvailable = ^{
-		
-		// Figure out if there is any data available to be read
-		// 
-		// socketFDBytesAvailable        <- Number of encrypted bytes we haven't read from the bsd socket
-		// [sslPreBuffer availableBytes] <- Number of encrypted bytes we've buffered from bsd socket
-		// sslInternalBufSize            <- Number of decrypted bytes SecureTransport has buffered
-		// 
-		// We call the variable "estimated" because we don't know how many decrypted bytes we'll get
-		// from the encrypted bytes in the sslPreBuffer.
-		// However, we do know this is an upper bound on the estimation.
-		
-		estimatedBytesAvailable = socketFDBytesAvailable + [sslPreBuffer availableBytes];
-		
-		size_t sslInternalBufSize = 0;
-		SSLGetBufferedReadSize(sslContext, &sslInternalBufSize);
-		
-		estimatedBytesAvailable += sslInternalBufSize;
-	};
-	
-	updateEstimatedBytesAvailable();
-	
-	if (estimatedBytesAvailable > 0)
-	{
-		LogVerbose(@"%@ - Flushing ssl buffers into prebuffer...", THIS_METHOD);
-		
-		BOOL done = NO;
-		do
-		{
-			LogVerbose(@"%@ - estimatedBytesAvailable = %lu", THIS_METHOD, (unsigned long)estimatedBytesAvailable);
-			
-			// Make sure there's enough room in the prebuffer
-			
-			[preBuffer ensureCapacityForWrite:estimatedBytesAvailable];
-			
-			// Read data into prebuffer
-			
-			uint8_t *buffer = [preBuffer writeBuffer];
-			size_t bytesRead = 0;
-			
-			OSStatus result = SSLRead(sslContext, buffer, (size_t)estimatedBytesAvailable, &bytesRead);
-			LogVerbose(@"%@ - read from secure socket = %u", THIS_METHOD, (unsigned)bytesRead);
-			
-			if (bytesRead > 0)
-			{
-				[preBuffer didWrite:bytesRead];
-			}
-			
-			LogVerbose(@"%@ - prebuffer.length = %zu", THIS_METHOD, [preBuffer availableBytes]);
-			
-			if (result != noErr)
-			{
-				done = YES;
-			}
-			else
-			{
-				updateEstimatedBytesAvailable();
-			}
-			
-		} while (!done && estimatedBytesAvailable > 0);
-	}
-}
-
-- (void)doReadData
-{
-	LogTrace();
-	
-	// This method is called on the socketQueue.
-	// It might be called directly, or via the readSource when data is available to be read.
-	
-	if ((currentRead == nil) || (flags & kReadsPaused))
-	{
-		LogVerbose(@"No currentRead or kReadsPaused");
-		
-		// Unable to read at this time
-		
-		if (flags & kSocketSecure)
-		{
-			// Here's the situation:
-			// 
-			// We have an established secure connection.
-			// There may not be a currentRead, but there might be encrypted data sitting around for us.
-			// When the user does get around to issuing a read, that encrypted data will need to be decrypted.
-			// 
-			// So why make the user wait?
-			// We might as well get a head start on decrypting some data now.
-			// 
-			// The other reason we do this has to do with detecting a socket disconnection.
-			// The SSL/TLS protocol has it's own disconnection handshake.
-			// So when a secure socket is closed, a "goodbye" packet comes across the wire.
-			// We want to make sure we read the "goodbye" packet so we can properly detect the TCP disconnection.
-			
-			[self flushSSLBuffers];
-		}
-		
-		if ([self usingCFStreamForTLS])
-		{
-			// CFReadStream only fires once when there is available data.
-			// It won't fire again until we've invoked CFReadStreamRead.
-		}
-		else
-		{
-			// If the readSource is firing, we need to pause it
-			// or else it will continue to fire over and over again.
-			// 
-			// If the readSource is not firing,
-			// we want it to continue monitoring the socket.
-			
-			if (socketFDBytesAvailable > 0)
-			{
-				[self suspendReadSource];
-			}
-		}
-		return;
-	}
-	
-	BOOL hasBytesAvailable = NO;
-	unsigned long estimatedBytesAvailable = 0;
-	
-	if ([self usingCFStreamForTLS])
-	{
-		#if TARGET_OS_IPHONE
-		
-		// Requested CFStream, rather than SecureTransport, for TLS (via GCDAsyncSocketUseCFStreamForTLS)
-		
-		estimatedBytesAvailable = 0;
-		if ((flags & kSecureSocketHasBytesAvailable) && CFReadStreamHasBytesAvailable(readStream))
-			hasBytesAvailable = YES;
-		else
-			hasBytesAvailable = NO;
-		
-		#endif
-	}
-	else
-	{
-		estimatedBytesAvailable = socketFDBytesAvailable;
-		
-		if (flags & kSocketSecure)
-		{
-			// There are 2 buffers to be aware of here.
-			// 
-			// We are using SecureTransport, a TLS/SSL security layer which sits atop TCP.
-			// We issue a read to the SecureTranport API, which in turn issues a read to our SSLReadFunction.
-			// Our SSLReadFunction then reads from the BSD socket and returns the encrypted data to SecureTransport.
-			// SecureTransport then decrypts the data, and finally returns the decrypted data back to us.
-			// 
-			// The first buffer is one we create.
-			// SecureTransport often requests small amounts of data.
-			// This has to do with the encypted packets that are coming across the TCP stream.
-			// But it's non-optimal to do a bunch of small reads from the BSD socket.
-			// So our SSLReadFunction reads all available data from the socket (optimizing the sys call)
-			// and may store excess in the sslPreBuffer.
-			
-			estimatedBytesAvailable += [sslPreBuffer availableBytes];
-			
-			// The second buffer is within SecureTransport.
-			// As mentioned earlier, there are encrypted packets coming across the TCP stream.
-			// SecureTransport needs the entire packet to decrypt it.
-			// But if the entire packet produces X bytes of decrypted data,
-			// and we only asked SecureTransport for X/2 bytes of data,
-			// it must store the extra X/2 bytes of decrypted data for the next read.
-			// 
-			// The SSLGetBufferedReadSize function will tell us the size of this internal buffer.
-			// From the documentation:
-			// 
-			// "This function does not block or cause any low-level read operations to occur."
-			
-			size_t sslInternalBufSize = 0;
-			SSLGetBufferedReadSize(sslContext, &sslInternalBufSize);
-			
-			estimatedBytesAvailable += sslInternalBufSize;
-		}
-		
-		hasBytesAvailable = (estimatedBytesAvailable > 0);
-	}
-	
-	if ((hasBytesAvailable == NO) && ([preBuffer availableBytes] == 0))
-	{
-		LogVerbose(@"No data available to read...");
-		
-		// No data available to read.
-		
-		if (![self usingCFStreamForTLS])
-		{
-			// Need to wait for readSource to fire and notify us of
-			// available data in the socket's internal read buffer.
-			
-			[self resumeReadSource];
-		}
-		return;
-	}
-	
-	if (flags & kStartingReadTLS)
-	{
-		LogVerbose(@"Waiting for SSL/TLS handshake to complete");
-		
-		// The readQueue is waiting for SSL/TLS handshake to complete.
-		
-		if (flags & kStartingWriteTLS)
-		{
-			if ([self usingSecureTransportForTLS] && lastSSLHandshakeError == errSSLWouldBlock)
-			{
-				// We are in the process of a SSL Handshake.
-				// We were waiting for incoming data which has just arrived.
-				
-				[self ssl_continueSSLHandshake];
-			}
-		}
-		else
-		{
-			// We are still waiting for the writeQueue to drain and start the SSL/TLS process.
-			// We now know data is available to read.
-			
-			if (![self usingCFStreamForTLS])
-			{
-				// Suspend the read source or else it will continue to fire nonstop.
-				
-				[self suspendReadSource];
-			}
-		}
-		
-		return;
-	}
-	
-	BOOL done        = NO;  // Completed read operation
-	NSError *error   = nil; // Error occurred
-	
-	NSUInteger totalBytesReadForCurrentRead = 0;
-	
-	// 
-	// STEP 1 - READ FROM PREBUFFER
-	// 
-	
-	if ([preBuffer availableBytes] > 0)
-	{
-		// There are 3 types of read packets:
-		// 
-		// 1) Read all available data.
-		// 2) Read a specific length of data.
-		// 3) Read up to a particular terminator.
-		
-		NSUInteger bytesToCopy;
-		
-		if (currentRead->term != nil)
-		{
-			// Read type #3 - read up to a terminator
-			
-			bytesToCopy = [currentRead readLengthForTermWithPreBuffer:preBuffer found:&done];
-		}
-		else
-		{
-			// Read type #1 or #2
-			
-			bytesToCopy = [currentRead readLengthForNonTermWithHint:[preBuffer availableBytes]];
-		}
-		
-		// Make sure we have enough room in the buffer for our read.
-		
-		[currentRead ensureCapacityForAdditionalDataOfLength:bytesToCopy];
-		
-		// Copy bytes from prebuffer into packet buffer
-		
-		uint8_t *buffer = (uint8_t *)[currentRead->buffer mutableBytes] + currentRead->startOffset +
-		                                                                  currentRead->bytesDone;
-		
-		memcpy(buffer, [preBuffer readBuffer], bytesToCopy);
-		
-		// Remove the copied bytes from the preBuffer
-		[preBuffer didRead:bytesToCopy];
-		
-		LogVerbose(@"copied(%lu) preBufferLength(%zu)", (unsigned long)bytesToCopy, [preBuffer availableBytes]);
-		
-		// Update totals
-		
-		currentRead->bytesDone += bytesToCopy;
-		totalBytesReadForCurrentRead += bytesToCopy;
-		
-		// Check to see if the read operation is done
-		
-		if (currentRead->readLength > 0)
-		{
-			// Read type #2 - read a specific length of data
-			
-			done = (currentRead->bytesDone == currentRead->readLength);
-		}
-		else if (currentRead->term != nil)
-		{
-			// Read type #3 - read up to a terminator
-			
-			// Our 'done' variable was updated via the readLengthForTermWithPreBuffer:found: method
-			
-			if (!done && currentRead->maxLength > 0)
-			{
-				// We're not done and there's a set maxLength.
-				// Have we reached that maxLength yet?
-				
-				if (currentRead->bytesDone >= currentRead->maxLength)
-				{
-					error = [self readMaxedOutError];
-				}
-			}
-		}
-		else
-		{
-			// Read type #1 - read all available data
-			// 
-			// We're done as soon as
-			// - we've read all available data (in prebuffer and socket)
-			// - we've read the maxLength of read packet.
-			
-			done = ((currentRead->maxLength > 0) && (currentRead->bytesDone == currentRead->maxLength));
-		}
-		
-	}
-	
-	// 
-	// STEP 2 - READ FROM SOCKET
-	// 
-	
-	BOOL socketEOF = (flags & kSocketHasReadEOF) ? YES : NO;  // Nothing more to read via socket (end of file)
-	BOOL waiting   = !done && !error && !socketEOF && !hasBytesAvailable; // Ran out of data, waiting for more
-	
-	if (!done && !error && !socketEOF && hasBytesAvailable)
-	{
-		NSAssert(([preBuffer availableBytes] == 0), @"Invalid logic");
-		
-		BOOL readIntoPreBuffer = NO;
-		uint8_t *buffer = NULL;
-		size_t bytesRead = 0;
-		
-		if (flags & kSocketSecure)
-		{
-			if ([self usingCFStreamForTLS])
-			{
-				#if TARGET_OS_IPHONE
-				
-				// Using CFStream, rather than SecureTransport, for TLS
-				
-				NSUInteger defaultReadLength = (1024 * 32);
-				
-				NSUInteger bytesToRead = [currentRead optimalReadLengthWithDefault:defaultReadLength
-				                                                   shouldPreBuffer:&readIntoPreBuffer];
-				
-				// Make sure we have enough room in the buffer for our read.
-				//
-				// We are either reading directly into the currentRead->buffer,
-				// or we're reading into the temporary preBuffer.
-				
-				if (readIntoPreBuffer)
-				{
-					[preBuffer ensureCapacityForWrite:bytesToRead];
-					
-					buffer = [preBuffer writeBuffer];
-				}
-				else
-				{
-					[currentRead ensureCapacityForAdditionalDataOfLength:bytesToRead];
-					
-					buffer = (uint8_t *)[currentRead->buffer mutableBytes]
-					       + currentRead->startOffset
-					       + currentRead->bytesDone;
-				}
-				
-				// Read data into buffer
-				
-				CFIndex result = CFReadStreamRead(readStream, buffer, (CFIndex)bytesToRead);
-				LogVerbose(@"CFReadStreamRead(): result = %i", (int)result);
-				
-				if (result < 0)
-				{
-					error = (__bridge_transfer NSError *)CFReadStreamCopyError(readStream);
-				}
-				else if (result == 0)
-				{
-					socketEOF = YES;
-				}
-				else
-				{
-					waiting = YES;
-					bytesRead = (size_t)result;
-				}
-				
-				// We only know how many decrypted bytes were read.
-				// The actual number of bytes read was likely more due to the overhead of the encryption.
-				// So we reset our flag, and rely on the next callback to alert us of more data.
-				flags &= ~kSecureSocketHasBytesAvailable;
-				
-				#endif
-			}
-			else
-			{
-				// Using SecureTransport for TLS
-				//
-				// We know:
-				// - how many bytes are available on the socket
-				// - how many encrypted bytes are sitting in the sslPreBuffer
-				// - how many decypted bytes are sitting in the sslContext
-				//
-				// But we do NOT know:
-				// - how many encypted bytes are sitting in the sslContext
-				//
-				// So we play the regular game of using an upper bound instead.
-				
-				NSUInteger defaultReadLength = (1024 * 32);
-				
-				if (defaultReadLength < estimatedBytesAvailable) {
-					defaultReadLength = estimatedBytesAvailable + (1024 * 16);
-				}
-				
-				NSUInteger bytesToRead = [currentRead optimalReadLengthWithDefault:defaultReadLength
-				                                                   shouldPreBuffer:&readIntoPreBuffer];
-				
-				if (bytesToRead > SIZE_MAX) { // NSUInteger may be bigger than size_t
-					bytesToRead = SIZE_MAX;
-				}
-				
-				// Make sure we have enough room in the buffer for our read.
-				//
-				// We are either reading directly into the currentRead->buffer,
-				// or we're reading into the temporary preBuffer.
-				
-				if (readIntoPreBuffer)
-				{
-					[preBuffer ensureCapacityForWrite:bytesToRead];
-					
-					buffer = [preBuffer writeBuffer];
-				}
-				else
-				{
-					[currentRead ensureCapacityForAdditionalDataOfLength:bytesToRead];
-					
-					buffer = (uint8_t *)[currentRead->buffer mutableBytes]
-					       + currentRead->startOffset
-					       + currentRead->bytesDone;
-				}
-				
-				// The documentation from Apple states:
-				// 
-				//     "a read operation might return errSSLWouldBlock,
-				//      indicating that less data than requested was actually transferred"
-				// 
-				// However, starting around 10.7, the function will sometimes return noErr,
-				// even if it didn't read as much data as requested. So we need to watch out for that.
-				
-				OSStatus result;
-				do
-				{
-					void *loop_buffer = buffer + bytesRead;
-					size_t loop_bytesToRead = (size_t)bytesToRead - bytesRead;
-					size_t loop_bytesRead = 0;
-					
-					result = SSLRead(sslContext, loop_buffer, loop_bytesToRead, &loop_bytesRead);
-					LogVerbose(@"read from secure socket = %u", (unsigned)loop_bytesRead);
-					
-					bytesRead += loop_bytesRead;
-					
-				} while ((result == noErr) && (bytesRead < bytesToRead));
-				
-				
-				if (result != noErr)
-				{
-					if (result == errSSLWouldBlock)
-						waiting = YES;
-					else
-					{
-						if (result == errSSLClosedGraceful || result == errSSLClosedAbort)
-						{
-							// We've reached the end of the stream.
-							// Handle this the same way we would an EOF from the socket.
-							socketEOF = YES;
-							sslErrCode = result;
-						}
-						else
-						{
-							error = [self sslError:result];
-						}
-					}
-					// It's possible that bytesRead > 0, even if the result was errSSLWouldBlock.
-					// This happens when the SSLRead function is able to read some data,
-					// but not the entire amount we requested.
-					
-					if (bytesRead <= 0)
-					{
-						bytesRead = 0;
-					}
-				}
-				
-				// Do not modify socketFDBytesAvailable.
-				// It will be updated via the SSLReadFunction().
-			}
-		}
-		else
-		{
-			// Normal socket operation
-			
-			NSUInteger bytesToRead;
-			
-			// There are 3 types of read packets:
-			//
-			// 1) Read all available data.
-			// 2) Read a specific length of data.
-			// 3) Read up to a particular terminator.
-			
-			if (currentRead->term != nil)
-			{
-				// Read type #3 - read up to a terminator
-				
-				bytesToRead = [currentRead readLengthForTermWithHint:estimatedBytesAvailable
-				                                     shouldPreBuffer:&readIntoPreBuffer];
-			}
-			else
-			{
-				// Read type #1 or #2
-				
-				bytesToRead = [currentRead readLengthForNonTermWithHint:estimatedBytesAvailable];
-			}
-			
-			if (bytesToRead > SIZE_MAX) { // NSUInteger may be bigger than size_t (read param 3)
-				bytesToRead = SIZE_MAX;
-			}
-			
-			// Make sure we have enough room in the buffer for our read.
-			//
-			// We are either reading directly into the currentRead->buffer,
-			// or we're reading into the temporary preBuffer.
-			
-			if (readIntoPreBuffer)
-			{
-				[preBuffer ensureCapacityForWrite:bytesToRead];
-				
-				buffer = [preBuffer writeBuffer];
-			}
-			else
-			{
-				[currentRead ensureCapacityForAdditionalDataOfLength:bytesToRead];
-				
-				buffer = (uint8_t *)[currentRead->buffer mutableBytes]
-				       + currentRead->startOffset
-				       + currentRead->bytesDone;
-			}
-			
-			// Read data into buffer
-			
-			int socketFD = (socket4FD != SOCKET_NULL) ? socket4FD : (socket6FD != SOCKET_NULL) ? socket6FD : socketUN;
-			
-			ssize_t result = read(socketFD, buffer, (size_t)bytesToRead);
-			LogVerbose(@"read from socket = %i", (int)result);
-			
-			if (result < 0)
-			{
-				if (errno == EWOULDBLOCK)
-					waiting = YES;
-				else
-					error = [self errnoErrorWithReason:@"Error in read() function"];
-				
-				socketFDBytesAvailable = 0;
-			}
-			else if (result == 0)
-			{
-				socketEOF = YES;
-				socketFDBytesAvailable = 0;
-			}
-			else
-			{
-				bytesRead = result;
-				
-				if (bytesRead < bytesToRead)
-				{
-					// The read returned less data than requested.
-					// This means socketFDBytesAvailable was a bit off due to timing,
-					// because we read from the socket right when the readSource event was firing.
-					socketFDBytesAvailable = 0;
-				}
-				else
-				{
-					if (socketFDBytesAvailable <= bytesRead)
-						socketFDBytesAvailable = 0;
-					else
-						socketFDBytesAvailable -= bytesRead;
-				}
-				
-				if (socketFDBytesAvailable == 0)
-				{
-					waiting = YES;
-				}
-			}
-		}
-		
-		if (bytesRead > 0)
-		{
-			// Check to see if the read operation is done
-			
-			if (currentRead->readLength > 0)
-			{
-				// Read type #2 - read a specific length of data
-				// 
-				// Note: We should never be using a prebuffer when we're reading a specific length of data.
-				
-				NSAssert(readIntoPreBuffer == NO, @"Invalid logic");
-				
-				currentRead->bytesDone += bytesRead;
-				totalBytesReadForCurrentRead += bytesRead;
-				
-				done = (currentRead->bytesDone == currentRead->readLength);
-			}
-			else if (currentRead->term != nil)
-			{
-				// Read type #3 - read up to a terminator
-				
-				if (readIntoPreBuffer)
-				{
-					// We just read a big chunk of data into the preBuffer
-					
-					[preBuffer didWrite:bytesRead];
-					LogVerbose(@"read data into preBuffer - preBuffer.length = %zu", [preBuffer availableBytes]);
-					
-					// Search for the terminating sequence
-					
-					NSUInteger bytesToCopy = [currentRead readLengthForTermWithPreBuffer:preBuffer found:&done];
-					LogVerbose(@"copying %lu bytes from preBuffer", (unsigned long)bytesToCopy);
-					
-					// Ensure there's room on the read packet's buffer
-					
-					[currentRead ensureCapacityForAdditionalDataOfLength:bytesToCopy];
-					
-					// Copy bytes from prebuffer into read buffer
-					
-					uint8_t *readBuf = (uint8_t *)[currentRead->buffer mutableBytes] + currentRead->startOffset
-					                                                                 + currentRead->bytesDone;
-					
-					memcpy(readBuf, [preBuffer readBuffer], bytesToCopy);
-					
-					// Remove the copied bytes from the prebuffer
-					[preBuffer didRead:bytesToCopy];
-					LogVerbose(@"preBuffer.length = %zu", [preBuffer availableBytes]);
-					
-					// Update totals
-					currentRead->bytesDone += bytesToCopy;
-					totalBytesReadForCurrentRead += bytesToCopy;
-					
-					// Our 'done' variable was updated via the readLengthForTermWithPreBuffer:found: method above
-				}
-				else
-				{
-					// We just read a big chunk of data directly into the packet's buffer.
-					// We need to move any overflow into the prebuffer.
-					
-					NSInteger overflow = [currentRead searchForTermAfterPreBuffering:bytesRead];
-					
-					if (overflow == 0)
-					{
-						// Perfect match!
-						// Every byte we read stays in the read buffer,
-						// and the last byte we read was the last byte of the term.
-						
-						currentRead->bytesDone += bytesRead;
-						totalBytesReadForCurrentRead += bytesRead;
-						done = YES;
-					}
-					else if (overflow > 0)
-					{
-						// The term was found within the data that we read,
-						// and there are extra bytes that extend past the end of the term.
-						// We need to move these excess bytes out of the read packet and into the prebuffer.
-						
-						NSInteger underflow = bytesRead - overflow;
-						
-						// Copy excess data into preBuffer
-						
-						LogVerbose(@"copying %ld overflow bytes into preBuffer", (long)overflow);
-						[preBuffer ensureCapacityForWrite:overflow];
-						
-						uint8_t *overflowBuffer = buffer + underflow;
-						memcpy([preBuffer writeBuffer], overflowBuffer, overflow);
-						
-						[preBuffer didWrite:overflow];
-						LogVerbose(@"preBuffer.length = %zu", [preBuffer availableBytes]);
-						
-						// Note: The completeCurrentRead method will trim the buffer for us.
-						
-						currentRead->bytesDone += underflow;
-						totalBytesReadForCurrentRead += underflow;
-						done = YES;
-					}
-					else
-					{
-						// The term was not found within the data that we read.
-						
-						currentRead->bytesDone += bytesRead;
-						totalBytesReadForCurrentRead += bytesRead;
-						done = NO;
-					}
-				}
-				
-				if (!done && currentRead->maxLength > 0)
-				{
-					// We're not done and there's a set maxLength.
-					// Have we reached that maxLength yet?
-					
-					if (currentRead->bytesDone >= currentRead->maxLength)
-					{
-						error = [self readMaxedOutError];
-					}
-				}
-			}
-			else
-			{
-				// Read type #1 - read all available data
-				
-				if (readIntoPreBuffer)
-				{
-					// We just read a chunk of data into the preBuffer
-					
-					[preBuffer didWrite:bytesRead];
-					
-					// Now copy the data into the read packet.
-					// 
-					// Recall that we didn't read directly into the packet's buffer to avoid
-					// over-allocating memory since we had no clue how much data was available to be read.
-					// 
-					// Ensure there's room on the read packet's buffer
-					
-					[currentRead ensureCapacityForAdditionalDataOfLength:bytesRead];
-					
-					// Copy bytes from prebuffer into read buffer
-					
-					uint8_t *readBuf = (uint8_t *)[currentRead->buffer mutableBytes] + currentRead->startOffset
-					                                                                 + currentRead->bytesDone;
-					
-					memcpy(readBuf, [preBuffer readBuffer], bytesRead);
-					
-					// Remove the copied bytes from the prebuffer
-					[preBuffer didRead:bytesRead];
-					
-					// Update totals
-					currentRead->bytesDone += bytesRead;
-					totalBytesReadForCurrentRead += bytesRead;
-				}
-				else
-				{
-					currentRead->bytesDone += bytesRead;
-					totalBytesReadForCurrentRead += bytesRead;
-				}
-				
-				done = YES;
-			}
-			
-		} // if (bytesRead > 0)
-		
-	} // if (!done && !error && !socketEOF && hasBytesAvailable)
-	
-	
-	if (!done && currentRead->readLength == 0 && currentRead->term == nil)
-	{
-		// Read type #1 - read all available data
-		// 
-		// We might arrive here if we read data from the prebuffer but not from the socket.
-		
-		done = (totalBytesReadForCurrentRead > 0);
-	}
-	
-	// Check to see if we're done, or if we've made progress
-	
-	if (done)
-	{
-		[self completeCurrentRead];
-		
-		if (!error && (!socketEOF || [preBuffer availableBytes] > 0))
-		{
-			[self maybeDequeueRead];
-		}
-	}
-	else if (totalBytesReadForCurrentRead > 0)
-	{
-		// We're not done read type #2 or #3 yet, but we have read in some bytes
-
-		__strong id theDelegate = delegate;
-		
-		if (delegateQueue && [theDelegate respondsToSelector:@selector(socket:didReadPartialDataOfLength:tag:)])
-		{
-			long theReadTag = currentRead->tag;
-			
-			dispatch_async(delegateQueue, ^{ @autoreleasepool {
-				
-				[theDelegate socket:self didReadPartialDataOfLength:totalBytesReadForCurrentRead tag:theReadTag];
-			}});
-		}
-	}
-	
-	// Check for errors
-	
-	if (error)
-	{
-		[self closeWithError:error];
-	}
-	else if (socketEOF)
-	{
-		[self doReadEOF];
-	}
-	else if (waiting)
-	{
-		if (![self usingCFStreamForTLS])
-		{
-			// Monitor the socket for readability (if we're not already doing so)
-			[self resumeReadSource];
-		}
-	}
-	
-	// Do not add any code here without first adding return statements in the error cases above.
-}
-
-- (void)doReadEOF
-{
-	LogTrace();
-	
-	// This method may be called more than once.
-	// If the EOF is read while there is still data in the preBuffer,
-	// then this method may be called continually after invocations of doReadData to see if it's time to disconnect.
-	
-	flags |= kSocketHasReadEOF;
-	
-	if (flags & kSocketSecure)
-	{
-		// If the SSL layer has any buffered data, flush it into the preBuffer now.
-		
-		[self flushSSLBuffers];
-	}
-	
-	BOOL shouldDisconnect = NO;
-	NSError *error = nil;
-	
-	if ((flags & kStartingReadTLS) || (flags & kStartingWriteTLS))
-	{
-		// We received an EOF during or prior to startTLS.
-		// The SSL/TLS handshake is now impossible, so this is an unrecoverable situation.
-		
-		shouldDisconnect = YES;
-		
-		if ([self usingSecureTransportForTLS])
-		{
-			error = [self sslError:errSSLClosedAbort];
-		}
-	}
-	else if (flags & kReadStreamClosed)
-	{
-		// The preBuffer has already been drained.
-		// The config allows half-duplex connections.
-		// We've previously checked the socket, and it appeared writeable.
-		// So we marked the read stream as closed and notified the delegate.
-		// 
-		// As per the half-duplex contract, the socket will be closed when a write fails,
-		// or when the socket is manually closed.
-		
-		shouldDisconnect = NO;
-	}
-	else if ([preBuffer availableBytes] > 0)
-	{
-		LogVerbose(@"Socket reached EOF, but there is still data available in prebuffer");
-		
-		// Although we won't be able to read any more data from the socket,
-		// there is existing data that has been prebuffered that we can read.
-		
-		shouldDisconnect = NO;
-	}
-	else if (config & kAllowHalfDuplexConnection)
-	{
-		// We just received an EOF (end of file) from the socket's read stream.
-		// This means the remote end of the socket (the peer we're connected to)
-		// has explicitly stated that it will not be sending us any more data.
-		// 
-		// Query the socket to see if it is still writeable. (Perhaps the peer will continue reading data from us)
-		
-		int socketFD = (socket4FD != SOCKET_NULL) ? socket4FD : (socket6FD != SOCKET_NULL) ? socket6FD : socketUN;
-		
-		struct pollfd pfd[1];
-		pfd[0].fd = socketFD;
-		pfd[0].events = POLLOUT;
-		pfd[0].revents = 0;
-		
-		poll(pfd, 1, 0);
-		
-		if (pfd[0].revents & POLLOUT)
-		{
-			// Socket appears to still be writeable
-			
-			shouldDisconnect = NO;
-			flags |= kReadStreamClosed;
-			
-			// Notify the delegate that we're going half-duplex
-			
-			__strong id theDelegate = delegate;
-
-			if (delegateQueue && [theDelegate respondsToSelector:@selector(socketDidCloseReadStream:)])
-			{
-				dispatch_async(delegateQueue, ^{ @autoreleasepool {
-					
-					[theDelegate socketDidCloseReadStream:self];
-				}});
-			}
-		}
-		else
-		{
-			shouldDisconnect = YES;
-		}
-	}
-	else
-	{
-		shouldDisconnect = YES;
-	}
-	
-	
-	if (shouldDisconnect)
-	{
-		if (error == nil)
-		{
-			if ([self usingSecureTransportForTLS])
-			{
-				if (sslErrCode != noErr && sslErrCode != errSSLClosedGraceful)
-				{
-					error = [self sslError:sslErrCode];
-				}
-				else
-				{
-					error = [self connectionClosedError];
-				}
-			}
-			else
-			{
-				error = [self connectionClosedError];
-			}
-		}
-		[self closeWithError:error];
-	}
-	else
-	{
-		if (![self usingCFStreamForTLS])
-		{
-			// Suspend the read source (if needed)
-			
-			[self suspendReadSource];
-		}
-	}
-}
-
-- (void)completeCurrentRead
-{
-	LogTrace();
-	
-	NSAssert(currentRead, @"Trying to complete current read when there is no current read.");
-	
-	
-	NSData *result = nil;
-	
-	if (currentRead->bufferOwner)
-	{
-		// We created the buffer on behalf of the user.
-		// Trim our buffer to be the proper size.
-		[currentRead->buffer setLength:currentRead->bytesDone];
-		
-		result = currentRead->buffer;
-	}
-	else
-	{
-		// We did NOT create the buffer.
-		// The buffer is owned by the caller.
-		// Only trim the buffer if we had to increase its size.
-		
-		if ([currentRead->buffer length] > currentRead->originalBufferLength)
-		{
-			NSUInteger readSize = currentRead->startOffset + currentRead->bytesDone;
-			NSUInteger origSize = currentRead->originalBufferLength;
-			
-			NSUInteger buffSize = MAX(readSize, origSize);
-			
-			[currentRead->buffer setLength:buffSize];
-		}
-		
-		uint8_t *buffer = (uint8_t *)[currentRead->buffer mutableBytes] + currentRead->startOffset;
-		
-		result = [NSData dataWithBytesNoCopy:buffer length:currentRead->bytesDone freeWhenDone:NO];
-	}
-	
-	__strong id theDelegate = delegate;
-
-	if (delegateQueue && [theDelegate respondsToSelector:@selector(socket:didReadData:withTag:)])
-	{
-		GCDAsyncReadPacket *theRead = currentRead; // Ensure currentRead retained since result may not own buffer
-		
-		dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-			[theDelegate socket:self didReadData:result withTag:theRead->tag];
-		}});
-	}
-	
-	[self endCurrentRead];
-}
-
-- (void)endCurrentRead
-{
-	if (readTimer)
-	{
-		dispatch_source_cancel(readTimer);
-		readTimer = NULL;
-	}
-	
-	currentRead = nil;
-}
-
-- (void)setupReadTimerWithTimeout:(NSTimeInterval)timeout
-{
-	if (timeout >= 0.0)
-	{
-		readTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, socketQueue);
-		
-		__weak GCDAsyncSocket *weakSelf = self;
-		
-		dispatch_source_set_event_handler(readTimer, ^{ @autoreleasepool {
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-			
-			__strong GCDAsyncSocket *strongSelf = weakSelf;
-			if (strongSelf == nil) return_from_block;
-			
-			[strongSelf doReadTimeout];
-			
-		#pragma clang diagnostic pop
-		}});
-		
-		#if !OS_OBJECT_USE_OBJC
-		dispatch_source_t theReadTimer = readTimer;
-		dispatch_source_set_cancel_handler(readTimer, ^{
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-			
-			LogVerbose(@"dispatch_release(readTimer)");
-			dispatch_release(theReadTimer);
-			
-		#pragma clang diagnostic pop
-		});
-		#endif
-		
-		dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC));
-		
-		dispatch_source_set_timer(readTimer, tt, DISPATCH_TIME_FOREVER, 0);
-		dispatch_resume(readTimer);
-	}
-}
-
-- (void)doReadTimeout
-{
-	// This is a little bit tricky.
-	// Ideally we'd like to synchronously query the delegate about a timeout extension.
-	// But if we do so synchronously we risk a possible deadlock.
-	// So instead we have to do so asynchronously, and callback to ourselves from within the delegate block.
-	
-	flags |= kReadsPaused;
-	
-	__strong id theDelegate = delegate;
-
-	if (delegateQueue && [theDelegate respondsToSelector:@selector(socket:shouldTimeoutReadWithTag:elapsed:bytesDone:)])
-	{
-		GCDAsyncReadPacket *theRead = currentRead;
-		
-		dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-			NSTimeInterval timeoutExtension = 0.0;
-			
-			timeoutExtension = [theDelegate socket:self shouldTimeoutReadWithTag:theRead->tag
-			                                                             elapsed:theRead->timeout
-			                                                           bytesDone:theRead->bytesDone];
-			
-			dispatch_async(socketQueue, ^{ @autoreleasepool {
-				
-				[self doReadTimeoutWithExtension:timeoutExtension];
-			}});
-		}});
-	}
-	else
-	{
-		[self doReadTimeoutWithExtension:0.0];
-	}
-}
-
-- (void)doReadTimeoutWithExtension:(NSTimeInterval)timeoutExtension
-{
-	if (currentRead)
-	{
-		if (timeoutExtension > 0.0)
-		{
-			currentRead->timeout += timeoutExtension;
-			
-			// Reschedule the timer
-			dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeoutExtension * NSEC_PER_SEC));
-			dispatch_source_set_timer(readTimer, tt, DISPATCH_TIME_FOREVER, 0);
-			
-			// Unpause reads, and continue
-			flags &= ~kReadsPaused;
-			[self doReadData];
-		}
-		else
-		{
-			LogVerbose(@"ReadTimeout");
-			
-			[self closeWithError:[self readTimeoutError]];
-		}
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Writing
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag
-{
-	if ([data length] == 0) return;
-	
-	GCDAsyncWritePacket *packet = [[GCDAsyncWritePacket alloc] initWithData:data timeout:timeout tag:tag];
-	
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		LogTrace();
-		
-		if ((flags & kSocketStarted) && !(flags & kForbidReadsWrites))
-		{
-			[writeQueue addObject:packet];
-			[self maybeDequeueWrite];
-		}
-	}});
-	
-	// Do not rely on the block being run in order to release the packet,
-	// as the queue might get released without the block completing.
-}
-
-- (float)progressOfWriteReturningTag:(long *)tagPtr bytesDone:(NSUInteger *)donePtr total:(NSUInteger *)totalPtr
-{
-	__block float result = 0.0F;
-	
-	dispatch_block_t block = ^{
-		
-		if (!currentWrite || ![currentWrite isKindOfClass:[GCDAsyncWritePacket class]])
-		{
-			// We're not writing anything right now.
-			
-			if (tagPtr != NULL)   *tagPtr = 0;
-			if (donePtr != NULL)  *donePtr = 0;
-			if (totalPtr != NULL) *totalPtr = 0;
-			
-			result = NAN;
-		}
-		else
-		{
-			NSUInteger done = currentWrite->bytesDone;
-			NSUInteger total = [currentWrite->buffer length];
-			
-			if (tagPtr != NULL)   *tagPtr = currentWrite->tag;
-			if (donePtr != NULL)  *donePtr = done;
-			if (totalPtr != NULL) *totalPtr = total;
-			
-			result = (float)done / (float)total;
-		}
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-	
-	return result;
-}
-
-/**
- * Conditionally starts a new write.
- * 
- * It is called when:
- * - a user requests a write
- * - after a write request has finished (to handle the next request)
- * - immediately after the socket opens to handle any pending requests
- * 
- * This method also handles auto-disconnect post read/write completion.
-**/
-- (void)maybeDequeueWrite
-{
-	LogTrace();
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	
-	// If we're not currently processing a write AND we have an available write stream
-	if ((currentWrite == nil) && (flags & kConnected))
-	{
-		if ([writeQueue count] > 0)
-		{
-			// Dequeue the next object in the write queue
-			currentWrite = [writeQueue objectAtIndex:0];
-			[writeQueue removeObjectAtIndex:0];
-			
-			
-			if ([currentWrite isKindOfClass:[GCDAsyncSpecialPacket class]])
-			{
-				LogVerbose(@"Dequeued GCDAsyncSpecialPacket");
-				
-				// Attempt to start TLS
-				flags |= kStartingWriteTLS;
-				
-				// This method won't do anything unless both kStartingReadTLS and kStartingWriteTLS are set
-				[self maybeStartTLS];
-			}
-			else
-			{
-				LogVerbose(@"Dequeued GCDAsyncWritePacket");
-				
-				// Setup write timer (if needed)
-				[self setupWriteTimerWithTimeout:currentWrite->timeout];
-				
-				// Immediately write, if possible
-				[self doWriteData];
-			}
-		}
-		else if (flags & kDisconnectAfterWrites)
-		{
-			if (flags & kDisconnectAfterReads)
-			{
-				if (([readQueue count] == 0) && (currentRead == nil))
-				{
-					[self closeWithError:nil];
-				}
-			}
-			else
-			{
-				[self closeWithError:nil];
-			}
-		}
-	}
-}
-
-- (void)doWriteData
-{
-	LogTrace();
-	
-	// This method is called by the writeSource via the socketQueue
-	
-	if ((currentWrite == nil) || (flags & kWritesPaused))
-	{
-		LogVerbose(@"No currentWrite or kWritesPaused");
-		
-		// Unable to write at this time
-		
-		if ([self usingCFStreamForTLS])
-		{
-			// CFWriteStream only fires once when there is available data.
-			// It won't fire again until we've invoked CFWriteStreamWrite.
-		}
-		else
-		{
-			// If the writeSource is firing, we need to pause it
-			// or else it will continue to fire over and over again.
-			
-			if (flags & kSocketCanAcceptBytes)
-			{
-				[self suspendWriteSource];
-			}
-		}
-		return;
-	}
-	
-	if (!(flags & kSocketCanAcceptBytes))
-	{
-		LogVerbose(@"No space available to write...");
-		
-		// No space available to write.
-		
-		if (![self usingCFStreamForTLS])
-		{
-			// Need to wait for writeSource to fire and notify us of
-			// available space in the socket's internal write buffer.
-			
-			[self resumeWriteSource];
-		}
-		return;
-	}
-	
-	if (flags & kStartingWriteTLS)
-	{
-		LogVerbose(@"Waiting for SSL/TLS handshake to complete");
-		
-		// The writeQueue is waiting for SSL/TLS handshake to complete.
-		
-		if (flags & kStartingReadTLS)
-		{
-			if ([self usingSecureTransportForTLS] && lastSSLHandshakeError == errSSLWouldBlock)
-			{
-				// We are in the process of a SSL Handshake.
-				// We were waiting for available space in the socket's internal OS buffer to continue writing.
-			
-				[self ssl_continueSSLHandshake];
-			}
-		}
-		else
-		{
-			// We are still waiting for the readQueue to drain and start the SSL/TLS process.
-			// We now know we can write to the socket.
-			
-			if (![self usingCFStreamForTLS])
-			{
-				// Suspend the write source or else it will continue to fire nonstop.
-				
-				[self suspendWriteSource];
-			}
-		}
-		
-		return;
-	}
-	
-	// Note: This method is not called if currentWrite is a GCDAsyncSpecialPacket (startTLS packet)
-	
-	BOOL waiting = NO;
-	NSError *error = nil;
-	size_t bytesWritten = 0;
-	
-	if (flags & kSocketSecure)
-	{
-		if ([self usingCFStreamForTLS])
-		{
-			#if TARGET_OS_IPHONE
-			
-			// 
-			// Writing data using CFStream (over internal TLS)
-			// 
-			
-			const uint8_t *buffer = (const uint8_t *)[currentWrite->buffer bytes] + currentWrite->bytesDone;
-			
-			NSUInteger bytesToWrite = [currentWrite->buffer length] - currentWrite->bytesDone;
-			
-			if (bytesToWrite > SIZE_MAX) // NSUInteger may be bigger than size_t (write param 3)
-			{
-				bytesToWrite = SIZE_MAX;
-			}
-		
-			CFIndex result = CFWriteStreamWrite(writeStream, buffer, (CFIndex)bytesToWrite);
-			LogVerbose(@"CFWriteStreamWrite(%lu) = %li", (unsigned long)bytesToWrite, result);
-		
-			if (result < 0)
-			{
-				error = (__bridge_transfer NSError *)CFWriteStreamCopyError(writeStream);
-			}
-			else
-			{
-				bytesWritten = (size_t)result;
-				
-				// We always set waiting to true in this scenario.
-				// CFStream may have altered our underlying socket to non-blocking.
-				// Thus if we attempt to write without a callback, we may end up blocking our queue.
-				waiting = YES;
-			}
-			
-			#endif
-		}
-		else
-		{
-			// We're going to use the SSLWrite function.
-			// 
-			// OSStatus SSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)
-			// 
-			// Parameters:
-			// context     - An SSL session context reference.
-			// data        - A pointer to the buffer of data to write.
-			// dataLength  - The amount, in bytes, of data to write.
-			// processed   - On return, the length, in bytes, of the data actually written.
-			// 
-			// It sounds pretty straight-forward,
-			// but there are a few caveats you should be aware of.
-			// 
-			// The SSLWrite method operates in a non-obvious (and rather annoying) manner.
-			// According to the documentation:
-			// 
-			//   Because you may configure the underlying connection to operate in a non-blocking manner,
-			//   a write operation might return errSSLWouldBlock, indicating that less data than requested
-			//   was actually transferred. In this case, you should repeat the call to SSLWrite until some
-			//   other result is returned.
-			// 
-			// This sounds perfect, but when our SSLWriteFunction returns errSSLWouldBlock,
-			// then the SSLWrite method returns (with the proper errSSLWouldBlock return value),
-			// but it sets processed to dataLength !!
-			// 
-			// In other words, if the SSLWrite function doesn't completely write all the data we tell it to,
-			// then it doesn't tell us how many bytes were actually written. So, for example, if we tell it to
-			// write 256 bytes then it might actually write 128 bytes, but then report 0 bytes written.
-			// 
-			// You might be wondering:
-			// If the SSLWrite function doesn't tell us how many bytes were written,
-			// then how in the world are we supposed to update our parameters (buffer & bytesToWrite)
-			// for the next time we invoke SSLWrite?
-			// 
-			// The answer is that SSLWrite cached all the data we told it to write,
-			// and it will push out that data next time we call SSLWrite.
-			// If we call SSLWrite with new data, it will push out the cached data first, and then the new data.
-			// If we call SSLWrite with empty data, then it will simply push out the cached data.
-			// 
-			// For this purpose we're going to break large writes into a series of smaller writes.
-			// This allows us to report progress back to the delegate.
-			
-			OSStatus result;
-			
-			BOOL hasCachedDataToWrite = (sslWriteCachedLength > 0);
-			BOOL hasNewDataToWrite = YES;
-			
-			if (hasCachedDataToWrite)
-			{
-				size_t processed = 0;
-				
-				result = SSLWrite(sslContext, NULL, 0, &processed);
-				
-				if (result == noErr)
-				{
-					bytesWritten = sslWriteCachedLength;
-					sslWriteCachedLength = 0;
-					
-					if ([currentWrite->buffer length] == (currentWrite->bytesDone + bytesWritten))
-					{
-						// We've written all data for the current write.
-						hasNewDataToWrite = NO;
-					}
-				}
-				else
-				{
-					if (result == errSSLWouldBlock)
-					{
-						waiting = YES;
-					}
-					else
-					{
-						error = [self sslError:result];
-					}
-					
-					// Can't write any new data since we were unable to write the cached data.
-					hasNewDataToWrite = NO;
-				}
-			}
-			
-			if (hasNewDataToWrite)
-			{
-				const uint8_t *buffer = (const uint8_t *)[currentWrite->buffer bytes]
-				                                        + currentWrite->bytesDone
-				                                        + bytesWritten;
-				
-				NSUInteger bytesToWrite = [currentWrite->buffer length] - currentWrite->bytesDone - bytesWritten;
-				
-				if (bytesToWrite > SIZE_MAX) // NSUInteger may be bigger than size_t (write param 3)
-				{
-					bytesToWrite = SIZE_MAX;
-				}
-				
-				size_t bytesRemaining = bytesToWrite;
-				
-				BOOL keepLooping = YES;
-				while (keepLooping)
-				{
-					const size_t sslMaxBytesToWrite = 32768;
-					size_t sslBytesToWrite = MIN(bytesRemaining, sslMaxBytesToWrite);
-					size_t sslBytesWritten = 0;
-					
-					result = SSLWrite(sslContext, buffer, sslBytesToWrite, &sslBytesWritten);
-					
-					if (result == noErr)
-					{
-						buffer += sslBytesWritten;
-						bytesWritten += sslBytesWritten;
-						bytesRemaining -= sslBytesWritten;
-						
-						keepLooping = (bytesRemaining > 0);
-					}
-					else
-					{
-						if (result == errSSLWouldBlock)
-						{
-							waiting = YES;
-							sslWriteCachedLength = sslBytesToWrite;
-						}
-						else
-						{
-							error = [self sslError:result];
-						}
-						
-						keepLooping = NO;
-					}
-					
-				} // while (keepLooping)
-				
-			} // if (hasNewDataToWrite)
-		}
-	}
-	else
-	{
-		// 
-		// Writing data directly over raw socket
-		// 
-		
-		int socketFD = (socket4FD != SOCKET_NULL) ? socket4FD : (socket6FD != SOCKET_NULL) ? socket6FD : socketUN;
-		
-		const uint8_t *buffer = (const uint8_t *)[currentWrite->buffer bytes] + currentWrite->bytesDone;
-		
-		NSUInteger bytesToWrite = [currentWrite->buffer length] - currentWrite->bytesDone;
-		
-		if (bytesToWrite > SIZE_MAX) // NSUInteger may be bigger than size_t (write param 3)
-		{
-			bytesToWrite = SIZE_MAX;
-		}
-		
-		ssize_t result = write(socketFD, buffer, (size_t)bytesToWrite);
-		LogVerbose(@"wrote to socket = %zd", result);
-		
-		// Check results
-		if (result < 0)
-		{
-			if (errno == EWOULDBLOCK)
-			{
-				waiting = YES;
-			}
-			else
-			{
-				error = [self errnoErrorWithReason:@"Error in write() function"];
-			}
-		}
-		else
-		{
-			bytesWritten = result;
-		}
-	}
-	
-	// We're done with our writing.
-	// If we explictly ran into a situation where the socket told us there was no room in the buffer,
-	// then we immediately resume listening for notifications.
-	// 
-	// We must do this before we dequeue another write,
-	// as that may in turn invoke this method again.
-	// 
-	// Note that if CFStream is involved, it may have maliciously put our socket in blocking mode.
-	
-	if (waiting)
-	{
-		flags &= ~kSocketCanAcceptBytes;
-		
-		if (![self usingCFStreamForTLS])
-		{
-			[self resumeWriteSource];
-		}
-	}
-	
-	// Check our results
-	
-	BOOL done = NO;
-	
-	if (bytesWritten > 0)
-	{
-		// Update total amount read for the current write
-		currentWrite->bytesDone += bytesWritten;
-		LogVerbose(@"currentWrite->bytesDone = %lu", (unsigned long)currentWrite->bytesDone);
-		
-		// Is packet done?
-		done = (currentWrite->bytesDone == [currentWrite->buffer length]);
-	}
-	
-	if (done)
-	{
-		[self completeCurrentWrite];
-		
-		if (!error)
-		{
-			dispatch_async(socketQueue, ^{ @autoreleasepool{
-				
-				[self maybeDequeueWrite];
-			}});
-		}
-	}
-	else
-	{
-		// We were unable to finish writing the data,
-		// so we're waiting for another callback to notify us of available space in the lower-level output buffer.
-		
-		if (!waiting && !error)
-		{
-			// This would be the case if our write was able to accept some data, but not all of it.
-			
-			flags &= ~kSocketCanAcceptBytes;
-			
-			if (![self usingCFStreamForTLS])
-			{
-				[self resumeWriteSource];
-			}
-		}
-		
-		if (bytesWritten > 0)
-		{
-			// We're not done with the entire write, but we have written some bytes
-			
-			__strong id theDelegate = delegate;
-
-			if (delegateQueue && [theDelegate respondsToSelector:@selector(socket:didWritePartialDataOfLength:tag:)])
-			{
-				long theWriteTag = currentWrite->tag;
-				
-				dispatch_async(delegateQueue, ^{ @autoreleasepool {
-					
-					[theDelegate socket:self didWritePartialDataOfLength:bytesWritten tag:theWriteTag];
-				}});
-			}
-		}
-	}
-	
-	// Check for errors
-	
-	if (error)
-	{
-		[self closeWithError:[self errnoErrorWithReason:@"Error in write() function"]];
-	}
-	
-	// Do not add any code here without first adding a return statement in the error case above.
-}
-
-- (void)completeCurrentWrite
-{
-	LogTrace();
-	
-	NSAssert(currentWrite, @"Trying to complete current write when there is no current write.");
-	
-
-	__strong id theDelegate = delegate;
-	
-	if (delegateQueue && [theDelegate respondsToSelector:@selector(socket:didWriteDataWithTag:)])
-	{
-		long theWriteTag = currentWrite->tag;
-		
-		dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-			[theDelegate socket:self didWriteDataWithTag:theWriteTag];
-		}});
-	}
-	
-	[self endCurrentWrite];
-}
-
-- (void)endCurrentWrite
-{
-	if (writeTimer)
-	{
-		dispatch_source_cancel(writeTimer);
-		writeTimer = NULL;
-	}
-	
-	currentWrite = nil;
-}
-
-- (void)setupWriteTimerWithTimeout:(NSTimeInterval)timeout
-{
-	if (timeout >= 0.0)
-	{
-		writeTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, socketQueue);
-		
-		__weak GCDAsyncSocket *weakSelf = self;
-		
-		dispatch_source_set_event_handler(writeTimer, ^{ @autoreleasepool {
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-			
-			__strong GCDAsyncSocket *strongSelf = weakSelf;
-			if (strongSelf == nil) return_from_block;
-			
-			[strongSelf doWriteTimeout];
-			
-		#pragma clang diagnostic pop
-		}});
-		
-		#if !OS_OBJECT_USE_OBJC
-		dispatch_source_t theWriteTimer = writeTimer;
-		dispatch_source_set_cancel_handler(writeTimer, ^{
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-			
-			LogVerbose(@"dispatch_release(writeTimer)");
-			dispatch_release(theWriteTimer);
-			
-		#pragma clang diagnostic pop
-		});
-		#endif
-		
-		dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC));
-		
-		dispatch_source_set_timer(writeTimer, tt, DISPATCH_TIME_FOREVER, 0);
-		dispatch_resume(writeTimer);
-	}
-}
-
-- (void)doWriteTimeout
-{
-	// This is a little bit tricky.
-	// Ideally we'd like to synchronously query the delegate about a timeout extension.
-	// But if we do so synchronously we risk a possible deadlock.
-	// So instead we have to do so asynchronously, and callback to ourselves from within the delegate block.
-	
-	flags |= kWritesPaused;
-	
-	__strong id theDelegate = delegate;
-
-	if (delegateQueue && [theDelegate respondsToSelector:@selector(socket:shouldTimeoutWriteWithTag:elapsed:bytesDone:)])
-	{
-		GCDAsyncWritePacket *theWrite = currentWrite;
-		
-		dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-			NSTimeInterval timeoutExtension = 0.0;
-			
-			timeoutExtension = [theDelegate socket:self shouldTimeoutWriteWithTag:theWrite->tag
-			                                                              elapsed:theWrite->timeout
-			                                                            bytesDone:theWrite->bytesDone];
-			
-			dispatch_async(socketQueue, ^{ @autoreleasepool {
-				
-				[self doWriteTimeoutWithExtension:timeoutExtension];
-			}});
-		}});
-	}
-	else
-	{
-		[self doWriteTimeoutWithExtension:0.0];
-	}
-}
-
-- (void)doWriteTimeoutWithExtension:(NSTimeInterval)timeoutExtension
-{
-	if (currentWrite)
-	{
-		if (timeoutExtension > 0.0)
-		{
-			currentWrite->timeout += timeoutExtension;
-			
-			// Reschedule the timer
-			dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeoutExtension * NSEC_PER_SEC));
-			dispatch_source_set_timer(writeTimer, tt, DISPATCH_TIME_FOREVER, 0);
-			
-			// Unpause writes, and continue
-			flags &= ~kWritesPaused;
-			[self doWriteData];
-		}
-		else
-		{
-			LogVerbose(@"WriteTimeout");
-			
-			[self closeWithError:[self writeTimeoutError]];
-		}
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Security
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (void)startTLS:(NSDictionary *)tlsSettings
-{
-	LogTrace();
-	
-	if (tlsSettings == nil)
-    {
-        // Passing nil/NULL to CFReadStreamSetProperty will appear to work the same as passing an empty dictionary,
-        // but causes problems if we later try to fetch the remote host's certificate.
-        // 
-        // To be exact, it causes the following to return NULL instead of the normal result:
-        // CFReadStreamCopyProperty(readStream, kCFStreamPropertySSLPeerCertificates)
-        // 
-        // So we use an empty dictionary instead, which works perfectly.
-        
-        tlsSettings = [NSDictionary dictionary];
-    }
-	
-	GCDAsyncSpecialPacket *packet = [[GCDAsyncSpecialPacket alloc] initWithTLSSettings:tlsSettings];
-	
-	dispatch_async(socketQueue, ^{ @autoreleasepool {
-		
-		if ((flags & kSocketStarted) && !(flags & kQueuedTLS) && !(flags & kForbidReadsWrites))
-		{
-			[readQueue addObject:packet];
-			[writeQueue addObject:packet];
-			
-			flags |= kQueuedTLS;
-			
-			[self maybeDequeueRead];
-			[self maybeDequeueWrite];
-		}
-	}});
-	
-}
-
-- (void)maybeStartTLS
-{
-	// We can't start TLS until:
-	// - All queued reads prior to the user calling startTLS are complete
-	// - All queued writes prior to the user calling startTLS are complete
-	// 
-	// We'll know these conditions are met when both kStartingReadTLS and kStartingWriteTLS are set
-	
-	if ((flags & kStartingReadTLS) && (flags & kStartingWriteTLS))
-	{
-		BOOL useSecureTransport = YES;
-		
-		#if TARGET_OS_IPHONE
-		{
-			GCDAsyncSpecialPacket *tlsPacket = (GCDAsyncSpecialPacket *)currentRead;
-            NSDictionary *tlsSettings = @{};
-            if (tlsPacket) {
-                tlsSettings = tlsPacket->tlsSettings;
-            }
-			NSNumber *value = [tlsSettings objectForKey:GCDAsyncSocketUseCFStreamForTLS];
-			if (value && [value boolValue])
-				useSecureTransport = NO;
-		}
-		#endif
-		
-		if (useSecureTransport)
-		{
-			[self ssl_startTLS];
-		}
-		else
-		{
-		#if TARGET_OS_IPHONE
-			[self cf_startTLS];
-		#endif
-		}
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Security via SecureTransport
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-- (OSStatus)sslReadWithBuffer:(void *)buffer length:(size_t *)bufferLength
-{
-	LogVerbose(@"sslReadWithBuffer:%p length:%lu", buffer, (unsigned long)*bufferLength);
-	
-	if ((socketFDBytesAvailable == 0) && ([sslPreBuffer availableBytes] == 0))
-	{
-		LogVerbose(@"%@ - No data available to read...", THIS_METHOD);
-		
-		// No data available to read.
-		// 
-		// Need to wait for readSource to fire and notify us of
-		// available data in the socket's internal read buffer.
-		
-		[self resumeReadSource];
-		
-		*bufferLength = 0;
-		return errSSLWouldBlock;
-	}
-	
-	size_t totalBytesRead = 0;
-	size_t totalBytesLeftToBeRead = *bufferLength;
-	
-	BOOL done = NO;
-	BOOL socketError = NO;
-	
-	// 
-	// STEP 1 : READ FROM SSL PRE BUFFER
-	// 
-	
-	size_t sslPreBufferLength = [sslPreBuffer availableBytes];
-	
-	if (sslPreBufferLength > 0)
-	{
-		LogVerbose(@"%@: Reading from SSL pre buffer...", THIS_METHOD);
-		
-		size_t bytesToCopy;
-		if (sslPreBufferLength > totalBytesLeftToBeRead)
-			bytesToCopy = totalBytesLeftToBeRead;
-		else
-			bytesToCopy = sslPreBufferLength;
-		
-		LogVerbose(@"%@: Copying %zu bytes from sslPreBuffer", THIS_METHOD, bytesToCopy);
-		
-		memcpy(buffer, [sslPreBuffer readBuffer], bytesToCopy);
-		[sslPreBuffer didRead:bytesToCopy];
-		
-		LogVerbose(@"%@: sslPreBuffer.length = %zu", THIS_METHOD, [sslPreBuffer availableBytes]);
-		
-		totalBytesRead += bytesToCopy;
-		totalBytesLeftToBeRead -= bytesToCopy;
-		
-		done = (totalBytesLeftToBeRead == 0);
-		
-		if (done) LogVerbose(@"%@: Complete", THIS_METHOD);
-	}
-	
-	// 
-	// STEP 2 : READ FROM SOCKET
-	// 
-	
-	if (!done && (socketFDBytesAvailable > 0))
-	{
-		LogVerbose(@"%@: Reading from socket...", THIS_METHOD);
-		
-		int socketFD = (socket4FD != SOCKET_NULL) ? socket4FD : (socket6FD != SOCKET_NULL) ? socket6FD : socketUN;
-		
-		BOOL readIntoPreBuffer;
-		size_t bytesToRead;
-		uint8_t *buf;
-		
-		if (socketFDBytesAvailable > totalBytesLeftToBeRead)
-		{
-			// Read all available data from socket into sslPreBuffer.
-			// Then copy requested amount into dataBuffer.
-			
-			LogVerbose(@"%@: Reading into sslPreBuffer...", THIS_METHOD);
-			
-			[sslPreBuffer ensureCapacityForWrite:socketFDBytesAvailable];
-			
-			readIntoPreBuffer = YES;
-			bytesToRead = (size_t)socketFDBytesAvailable;
-			buf = [sslPreBuffer writeBuffer];
-		}
-		else
-		{
-			// Read available data from socket directly into dataBuffer.
-			
-			LogVerbose(@"%@: Reading directly into dataBuffer...", THIS_METHOD);
-			
-			readIntoPreBuffer = NO;
-			bytesToRead = totalBytesLeftToBeRead;
-			buf = (uint8_t *)buffer + totalBytesRead;
-		}
-		
-		ssize_t result = read(socketFD, buf, bytesToRead);
-		LogVerbose(@"%@: read from socket = %zd", THIS_METHOD, result);
-		
-		if (result < 0)
-		{
-			LogVerbose(@"%@: read errno = %i", THIS_METHOD, errno);
-			
-			if (errno != EWOULDBLOCK)
-			{
-				socketError = YES;
-			}
-			
-			socketFDBytesAvailable = 0;
-		}
-		else if (result == 0)
-		{
-			LogVerbose(@"%@: read EOF", THIS_METHOD);
-			
-			socketError = YES;
-			socketFDBytesAvailable = 0;
-		}
-		else
-		{
-			size_t bytesReadFromSocket = result;
-			
-			if (socketFDBytesAvailable > bytesReadFromSocket)
-				socketFDBytesAvailable -= bytesReadFromSocket;
-			else
-				socketFDBytesAvailable = 0;
-			
-			if (readIntoPreBuffer)
-			{
-				[sslPreBuffer didWrite:bytesReadFromSocket];
-				
-				size_t bytesToCopy = MIN(totalBytesLeftToBeRead, bytesReadFromSocket);
-				
-				LogVerbose(@"%@: Copying %zu bytes out of sslPreBuffer", THIS_METHOD, bytesToCopy);
-				
-				memcpy((uint8_t *)buffer + totalBytesRead, [sslPreBuffer readBuffer], bytesToCopy);
-				[sslPreBuffer didRead:bytesToCopy];
-				
-				totalBytesRead += bytesToCopy;
-				totalBytesLeftToBeRead -= bytesToCopy;
-				
-				LogVerbose(@"%@: sslPreBuffer.length = %zu", THIS_METHOD, [sslPreBuffer availableBytes]);
-			}
-			else
-			{
-				totalBytesRead += bytesReadFromSocket;
-				totalBytesLeftToBeRead -= bytesReadFromSocket;
-			}
-			
-			done = (totalBytesLeftToBeRead == 0);
-			
-			if (done) LogVerbose(@"%@: Complete", THIS_METHOD);
-		}
-	}
-	
-	*bufferLength = totalBytesRead;
-	
-	if (done)
-		return noErr;
-	
-	if (socketError)
-		return errSSLClosedAbort;
-	
-	return errSSLWouldBlock;
-}
-
-- (OSStatus)sslWriteWithBuffer:(const void *)buffer length:(size_t *)bufferLength
-{
-	if (!(flags & kSocketCanAcceptBytes))
-	{
-		// Unable to write.
-		// 
-		// Need to wait for writeSource to fire and notify us of
-		// available space in the socket's internal write buffer.
-		
-		[self resumeWriteSource];
-		
-		*bufferLength = 0;
-		return errSSLWouldBlock;
-	}
-	
-	size_t bytesToWrite = *bufferLength;
-	size_t bytesWritten = 0;
-	
-	BOOL done = NO;
-	BOOL socketError = NO;
-	
-	int socketFD = (socket4FD != SOCKET_NULL) ? socket4FD : (socket6FD != SOCKET_NULL) ? socket6FD : socketUN;
-	
-	ssize_t result = write(socketFD, buffer, bytesToWrite);
-	
-	if (result < 0)
-	{
-		if (errno != EWOULDBLOCK)
-		{
-			socketError = YES;
-		}
-		
-		flags &= ~kSocketCanAcceptBytes;
-	}
-	else if (result == 0)
-	{
-		flags &= ~kSocketCanAcceptBytes;
-	}
-	else
-	{
-		bytesWritten = result;
-		
-		done = (bytesWritten == bytesToWrite);
-	}
-	
-	*bufferLength = bytesWritten;
-	
-	if (done)
-		return noErr;
-	
-	if (socketError)
-		return errSSLClosedAbort;
-	
-	return errSSLWouldBlock;
-}
-
-static OSStatus SSLReadFunction(SSLConnectionRef connection, void *data, size_t *dataLength)
-{
-	GCDAsyncSocket *asyncSocket = (__bridge GCDAsyncSocket *)connection;
-	
-	NSCAssert(dispatch_get_specific(asyncSocket->IsOnSocketQueueOrTargetQueueKey), @"What the deuce?");
-	
-	return [asyncSocket sslReadWithBuffer:data length:dataLength];
-}
-
-static OSStatus SSLWriteFunction(SSLConnectionRef connection, const void *data, size_t *dataLength)
-{
-	GCDAsyncSocket *asyncSocket = (__bridge GCDAsyncSocket *)connection;
-	
-	NSCAssert(dispatch_get_specific(asyncSocket->IsOnSocketQueueOrTargetQueueKey), @"What the deuce?");
-	
-	return [asyncSocket sslWriteWithBuffer:data length:dataLength];
-}
-
-- (void)ssl_startTLS
-{
-	LogTrace();
-	
-	LogVerbose(@"Starting TLS (via SecureTransport)...");
-	
-	OSStatus status;
-	
-	GCDAsyncSpecialPacket *tlsPacket = (GCDAsyncSpecialPacket *)currentRead;
-	if (tlsPacket == nil) // Code to quiet the analyzer
-	{
-		NSAssert(NO, @"Logic error");
-		
-		[self closeWithError:[self otherError:@"Logic error"]];
-		return;
-	}
-	NSDictionary *tlsSettings = tlsPacket->tlsSettings;
-	
-	// Create SSLContext, and setup IO callbacks and connection ref
-	
-	BOOL isServer = [[tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLIsServer] boolValue];
-	
-	#if TARGET_OS_IPHONE || (__MAC_OS_X_VERSION_MIN_REQUIRED >= 1080)
-	{
-		if (isServer)
-			sslContext = SSLCreateContext(kCFAllocatorDefault, kSSLServerSide, kSSLStreamType);
-		else
-			sslContext = SSLCreateContext(kCFAllocatorDefault, kSSLClientSide, kSSLStreamType);
-		
-		if (sslContext == NULL)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLCreateContext"]];
-			return;
-		}
-	}
-	#else // (__MAC_OS_X_VERSION_MIN_REQUIRED < 1080)
-	{
-		status = SSLNewContext(isServer, &sslContext);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLNewContext"]];
-			return;
-		}
-	}
-	#endif
-	
-	status = SSLSetIOFuncs(sslContext, &SSLReadFunction, &SSLWriteFunction);
-	if (status != noErr)
-	{
-		[self closeWithError:[self otherError:@"Error in SSLSetIOFuncs"]];
-		return;
-	}
-	
-	status = SSLSetConnection(sslContext, (__bridge SSLConnectionRef)self);
-	if (status != noErr)
-	{
-		[self closeWithError:[self otherError:@"Error in SSLSetConnection"]];
-		return;
-	}
-
-
-	BOOL shouldManuallyEvaluateTrust = [[tlsSettings objectForKey:GCDAsyncSocketManuallyEvaluateTrust] boolValue];
-	if (shouldManuallyEvaluateTrust)
-	{
-		if (isServer)
-		{
-			[self closeWithError:[self otherError:@"Manual trust validation is not supported for server sockets"]];
-			return;
-		}
-		
-		status = SSLSetSessionOption(sslContext, kSSLSessionOptionBreakOnServerAuth, true);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetSessionOption"]];
-			return;
-		}
-		
-		#if !TARGET_OS_IPHONE && (__MAC_OS_X_VERSION_MIN_REQUIRED < 1080)
-		
-		// Note from Apple's documentation:
-		//
-		// It is only necessary to call SSLSetEnableCertVerify on the Mac prior to OS X 10.8.
-		// On OS X 10.8 and later setting kSSLSessionOptionBreakOnServerAuth always disables the
-		// built-in trust evaluation. All versions of iOS behave like OS X 10.8 and thus
-		// SSLSetEnableCertVerify is not available on that platform at all.
-		
-		status = SSLSetEnableCertVerify(sslContext, NO);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetEnableCertVerify"]];
-			return;
-		}
-		
-		#endif
-	}
-
-	// Configure SSLContext from given settings
-	// 
-	// Checklist:
-	//  1. kCFStreamSSLPeerName
-	//  2. kCFStreamSSLCertificates
-	//  3. GCDAsyncSocketSSLPeerID
-	//  4. GCDAsyncSocketSSLProtocolVersionMin
-	//  5. GCDAsyncSocketSSLProtocolVersionMax
-	//  6. GCDAsyncSocketSSLSessionOptionFalseStart
-	//  7. GCDAsyncSocketSSLSessionOptionSendOneByteRecord
-	//  8. GCDAsyncSocketSSLCipherSuites
-	//  9. GCDAsyncSocketSSLDiffieHellmanParameters (Mac)
-	//
-	// Deprecated (throw error):
-	// 10. kCFStreamSSLAllowsAnyRoot
-	// 11. kCFStreamSSLAllowsExpiredRoots
-	// 12. kCFStreamSSLAllowsExpiredCertificates
-	// 13. kCFStreamSSLValidatesCertificateChain
-	// 14. kCFStreamSSLLevel
-	
-	id value;
-	
-	// 1. kCFStreamSSLPeerName
-	
-	value = [tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLPeerName];
-	if ([value isKindOfClass:[NSString class]])
-	{
-		NSString *peerName = (NSString *)value;
-		
-		const char *peer = [peerName UTF8String];
-		size_t peerLen = strlen(peer);
-		
-		status = SSLSetPeerDomainName(sslContext, peer, peerLen);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetPeerDomainName"]];
-			return;
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for kCFStreamSSLPeerName. Value must be of type NSString.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for kCFStreamSSLPeerName."]];
-		return;
-	}
-	
-	// 2. kCFStreamSSLCertificates
-	
-	value = [tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLCertificates];
-	if ([value isKindOfClass:[NSArray class]])
-	{
-		CFArrayRef certs = (__bridge CFArrayRef)value;
-		
-		status = SSLSetCertificate(sslContext, certs);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetCertificate"]];
-			return;
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for kCFStreamSSLCertificates. Value must be of type NSArray.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for kCFStreamSSLCertificates."]];
-		return;
-	}
-	
-	// 3. GCDAsyncSocketSSLPeerID
-	
-	value = [tlsSettings objectForKey:GCDAsyncSocketSSLPeerID];
-	if ([value isKindOfClass:[NSData class]])
-	{
-		NSData *peerIdData = (NSData *)value;
-		
-		status = SSLSetPeerID(sslContext, [peerIdData bytes], [peerIdData length]);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetPeerID"]];
-			return;
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for GCDAsyncSocketSSLPeerID. Value must be of type NSData."
-		             @" (You can convert strings to data using a method like"
-		             @" [string dataUsingEncoding:NSUTF8StringEncoding])");
-		
-		[self closeWithError:[self otherError:@"Invalid value for GCDAsyncSocketSSLPeerID."]];
-		return;
-	}
-	
-	// 4. GCDAsyncSocketSSLProtocolVersionMin
-	
-	value = [tlsSettings objectForKey:GCDAsyncSocketSSLProtocolVersionMin];
-	if ([value isKindOfClass:[NSNumber class]])
-	{
-		SSLProtocol minProtocol = (SSLProtocol)[(NSNumber *)value intValue];
-		if (minProtocol != kSSLProtocolUnknown)
-		{
-			status = SSLSetProtocolVersionMin(sslContext, minProtocol);
-			if (status != noErr)
-			{
-				[self closeWithError:[self otherError:@"Error in SSLSetProtocolVersionMin"]];
-				return;
-			}
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for GCDAsyncSocketSSLProtocolVersionMin. Value must be of type NSNumber.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for GCDAsyncSocketSSLProtocolVersionMin."]];
-		return;
-	}
-	
-	// 5. GCDAsyncSocketSSLProtocolVersionMax
-	
-	value = [tlsSettings objectForKey:GCDAsyncSocketSSLProtocolVersionMax];
-	if ([value isKindOfClass:[NSNumber class]])
-	{
-		SSLProtocol maxProtocol = (SSLProtocol)[(NSNumber *)value intValue];
-		if (maxProtocol != kSSLProtocolUnknown)
-		{
-			status = SSLSetProtocolVersionMax(sslContext, maxProtocol);
-			if (status != noErr)
-			{
-				[self closeWithError:[self otherError:@"Error in SSLSetProtocolVersionMax"]];
-				return;
-			}
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for GCDAsyncSocketSSLProtocolVersionMax. Value must be of type NSNumber.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for GCDAsyncSocketSSLProtocolVersionMax."]];
-		return;
-	}
-	
-	// 6. GCDAsyncSocketSSLSessionOptionFalseStart
-	
-	value = [tlsSettings objectForKey:GCDAsyncSocketSSLSessionOptionFalseStart];
-	if ([value isKindOfClass:[NSNumber class]])
-	{
-		status = SSLSetSessionOption(sslContext, kSSLSessionOptionFalseStart, [value boolValue]);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetSessionOption (kSSLSessionOptionFalseStart)"]];
-			return;
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for GCDAsyncSocketSSLSessionOptionFalseStart. Value must be of type NSNumber.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for GCDAsyncSocketSSLSessionOptionFalseStart."]];
-		return;
-	}
-	
-	// 7. GCDAsyncSocketSSLSessionOptionSendOneByteRecord
-	
-	value = [tlsSettings objectForKey:GCDAsyncSocketSSLSessionOptionSendOneByteRecord];
-	if ([value isKindOfClass:[NSNumber class]])
-	{
-		status = SSLSetSessionOption(sslContext, kSSLSessionOptionSendOneByteRecord, [value boolValue]);
-		if (status != noErr)
-		{
-			[self closeWithError:
-			  [self otherError:@"Error in SSLSetSessionOption (kSSLSessionOptionSendOneByteRecord)"]];
-			return;
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for GCDAsyncSocketSSLSessionOptionSendOneByteRecord."
-		             @" Value must be of type NSNumber.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for GCDAsyncSocketSSLSessionOptionSendOneByteRecord."]];
-		return;
-	}
-	
-	// 8. GCDAsyncSocketSSLCipherSuites
-	
-	value = [tlsSettings objectForKey:GCDAsyncSocketSSLCipherSuites];
-	if ([value isKindOfClass:[NSArray class]])
-	{
-		NSArray *cipherSuites = (NSArray *)value;
-		NSUInteger numberCiphers = [cipherSuites count];
-		SSLCipherSuite ciphers[numberCiphers];
-		
-		NSUInteger cipherIndex;
-		for (cipherIndex = 0; cipherIndex < numberCiphers; cipherIndex++)
-		{
-			NSNumber *cipherObject = [cipherSuites objectAtIndex:cipherIndex];
-			ciphers[cipherIndex] = [cipherObject shortValue];
-		}
-		
-		status = SSLSetEnabledCiphers(sslContext, ciphers, numberCiphers);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetEnabledCiphers"]];
-			return;
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for GCDAsyncSocketSSLCipherSuites. Value must be of type NSArray.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for GCDAsyncSocketSSLCipherSuites."]];
-		return;
-	}
-	
-	// 9. GCDAsyncSocketSSLDiffieHellmanParameters
-	
-	#if !TARGET_OS_IPHONE
-	value = [tlsSettings objectForKey:GCDAsyncSocketSSLDiffieHellmanParameters];
-	if ([value isKindOfClass:[NSData class]])
-	{
-		NSData *diffieHellmanData = (NSData *)value;
-		
-		status = SSLSetDiffieHellmanParams(sslContext, [diffieHellmanData bytes], [diffieHellmanData length]);
-		if (status != noErr)
-		{
-			[self closeWithError:[self otherError:@"Error in SSLSetDiffieHellmanParams"]];
-			return;
-		}
-	}
-	else if (value)
-	{
-		NSAssert(NO, @"Invalid value for GCDAsyncSocketSSLDiffieHellmanParameters. Value must be of type NSData.");
-		
-		[self closeWithError:[self otherError:@"Invalid value for GCDAsyncSocketSSLDiffieHellmanParameters."]];
-		return;
-	}
-	#endif
-	
-	// DEPRECATED checks
-	
-	// 10. kCFStreamSSLAllowsAnyRoot
-	
-	#pragma clang diagnostic push
-	#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-	value = [tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLAllowsAnyRoot];
-	#pragma clang diagnostic pop
-	if (value)
-	{
-		NSAssert(NO, @"Security option unavailable - kCFStreamSSLAllowsAnyRoot"
-		             @" - You must use manual trust evaluation");
-		
-		[self closeWithError:[self otherError:@"Security option unavailable - kCFStreamSSLAllowsAnyRoot"]];
-		return;
-	}
-	
-	// 11. kCFStreamSSLAllowsExpiredRoots
-	
-	#pragma clang diagnostic push
-	#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-	value = [tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLAllowsExpiredRoots];
-	#pragma clang diagnostic pop
-	if (value)
-	{
-		NSAssert(NO, @"Security option unavailable - kCFStreamSSLAllowsExpiredRoots"
-		             @" - You must use manual trust evaluation");
-		
-		[self closeWithError:[self otherError:@"Security option unavailable - kCFStreamSSLAllowsExpiredRoots"]];
-		return;
-	}
-	
-	// 12. kCFStreamSSLValidatesCertificateChain
-	
-	#pragma clang diagnostic push
-	#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-	value = [tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLValidatesCertificateChain];
-	#pragma clang diagnostic pop
-	if (value)
-	{
-		NSAssert(NO, @"Security option unavailable - kCFStreamSSLValidatesCertificateChain"
-		             @" - You must use manual trust evaluation");
-		
-		[self closeWithError:[self otherError:@"Security option unavailable - kCFStreamSSLValidatesCertificateChain"]];
-		return;
-	}
-	
-	// 13. kCFStreamSSLAllowsExpiredCertificates
-	
-	#pragma clang diagnostic push
-	#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-	value = [tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLAllowsExpiredCertificates];
-	#pragma clang diagnostic pop
-	if (value)
-	{
-		NSAssert(NO, @"Security option unavailable - kCFStreamSSLAllowsExpiredCertificates"
-		             @" - You must use manual trust evaluation");
-		
-		[self closeWithError:[self otherError:@"Security option unavailable - kCFStreamSSLAllowsExpiredCertificates"]];
-		return;
-	}
-	
-	// 14. kCFStreamSSLLevel
-	
-	#pragma clang diagnostic push
-	#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-	value = [tlsSettings objectForKey:(__bridge NSString *)kCFStreamSSLLevel];
-	#pragma clang diagnostic pop
-	if (value)
-	{
-		NSAssert(NO, @"Security option unavailable - kCFStreamSSLLevel"
-		             @" - You must use GCDAsyncSocketSSLProtocolVersionMin & GCDAsyncSocketSSLProtocolVersionMax");
-		
-		[self closeWithError:[self otherError:@"Security option unavailable - kCFStreamSSLLevel"]];
-		return;
-	}
-	
-	// Setup the sslPreBuffer
-	// 
-	// Any data in the preBuffer needs to be moved into the sslPreBuffer,
-	// as this data is now part of the secure read stream.
-	
-	sslPreBuffer = [[GCDAsyncSocketPreBuffer alloc] initWithCapacity:(1024 * 4)];
-	
-	size_t preBufferLength  = [preBuffer availableBytes];
-	
-	if (preBufferLength > 0)
-	{
-		[sslPreBuffer ensureCapacityForWrite:preBufferLength];
-		
-		memcpy([sslPreBuffer writeBuffer], [preBuffer readBuffer], preBufferLength);
-		[preBuffer didRead:preBufferLength];
-		[sslPreBuffer didWrite:preBufferLength];
-	}
-	
-	sslErrCode = lastSSLHandshakeError = noErr;
-	
-	// Start the SSL Handshake process
-	
-	[self ssl_continueSSLHandshake];
-}
-
-- (void)ssl_continueSSLHandshake
-{
-	LogTrace();
-	
-	// If the return value is noErr, the session is ready for normal secure communication.
-	// If the return value is errSSLWouldBlock, the SSLHandshake function must be called again.
-	// If the return value is errSSLServerAuthCompleted, we ask delegate if we should trust the
-	// server and then call SSLHandshake again to resume the handshake or close the connection
-	// errSSLPeerBadCert SSL error.
-	// Otherwise, the return value indicates an error code.
-	
-	OSStatus status = SSLHandshake(sslContext);
-	lastSSLHandshakeError = status;
-	
-	if (status == noErr)
-	{
-		LogVerbose(@"SSLHandshake complete");
-		
-		flags &= ~kStartingReadTLS;
-		flags &= ~kStartingWriteTLS;
-		
-		flags |=  kSocketSecure;
-		
-		__strong id theDelegate = delegate;
-
-		if (delegateQueue && [theDelegate respondsToSelector:@selector(socketDidSecure:)])
-		{
-			dispatch_async(delegateQueue, ^{ @autoreleasepool {
-				
-				[theDelegate socketDidSecure:self];
-			}});
-		}
-		
-		[self endCurrentRead];
-		[self endCurrentWrite];
-		
-		[self maybeDequeueRead];
-		[self maybeDequeueWrite];
-	}
-	else if (status == errSSLPeerAuthCompleted)
-	{
-		LogVerbose(@"SSLHandshake peerAuthCompleted - awaiting delegate approval");
-		
-		__block SecTrustRef trust = NULL;
-		status = SSLCopyPeerTrust(sslContext, &trust);
-		if (status != noErr)
-		{
-			[self closeWithError:[self sslError:status]];
-			return;
-		}
-		
-		int aStateIndex = stateIndex;
-		dispatch_queue_t theSocketQueue = socketQueue;
-		
-		__weak GCDAsyncSocket *weakSelf = self;
-		
-		void (^comletionHandler)(BOOL) = ^(BOOL shouldTrust){ @autoreleasepool {
-		#pragma clang diagnostic push
-		#pragma clang diagnostic warning "-Wimplicit-retain-self"
-			
-			dispatch_async(theSocketQueue, ^{ @autoreleasepool {
-				
-				if (trust) {
-					CFRelease(trust);
-					trust = NULL;
-				}
-				
-				__strong GCDAsyncSocket *strongSelf = weakSelf;
-				if (strongSelf)
-				{
-					[strongSelf ssl_shouldTrustPeer:shouldTrust stateIndex:aStateIndex];
-				}
-			}});
-			
-		#pragma clang diagnostic pop
-		}};
-		
-		__strong id theDelegate = delegate;
-		
-		if (delegateQueue && [theDelegate respondsToSelector:@selector(socket:didReceiveTrust:completionHandler:)])
-		{
-			dispatch_async(delegateQueue, ^{ @autoreleasepool {
-			
-				[theDelegate socket:self didReceiveTrust:trust completionHandler:comletionHandler];
-			}});
-		}
-		else
-		{
-			if (trust) {
-				CFRelease(trust);
-				trust = NULL;
-			}
-			
-			NSString *msg = @"GCDAsyncSocketManuallyEvaluateTrust specified in tlsSettings,"
-			                @" but delegate doesn't implement socket:shouldTrustPeer:";
-			
-			[self closeWithError:[self otherError:msg]];
-			return;
-		}
-	}
-	else if (status == errSSLWouldBlock)
-	{
-		LogVerbose(@"SSLHandshake continues...");
-		
-		// Handshake continues...
-		// 
-		// This method will be called again from doReadData or doWriteData.
-	}
-	else
-	{
-		[self closeWithError:[self sslError:status]];
-	}
-}
-
-- (void)ssl_shouldTrustPeer:(BOOL)shouldTrust stateIndex:(int)aStateIndex
-{
-	LogTrace();
-	
-	if (aStateIndex != stateIndex)
-	{
-		LogInfo(@"Ignoring ssl_shouldTrustPeer - invalid state (maybe disconnected)");
-		
-		// One of the following is true
-		// - the socket was disconnected
-		// - the startTLS operation timed out
-		// - the completionHandler was already invoked once
-		
-		return;
-	}
-	
-	// Increment stateIndex to ensure completionHandler can only be called once.
-	stateIndex++;
-	
-	if (shouldTrust)
-	{
-        NSAssert(lastSSLHandshakeError == errSSLPeerAuthCompleted, @"ssl_shouldTrustPeer called when last error is %d and not errSSLPeerAuthCompleted", (int)lastSSLHandshakeError);
-		[self ssl_continueSSLHandshake];
-	}
-	else
-	{
-		[self closeWithError:[self sslError:errSSLPeerBadCert]];
-	}
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Security via CFStream
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-#if TARGET_OS_IPHONE
-
-- (void)cf_finishSSLHandshake
-{
-	LogTrace();
-	
-	if ((flags & kStartingReadTLS) && (flags & kStartingWriteTLS))
-	{
-		flags &= ~kStartingReadTLS;
-		flags &= ~kStartingWriteTLS;
-		
-		flags |= kSocketSecure;
-		
-		__strong id theDelegate = delegate;
-
-		if (delegateQueue && [theDelegate respondsToSelector:@selector(socketDidSecure:)])
-		{
-			dispatch_async(delegateQueue, ^{ @autoreleasepool {
-				
-				[theDelegate socketDidSecure:self];
-			}});
-		}
-		
-		[self endCurrentRead];
-		[self endCurrentWrite];
-		
-		[self maybeDequeueRead];
-		[self maybeDequeueWrite];
-	}
-}
-
-- (void)cf_abortSSLHandshake:(NSError *)error
-{
-	LogTrace();
-	
-	if ((flags & kStartingReadTLS) && (flags & kStartingWriteTLS))
-	{
-		flags &= ~kStartingReadTLS;
-		flags &= ~kStartingWriteTLS;
-		
-		[self closeWithError:error];
-	}
-}
-
-- (void)cf_startTLS
-{
-	LogTrace();
-	
-	LogVerbose(@"Starting TLS (via CFStream)...");
-	
-	if ([preBuffer availableBytes] > 0)
-	{
-		NSString *msg = @"Invalid TLS transition. Handshake has already been read from socket.";
-		
-		[self closeWithError:[self otherError:msg]];
-		return;
-	}
-	
-	[self suspendReadSource];
-	[self suspendWriteSource];
-	
-	socketFDBytesAvailable = 0;
-	flags &= ~kSocketCanAcceptBytes;
-	flags &= ~kSecureSocketHasBytesAvailable;
-	
-	flags |=  kUsingCFStreamForTLS;
-	
-	if (![self createReadAndWriteStream])
-	{
-		[self closeWithError:[self otherError:@"Error in CFStreamCreatePairWithSocket"]];
-		return;
-	}
-	
-	if (![self registerForStreamCallbacksIncludingReadWrite:YES])
-	{
-		[self closeWithError:[self otherError:@"Error in CFStreamSetClient"]];
-		return;
-	}
-	
-	if (![self addStreamsToRunLoop])
-	{
-		[self closeWithError:[self otherError:@"Error in CFStreamScheduleWithRunLoop"]];
-		return;
-	}
-	
-	NSAssert([currentRead isKindOfClass:[GCDAsyncSpecialPacket class]], @"Invalid read packet for startTLS");
-	NSAssert([currentWrite isKindOfClass:[GCDAsyncSpecialPacket class]], @"Invalid write packet for startTLS");
-	
-	GCDAsyncSpecialPacket *tlsPacket = (GCDAsyncSpecialPacket *)currentRead;
-	CFDictionaryRef tlsSettings = (__bridge CFDictionaryRef)tlsPacket->tlsSettings;
-	
-	// Getting an error concerning kCFStreamPropertySSLSettings ?
-	// You need to add the CFNetwork framework to your iOS application.
-	
-	BOOL r1 = CFReadStreamSetProperty(readStream, kCFStreamPropertySSLSettings, tlsSettings);
-	BOOL r2 = CFWriteStreamSetProperty(writeStream, kCFStreamPropertySSLSettings, tlsSettings);
-	
-	// For some reason, starting around the time of iOS 4.3,
-	// the first call to set the kCFStreamPropertySSLSettings will return true,
-	// but the second will return false.
-	// 
-	// Order doesn't seem to matter.
-	// So you could call CFReadStreamSetProperty and then CFWriteStreamSetProperty, or you could reverse the order.
-	// Either way, the first call will return true, and the second returns false.
-	// 
-	// Interestingly, this doesn't seem to affect anything.
-	// Which is not altogether unusual, as the documentation seems to suggest that (for many settings)
-	// setting it on one side of the stream automatically sets it for the other side of the stream.
-	// 
-	// Although there isn't anything in the documentation to suggest that the second attempt would fail.
-	// 
-	// Furthermore, this only seems to affect streams that are negotiating a security upgrade.
-	// In other words, the socket gets connected, there is some back-and-forth communication over the unsecure
-	// connection, and then a startTLS is issued.
-	// So this mostly affects newer protocols (XMPP, IMAP) as opposed to older protocols (HTTPS).
-	
-	if (!r1 && !r2) // Yes, the && is correct - workaround for apple bug.
-	{
-		[self closeWithError:[self otherError:@"Error in CFStreamSetProperty"]];
-		return;
-	}
-	
-	if (![self openStreams])
-	{
-		[self closeWithError:[self otherError:@"Error in CFStreamOpen"]];
-		return;
-	}
-	
-	LogVerbose(@"Waiting for SSL Handshake to complete...");
-}
-
-#endif
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark CFStream
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-#if TARGET_OS_IPHONE
-
-+ (void)ignore:(id)_
-{}
-
-+ (void)startCFStreamThreadIfNeeded
-{
-	LogTrace();
-	
-	static dispatch_once_t predicate;
-	dispatch_once(&predicate, ^{
-		
-		cfstreamThreadRetainCount = 0;
-		cfstreamThreadSetupQueue = dispatch_queue_create("GCDAsyncSocket-CFStreamThreadSetup", DISPATCH_QUEUE_SERIAL);
-	});
-	
-	dispatch_sync(cfstreamThreadSetupQueue, ^{ @autoreleasepool {
-		
-		if (++cfstreamThreadRetainCount == 1)
-		{
-			cfstreamThread = [[NSThread alloc] initWithTarget:self
-			                                         selector:@selector(cfstreamThread)
-			                                           object:nil];
-			[cfstreamThread start];
-		}
-	}});
-}
-
-+ (void)stopCFStreamThreadIfNeeded
-{
-	LogTrace();
-	
-	// The creation of the cfstreamThread is relatively expensive.
-	// So we'd like to keep it available for recycling.
-	// However, there's a tradeoff here, because it shouldn't remain alive forever.
-	// So what we're going to do is use a little delay before taking it down.
-	// This way it can be reused properly in situations where multiple sockets are continually in flux.
-	
-	int delayInSeconds = 30;
-	dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
-	dispatch_after(when, cfstreamThreadSetupQueue, ^{ @autoreleasepool {
-	#pragma clang diagnostic push
-	#pragma clang diagnostic warning "-Wimplicit-retain-self"
-		
-		if (cfstreamThreadRetainCount == 0)
-		{
-			LogWarn(@"Logic error concerning cfstreamThread start / stop");
-			return_from_block;
-		}
-		
-		if (--cfstreamThreadRetainCount == 0)
-		{
-			[cfstreamThread cancel]; // set isCancelled flag
-			
-			// wake up the thread
-            [[self class] performSelector:@selector(ignore:)
-                                 onThread:cfstreamThread
-                               withObject:[NSNull null]
-                            waitUntilDone:NO];
-            
-			cfstreamThread = nil;
-		}
-		
-	#pragma clang diagnostic pop
-	}});
-}
-
-+ (void)cfstreamThread { @autoreleasepool
-{
-	[[NSThread currentThread] setName:GCDAsyncSocketThreadName];
-	
-	LogInfo(@"CFStreamThread: Started");
-	
-	// We can't run the run loop unless it has an associated input source or a timer.
-	// So we'll just create a timer that will never fire - unless the server runs for decades.
-	[NSTimer scheduledTimerWithTimeInterval:[[NSDate distantFuture] timeIntervalSinceNow]
-	                                 target:self
-	                               selector:@selector(ignore:)
-	                               userInfo:nil
-	                                repeats:YES];
-	
-	NSThread *currentThread = [NSThread currentThread];
-	NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];
-	
-	BOOL isCancelled = [currentThread isCancelled];
-	
-	while (!isCancelled && [currentRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]])
-	{
-		isCancelled = [currentThread isCancelled];
-	}
-	
-	LogInfo(@"CFStreamThread: Stopped");
-}}
-
-+ (void)scheduleCFStreams:(GCDAsyncSocket *)asyncSocket
-{
-	LogTrace();
-	NSAssert([NSThread currentThread] == cfstreamThread, @"Invoked on wrong thread");
-	
-	CFRunLoopRef runLoop = CFRunLoopGetCurrent();
-	
-	if (asyncSocket->readStream)
-		CFReadStreamScheduleWithRunLoop(asyncSocket->readStream, runLoop, kCFRunLoopDefaultMode);
-	
-	if (asyncSocket->writeStream)
-		CFWriteStreamScheduleWithRunLoop(asyncSocket->writeStream, runLoop, kCFRunLoopDefaultMode);
-}
-
-+ (void)unscheduleCFStreams:(GCDAsyncSocket *)asyncSocket
-{
-	LogTrace();
-	NSAssert([NSThread currentThread] == cfstreamThread, @"Invoked on wrong thread");
-	
-	CFRunLoopRef runLoop = CFRunLoopGetCurrent();
-	
-	if (asyncSocket->readStream)
-		CFReadStreamUnscheduleFromRunLoop(asyncSocket->readStream, runLoop, kCFRunLoopDefaultMode);
-	
-	if (asyncSocket->writeStream)
-		CFWriteStreamUnscheduleFromRunLoop(asyncSocket->writeStream, runLoop, kCFRunLoopDefaultMode);
-}
-
-static void CFReadStreamCallback (CFReadStreamRef stream, CFStreamEventType type, void *pInfo)
-{
-	GCDAsyncSocket *asyncSocket = (__bridge GCDAsyncSocket *)pInfo;
-	
-	switch(type)
-	{
-		case kCFStreamEventHasBytesAvailable:
-		{
-			dispatch_async(asyncSocket->socketQueue, ^{ @autoreleasepool {
-				
-				LogCVerbose(@"CFReadStreamCallback - HasBytesAvailable");
-				
-				if (asyncSocket->readStream != stream)
-					return_from_block;
-				
-				if ((asyncSocket->flags & kStartingReadTLS) && (asyncSocket->flags & kStartingWriteTLS))
-				{
-					// If we set kCFStreamPropertySSLSettings before we opened the streams, this might be a lie.
-					// (A callback related to the tcp stream, but not to the SSL layer).
-					
-					if (CFReadStreamHasBytesAvailable(asyncSocket->readStream))
-					{
-						asyncSocket->flags |= kSecureSocketHasBytesAvailable;
-						[asyncSocket cf_finishSSLHandshake];
-					}
-				}
-				else
-				{
-					asyncSocket->flags |= kSecureSocketHasBytesAvailable;
-					[asyncSocket doReadData];
-				}
-			}});
-			
-			break;
-		}
-		default:
-		{
-			NSError *error = (__bridge_transfer  NSError *)CFReadStreamCopyError(stream);
-			
-			if (error == nil && type == kCFStreamEventEndEncountered)
-			{
-				error = [asyncSocket connectionClosedError];
-			}
-			
-			dispatch_async(asyncSocket->socketQueue, ^{ @autoreleasepool {
-				
-				LogCVerbose(@"CFReadStreamCallback - Other");
-				
-				if (asyncSocket->readStream != stream)
-					return_from_block;
-				
-				if ((asyncSocket->flags & kStartingReadTLS) && (asyncSocket->flags & kStartingWriteTLS))
-				{
-					[asyncSocket cf_abortSSLHandshake:error];
-				}
-				else
-				{
-					[asyncSocket closeWithError:error];
-				}
-			}});
-			
-			break;
-		}
-	}
-	
-}
-
-static void CFWriteStreamCallback (CFWriteStreamRef stream, CFStreamEventType type, void *pInfo)
-{
-	GCDAsyncSocket *asyncSocket = (__bridge GCDAsyncSocket *)pInfo;
-	
-	switch(type)
-	{
-		case kCFStreamEventCanAcceptBytes:
-		{
-			dispatch_async(asyncSocket->socketQueue, ^{ @autoreleasepool {
-				
-				LogCVerbose(@"CFWriteStreamCallback - CanAcceptBytes");
-				
-				if (asyncSocket->writeStream != stream)
-					return_from_block;
-				
-				if ((asyncSocket->flags & kStartingReadTLS) && (asyncSocket->flags & kStartingWriteTLS))
-				{
-					// If we set kCFStreamPropertySSLSettings before we opened the streams, this might be a lie.
-					// (A callback related to the tcp stream, but not to the SSL layer).
-					
-					if (CFWriteStreamCanAcceptBytes(asyncSocket->writeStream))
-					{
-						asyncSocket->flags |= kSocketCanAcceptBytes;
-						[asyncSocket cf_finishSSLHandshake];
-					}
-				}
-				else
-				{
-					asyncSocket->flags |= kSocketCanAcceptBytes;
-					[asyncSocket doWriteData];
-				}
-			}});
-			
-			break;
-		}
-		default:
-		{
-			NSError *error = (__bridge_transfer NSError *)CFWriteStreamCopyError(stream);
-			
-			if (error == nil && type == kCFStreamEventEndEncountered)
-			{
-				error = [asyncSocket connectionClosedError];
-			}
-			
-			dispatch_async(asyncSocket->socketQueue, ^{ @autoreleasepool {
-				
-				LogCVerbose(@"CFWriteStreamCallback - Other");
-				
-				if (asyncSocket->writeStream != stream)
-					return_from_block;
-				
-				if ((asyncSocket->flags & kStartingReadTLS) && (asyncSocket->flags & kStartingWriteTLS))
-				{
-					[asyncSocket cf_abortSSLHandshake:error];
-				}
-				else
-				{
-					[asyncSocket closeWithError:error];
-				}
-			}});
-			
-			break;
-		}
-	}
-	
-}
-
-- (BOOL)createReadAndWriteStream
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	
-	
-	if (readStream || writeStream)
-	{
-		// Streams already created
-		return YES;
-	}
-	
-	int socketFD = (socket4FD != SOCKET_NULL) ? socket4FD : (socket6FD != SOCKET_NULL) ? socket6FD : socketUN;
-	
-	if (socketFD == SOCKET_NULL)
-	{
-		// Cannot create streams without a file descriptor
-		return NO;
-	}
-	
-	if (![self isConnected])
-	{
-		// Cannot create streams until file descriptor is connected
-		return NO;
-	}
-	
-	LogVerbose(@"Creating read and write stream...");
-	
-	CFStreamCreatePairWithSocket(NULL, (CFSocketNativeHandle)socketFD, &readStream, &writeStream);
-	
-	// The kCFStreamPropertyShouldCloseNativeSocket property should be false by default (for our case).
-	// But let's not take any chances.
-	
-	if (readStream)
-		CFReadStreamSetProperty(readStream, kCFStreamPropertyShouldCloseNativeSocket, kCFBooleanFalse);
-	if (writeStream)
-		CFWriteStreamSetProperty(writeStream, kCFStreamPropertyShouldCloseNativeSocket, kCFBooleanFalse);
-	
-	if ((readStream == NULL) || (writeStream == NULL))
-	{
-		LogWarn(@"Unable to create read and write stream...");
-		
-		if (readStream)
-		{
-			CFReadStreamClose(readStream);
-			CFRelease(readStream);
-			readStream = NULL;
-		}
-		if (writeStream)
-		{
-			CFWriteStreamClose(writeStream);
-			CFRelease(writeStream);
-			writeStream = NULL;
-		}
-		
-		return NO;
-	}
-	
-	return YES;
-}
-
-- (BOOL)registerForStreamCallbacksIncludingReadWrite:(BOOL)includeReadWrite
-{
-	LogVerbose(@"%@ %@", THIS_METHOD, (includeReadWrite ? @"YES" : @"NO"));
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	NSAssert((readStream != NULL && writeStream != NULL), @"Read/Write stream is null");
-	
-	streamContext.version = 0;
-	streamContext.info = (__bridge void *)(self);
-	streamContext.retain = nil;
-	streamContext.release = nil;
-	streamContext.copyDescription = nil;
-	
-	CFOptionFlags readStreamEvents = kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered;
-	if (includeReadWrite)
-		readStreamEvents |= kCFStreamEventHasBytesAvailable;
-	
-	if (!CFReadStreamSetClient(readStream, readStreamEvents, &CFReadStreamCallback, &streamContext))
-	{
-		return NO;
-	}
-	
-	CFOptionFlags writeStreamEvents = kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered;
-	if (includeReadWrite)
-		writeStreamEvents |= kCFStreamEventCanAcceptBytes;
-	
-	if (!CFWriteStreamSetClient(writeStream, writeStreamEvents, &CFWriteStreamCallback, &streamContext))
-	{
-		return NO;
-	}
-	
-	return YES;
-}
-
-- (BOOL)addStreamsToRunLoop
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	NSAssert((readStream != NULL && writeStream != NULL), @"Read/Write stream is null");
-	
-	if (!(flags & kAddedStreamsToRunLoop))
-	{
-		LogVerbose(@"Adding streams to runloop...");
-		
-		[[self class] startCFStreamThreadIfNeeded];
-		[[self class] performSelector:@selector(scheduleCFStreams:)
-		                     onThread:cfstreamThread
-		                   withObject:self
-		                waitUntilDone:YES];
-		
-		flags |= kAddedStreamsToRunLoop;
-	}
-	
-	return YES;
-}
-
-- (void)removeStreamsFromRunLoop
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	NSAssert((readStream != NULL && writeStream != NULL), @"Read/Write stream is null");
-	
-	if (flags & kAddedStreamsToRunLoop)
-	{
-		LogVerbose(@"Removing streams from runloop...");
-		
-		[[self class] performSelector:@selector(unscheduleCFStreams:)
-		                     onThread:cfstreamThread
-		                   withObject:self
-		                waitUntilDone:YES];
-		[[self class] stopCFStreamThreadIfNeeded];
-		
-		flags &= ~kAddedStreamsToRunLoop;
-	}
-}
-
-- (BOOL)openStreams
-{
-	LogTrace();
-	
-	NSAssert(dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey), @"Must be dispatched on socketQueue");
-	NSAssert((readStream != NULL && writeStream != NULL), @"Read/Write stream is null");
-	
-	CFStreamStatus readStatus = CFReadStreamGetStatus(readStream);
-	CFStreamStatus writeStatus = CFWriteStreamGetStatus(writeStream);
-	
-	if ((readStatus == kCFStreamStatusNotOpen) || (writeStatus == kCFStreamStatusNotOpen))
-	{
-		LogVerbose(@"Opening read and write stream...");
-		
-		BOOL r1 = CFReadStreamOpen(readStream);
-		BOOL r2 = CFWriteStreamOpen(writeStream);
-		
-		if (!r1 || !r2)
-		{
-			LogError(@"Error in CFStreamOpen");
-			return NO;
-		}
-	}
-	
-	return YES;
-}
-
-#endif
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Advanced
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/**
- * See header file for big discussion of this method.
-**/
-- (BOOL)autoDisconnectOnClosedReadStream
-{
-	// Note: YES means kAllowHalfDuplexConnection is OFF
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		return ((config & kAllowHalfDuplexConnection) == 0);
-	}
-	else
-	{
-		__block BOOL result;
-		
-		dispatch_sync(socketQueue, ^{
-			result = ((config & kAllowHalfDuplexConnection) == 0);
-		});
-		
-		return result;
-	}
-}
-
-/**
- * See header file for big discussion of this method.
-**/
-- (void)setAutoDisconnectOnClosedReadStream:(BOOL)flag
-{
-	// Note: YES means kAllowHalfDuplexConnection is OFF
-	
-	dispatch_block_t block = ^{
-		
-		if (flag)
-			config &= ~kAllowHalfDuplexConnection;
-		else
-			config |= kAllowHalfDuplexConnection;
-	};
-	
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_async(socketQueue, block);
-}
-
-
-/**
- * See header file for big discussion of this method.
-**/
-- (void)markSocketQueueTargetQueue:(dispatch_queue_t)socketNewTargetQueue
-{
-	void *nonNullUnusedPointer = (__bridge void *)self;
-	dispatch_queue_set_specific(socketNewTargetQueue, IsOnSocketQueueOrTargetQueueKey, nonNullUnusedPointer, NULL);
-}
-
-/**
- * See header file for big discussion of this method.
-**/
-- (void)unmarkSocketQueueTargetQueue:(dispatch_queue_t)socketOldTargetQueue
-{
-	dispatch_queue_set_specific(socketOldTargetQueue, IsOnSocketQueueOrTargetQueueKey, NULL, NULL);
-}
-
-/**
- * See header file for big discussion of this method.
-**/
-- (void)performBlock:(dispatch_block_t)block
-{
-	if (dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-		block();
-	else
-		dispatch_sync(socketQueue, block);
-}
-
-/**
- * Questions? Have you read the header file?
-**/
-- (int)socketFD
-{
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return SOCKET_NULL;
-	}
-	
-	if (socket4FD != SOCKET_NULL)
-		return socket4FD;
-	else
-		return socket6FD;
-}
-
-/**
- * Questions? Have you read the header file?
-**/
-- (int)socket4FD
-{
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return SOCKET_NULL;
-	}
-	
-	return socket4FD;
-}
-
-/**
- * Questions? Have you read the header file?
-**/
-- (int)socket6FD
-{
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return SOCKET_NULL;
-	}
-	
-	return socket6FD;
-}
-
-#if TARGET_OS_IPHONE
-
-/**
- * Questions? Have you read the header file?
-**/
-- (CFReadStreamRef)readStream
-{
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return NULL;
-	}
-	
-	if (readStream == NULL)
-		[self createReadAndWriteStream];
-	
-	return readStream;
-}
-
-/**
- * Questions? Have you read the header file?
-**/
-- (CFWriteStreamRef)writeStream
-{
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return NULL;
-	}
-	
-	if (writeStream == NULL)
-		[self createReadAndWriteStream];
-	
-	return writeStream;
-}
-
-- (BOOL)enableBackgroundingOnSocketWithCaveat:(BOOL)caveat
-{
-	if (![self createReadAndWriteStream])
-	{
-		// Error occurred creating streams (perhaps socket isn't open)
-		return NO;
-	}
-	
-	BOOL r1, r2;
-	
-	LogVerbose(@"Enabling backgrouding on socket");
-	
-	r1 = CFReadStreamSetProperty(readStream, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);
-	r2 = CFWriteStreamSetProperty(writeStream, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);
-	
-	if (!r1 || !r2)
-	{
-		return NO;
-	}
-	
-	if (!caveat)
-	{
-		if (![self openStreams])
-		{
-			return NO;
-		}
-	}
-	
-	return YES;
-}
-
-/**
- * Questions? Have you read the header file?
-**/
-- (BOOL)enableBackgroundingOnSocket
-{
-	LogTrace();
-	
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return NO;
-	}
-	
-	return [self enableBackgroundingOnSocketWithCaveat:NO];
-}
-
-- (BOOL)enableBackgroundingOnSocketWithCaveat // Deprecated in iOS 4.???
-{
-	// This method was created as a workaround for a bug in iOS.
-	// Apple has since fixed this bug.
-	// I'm not entirely sure which version of iOS they fixed it in...
-	
-	LogTrace();
-	
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return NO;
-	}
-	
-	return [self enableBackgroundingOnSocketWithCaveat:YES];
-}
-
-#endif
-
-- (SSLContextRef)sslContext
-{
-	if (!dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey))
-	{
-		LogWarn(@"%@ - Method only available from within the context of a performBlock: invocation", THIS_METHOD);
-		return NULL;
-	}
-	
-	return sslContext;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-#pragma mark Class Utilities
-////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-+ (NSMutableArray *)lookupHost:(NSString *)host port:(uint16_t)port error:(NSError **)errPtr
-{
-	LogTrace();
-	
-	NSMutableArray *addresses = nil;
-	NSError *error = nil;
-	
-	if ([host isEqualToString:@"localhost"] || [host isEqualToString:@"loopback"])
-	{
-		// Use LOOPBACK address
-		struct sockaddr_in nativeAddr4;
-		nativeAddr4.sin_len         = sizeof(struct sockaddr_in);
-		nativeAddr4.sin_family      = AF_INET;
-		nativeAddr4.sin_port        = htons(port);
-		nativeAddr4.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-		memset(&(nativeAddr4.sin_zero), 0, sizeof(nativeAddr4.sin_zero));
-		
-		struct sockaddr_in6 nativeAddr6;
-		nativeAddr6.sin6_len        = sizeof(struct sockaddr_in6);
-		nativeAddr6.sin6_family     = AF_INET6;
-		nativeAddr6.sin6_port       = htons(port);
-		nativeAddr6.sin6_flowinfo   = 0;
-		nativeAddr6.sin6_addr       = in6addr_loopback;
-		nativeAddr6.sin6_scope_id   = 0;
-		
-		// Wrap the native address structures
-		
-		NSData *address4 = [NSData dataWithBytes:&nativeAddr4 length:sizeof(nativeAddr4)];
-		NSData *address6 = [NSData dataWithBytes:&nativeAddr6 length:sizeof(nativeAddr6)];
-		
-		addresses = [NSMutableArray arrayWithCapacity:2];
-		[addresses addObject:address4];
-		[addresses addObject:address6];
-	}
-	else
-	{
-		NSString *portStr = [NSString stringWithFormat:@"%hu", port];
-		
-		struct addrinfo hints, *res, *res0;
-		
-		memset(&hints, 0, sizeof(hints));
-		hints.ai_family   = PF_UNSPEC;
-		hints.ai_socktype = SOCK_STREAM;
-		hints.ai_protocol = IPPROTO_TCP;
-		
-		int gai_error = getaddrinfo([host UTF8String], [portStr UTF8String], &hints, &res0);
-		
-		if (gai_error)
-		{
-			error = [self gaiError:gai_error];
-		}
-		else
-		{
-			NSUInteger capacity = 0;
-			for (res = res0; res; res = res->ai_next)
-			{
-				if (res->ai_family == AF_INET || res->ai_family == AF_INET6) {
-					capacity++;
-				}
-			}
-			
-			addresses = [NSMutableArray arrayWithCapacity:capacity];
-			
-			for (res = res0; res; res = res->ai_next)
-			{
-				if (res->ai_family == AF_INET)
-				{
-					// Found IPv4 address.
-					// Wrap the native address structure, and add to results.
-					
-					NSData *address4 = [NSData dataWithBytes:res->ai_addr length:res->ai_addrlen];
-					[addresses addObject:address4];
-				}
-				else if (res->ai_family == AF_INET6)
-				{
-					// Fixes connection issues with IPv6
-					// https://github.com/robbiehanson/CocoaAsyncSocket/issues/429#issuecomment-222477158
-					
-					// Found IPv6 address.
-					// Wrap the native address structure, and add to results.
-					
-					struct sockaddr_in6 *sockaddr = (struct sockaddr_in6 *)res->ai_addr;
-					in_port_t *portPtr = &sockaddr->sin6_port;
-					if ((portPtr != NULL) && (*portPtr == 0)) {
-					        *portPtr = htons(port);
-					}
-
-					NSData *address6 = [NSData dataWithBytes:res->ai_addr length:res->ai_addrlen];
-					[addresses addObject:address6];
-				}
-			}
-			freeaddrinfo(res0);
-			
-			if ([addresses count] == 0)
-			{
-				error = [self gaiError:EAI_FAIL];
-			}
-		}
-	}
-	
-	if (errPtr) *errPtr = error;
-	return addresses;
-}
-
-+ (NSString *)hostFromSockaddr4:(const struct sockaddr_in *)pSockaddr4
-{
-	char addrBuf[INET_ADDRSTRLEN];
-	
-	if (inet_ntop(AF_INET, &pSockaddr4->sin_addr, addrBuf, (socklen_t)sizeof(addrBuf)) == NULL)
-	{
-		addrBuf[0] = '\0';
-	}
-	
-	return [NSString stringWithCString:addrBuf encoding:NSASCIIStringEncoding];
-}
-
-+ (NSString *)hostFromSockaddr6:(const struct sockaddr_in6 *)pSockaddr6
-{
-	char addrBuf[INET6_ADDRSTRLEN];
-	
-	if (inet_ntop(AF_INET6, &pSockaddr6->sin6_addr, addrBuf, (socklen_t)sizeof(addrBuf)) == NULL)
-	{
-		addrBuf[0] = '\0';
-	}
-	
-	return [NSString stringWithCString:addrBuf encoding:NSASCIIStringEncoding];
-}
-
-+ (uint16_t)portFromSockaddr4:(const struct sockaddr_in *)pSockaddr4
-{
-	return ntohs(pSockaddr4->sin_port);
-}
-
-+ (uint16_t)portFromSockaddr6:(const struct sockaddr_in6 *)pSockaddr6
-{
-	return ntohs(pSockaddr6->sin6_port);
-}
-
-+ (NSURL *)urlFromSockaddrUN:(const struct sockaddr_un *)pSockaddr
-{
-	NSString *path = [NSString stringWithUTF8String:pSockaddr->sun_path];
-	return [NSURL fileURLWithPath:path];
-}
-
-+ (NSString *)hostFromAddress:(NSData *)address
-{
-	NSString *host;
-	
-	if ([self getHost:&host port:NULL fromAddress:address])
-		return host;
-	else
-		return nil;
-}
-
-+ (uint16_t)portFromAddress:(NSData *)address
-{
-	uint16_t port;
-	
-	if ([self getHost:NULL port:&port fromAddress:address])
-		return port;
-	else
-		return 0;
-}
-
-+ (BOOL)isIPv4Address:(NSData *)address
-{
-	if ([address length] >= sizeof(struct sockaddr))
-	{
-		const struct sockaddr *sockaddrX = [address bytes];
-		
-		if (sockaddrX->sa_family == AF_INET) {
-			return YES;
-		}
-	}
-	
-	return NO;
-}
-
-+ (BOOL)isIPv6Address:(NSData *)address
-{
-	if ([address length] >= sizeof(struct sockaddr))
-	{
-		const struct sockaddr *sockaddrX = [address bytes];
-		
-		if (sockaddrX->sa_family == AF_INET6) {
-			return YES;
-		}
-	}
-	
-	return NO;
-}
-
-+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr fromAddress:(NSData *)address
-{
-	return [self getHost:hostPtr port:portPtr family:NULL fromAddress:address];
-}
-
-+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr family:(sa_family_t *)afPtr fromAddress:(NSData *)address
-{
-	if ([address length] >= sizeof(struct sockaddr))
-	{
-		const struct sockaddr *sockaddrX = [address bytes];
-		
-		if (sockaddrX->sa_family == AF_INET)
-		{
-			if ([address length] >= sizeof(struct sockaddr_in))
-			{
-				struct sockaddr_in sockaddr4;
-				memcpy(&sockaddr4, sockaddrX, sizeof(sockaddr4));
-				
-				if (hostPtr) *hostPtr = [self hostFromSockaddr4:&sockaddr4];
-				if (portPtr) *portPtr = [self portFromSockaddr4:&sockaddr4];
-				if (afPtr)   *afPtr   = AF_INET;
-				
-				return YES;
-			}
-		}
-		else if (sockaddrX->sa_family == AF_INET6)
-		{
-			if ([address length] >= sizeof(struct sockaddr_in6))
-			{
-				struct sockaddr_in6 sockaddr6;
-				memcpy(&sockaddr6, sockaddrX, sizeof(sockaddr6));
-				
-				if (hostPtr) *hostPtr = [self hostFromSockaddr6:&sockaddr6];
-				if (portPtr) *portPtr = [self portFromSockaddr6:&sockaddr6];
-				if (afPtr)   *afPtr   = AF_INET6;
-				
-				return YES;
-			}
-		}
-	}
-	
-	return NO;
-}
-
-+ (NSData *)CRLFData
-{
-	return [NSData dataWithBytes:"\x0D\x0A" length:2];
-}
-
-+ (NSData *)CRData
-{
-	return [NSData dataWithBytes:"\x0D" length:1];
-}
-
-+ (NSData *)LFData
-{
-	return [NSData dataWithBytes:"\x0A" length:1];
-}
-
-+ (NSData *)ZeroData
-{
-	return [NSData dataWithBytes:"" length:1];
-}
-
-@end	
diff --git a/node_modules/react-native-tcp/ios/TcpSocketClient.h b/node_modules/react-native-tcp/ios/TcpSocketClient.h
index 6b1de9d..4f74b78 100644
--- a/node_modules/react-native-tcp/ios/TcpSocketClient.h
+++ b/node_modules/react-native-tcp/ios/TcpSocketClient.h
@@ -4,7 +4,7 @@
  */
 
 #import <React/RCTBridgeModule.h>
-#import "CocoaAsyncSocket/GCDAsyncSocket.h"
+#import "GCDAsyncSocket.h"
 
 extern NSString *const RCTTCPErrorDomain;
 
diff --git a/node_modules/react-native-tcp/ios/TcpSockets.h b/node_modules/react-native-tcp/ios/TcpSockets.h
index 47ba018..e7781b4 100644
--- a/node_modules/react-native-tcp/ios/TcpSockets.h
+++ b/node_modules/react-native-tcp/ios/TcpSockets.h
@@ -6,7 +6,7 @@
 #import "TcpSocketClient.h"
 
 #import <React/RCTEventEmitter.h>
-#import "CocoaAsyncSocket/GCDAsyncSocket.h"
+#import "GCDAsyncSocket.h"
 
 @interface TcpSockets : RCTEventEmitter<SocketClientDelegate>
 
diff --git a/node_modules/react-native-tcp/ios/TcpSockets.xcodeproj/project.pbxproj b/node_modules/react-native-tcp/ios/TcpSockets.xcodeproj/project.pbxproj
index 92a2b8b..5f3b485 100644
--- a/node_modules/react-native-tcp/ios/TcpSockets.xcodeproj/project.pbxproj
+++ b/node_modules/react-native-tcp/ios/TcpSockets.xcodeproj/project.pbxproj
@@ -64,20 +64,10 @@
 				7350006A1AFF9AB600ED3C82 /* TcpSocketClient.m */,
 				13BE3DEC1AC21097009241FE /* TcpSockets.h */,
 				13BE3DED1AC21097009241FE /* TcpSockets.m */,
-				96EDB0A91C10C33B00D41E94 /* CocoaAsyncSocket */,
 				134814211AA4EA7D00B7C361 /* Products */,
 			);
 			sourceTree = "<group>";
 		};
-		96EDB0A91C10C33B00D41E94 /* CocoaAsyncSocket */ = {
-			isa = PBXGroup;
-			children = (
-				96EDB0AA1C10C33B00D41E94 /* GCDAsyncSocket.h */,
-				96EDB0AB1C10C33B00D41E94 /* GCDAsyncSocket.m */,
-			);
-			path = CocoaAsyncSocket;
-			sourceTree = "<group>";
-		};
 /* End PBXGroup section */
 
 /* Begin PBXNativeTarget section */
