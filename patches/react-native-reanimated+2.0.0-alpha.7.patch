diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/.DS_Store b/node_modules/react-native-reanimated/react-native-reanimated/Common/.DS_Store
new file mode 100644
index 0000000..9104602
Binary files /dev/null and b/node_modules/react-native-reanimated/react-native-reanimated/Common/.DS_Store differ
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/.DS_Store b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/.DS_Store
new file mode 100644
index 0000000..c4c3959
Binary files /dev/null and b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/.DS_Store differ
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModule.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModule.cpp
new file mode 100644
index 0000000..ae75ee5
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModule.cpp
@@ -0,0 +1,254 @@
+#include "NativeReanimatedModule.h"
+#include "Logger.h"
+#include "SpeedChecker.h"
+#include "ShareableValue.h"
+#include "MapperRegistry.h"
+#include "Mapper.h"
+#include "RuntimeDecorator.h"
+#include "EventHandlerRegistry.h"
+#include "EventHandler.h"
+#include "FrozenObject.h"
+#include <functional>
+#include <thread>
+#include <memory>
+#include "JSIStoreValueUser.h"
+
+using namespace facebook;
+
+namespace reanimated
+{
+
+void extractMutables(jsi::Runtime &rt,
+                     std::shared_ptr<ShareableValue> sv,
+                     std::vector<std::shared_ptr<MutableValue>> &res)
+{
+  switch (sv->type)
+  {
+  case ValueType::MutableValueType:
+    res.push_back(sv->mutableValue);
+    break;
+  case ValueType::ArrayType:
+    for (auto &it : sv->frozenArray)
+    {
+      extractMutables(rt, it, res);
+    }
+    break;
+  case ValueType::RemoteObjectType:
+  case ValueType::ObjectType:
+    for (auto &it : sv->frozenObject->map)
+    {
+      extractMutables(rt, it.second, res);
+    }
+    break;
+  default:
+    break;
+  }
+}
+
+std::vector<std::shared_ptr<MutableValue>> extractMutablesFromArray(jsi::Runtime &rt, const jsi::Array &array, NativeReanimatedModule *module)
+{
+  std::vector<std::shared_ptr<MutableValue>> res;
+  for (size_t i = 0, size = array.size(rt); i < size; i++)
+  {
+    auto shareable = ShareableValue::adapt(rt, array.getValueAtIndex(rt, i), module);
+    extractMutables(rt, shareable, res);
+  }
+  return res;
+}
+
+NativeReanimatedModule::NativeReanimatedModule(std::shared_ptr<CallInvoker> jsInvoker,
+                                               std::shared_ptr<Scheduler> scheduler,
+                                               std::unique_ptr<jsi::Runtime> rt,
+                                               std::shared_ptr<ErrorHandler> errorHandler,
+                                               std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer,
+                                               PlatformDepMethodsHolder platformDepMethodsHolder) : NativeReanimatedModuleSpec(jsInvoker),
+                                                  runtime(std::move(rt)),
+                                                  mapperRegistry(new MapperRegistry()),
+                                                  eventHandlerRegistry(new EventHandlerRegistry()),
+                                                  requestRender(platformDepMethodsHolder.requestRender),
+                                                  propObtainer(propObtainer),
+                                                  errorHandler(errorHandler),
+                                                  workletsCache(new WorkletsCache()),
+                                                  scheduler(scheduler)
+{
+  auto requestAnimationFrame = [=](FrameCallback callback) {
+    frameCallbacks.push_back(callback);
+    maybeRequestRender();
+  };
+
+  RuntimeDecorator::addNativeObjects(*runtime,
+                                     platformDepMethodsHolder.updaterFunction,
+                                     requestAnimationFrame,
+                                     platformDepMethodsHolder.scrollToFunction,
+                                     platformDepMethodsHolder.measuringFunction);
+}
+
+bool NativeReanimatedModule::isUIRuntime(jsi::Runtime &rt)
+{
+  return runtime.get() == &rt;
+}
+
+bool NativeReanimatedModule::isHostRuntime(jsi::Runtime &rt)
+{
+  return !isUIRuntime(rt);
+}
+
+void NativeReanimatedModule::installCoreFunctions(jsi::Runtime &rt, const jsi::Value &valueSetter)
+{
+  this->valueSetter = ShareableValue::adapt(rt, valueSetter, this);
+}
+
+jsi::Value NativeReanimatedModule::makeShareable(jsi::Runtime &rt, const jsi::Value &value)
+{
+  return ShareableValue::adapt(rt, value, this)->getValue(rt);
+}
+
+jsi::Value NativeReanimatedModule::makeMutable(jsi::Runtime &rt, const jsi::Value &value)
+{
+  return ShareableValue::adapt(rt, value, this, ValueType::MutableValueType)->getValue(rt);
+}
+
+jsi::Value NativeReanimatedModule::makeRemote(jsi::Runtime &rt, const jsi::Value &value)
+{
+  return ShareableValue::adapt(rt, value, this, ValueType::RemoteObjectType)->getValue(rt);
+}
+
+jsi::Value NativeReanimatedModule::startMapper(jsi::Runtime &rt, const jsi::Value &worklet, const jsi::Value &inputs, const jsi::Value &outputs)
+{
+  static unsigned long MAPPER_ID = 1;
+
+  unsigned long newMapperId = MAPPER_ID++;
+  auto mapperShareable = ShareableValue::adapt(rt, worklet, this);
+  auto inputMutables = extractMutablesFromArray(rt, inputs.asObject(rt).asArray(rt), this);
+  auto outputMutables = extractMutablesFromArray(rt, outputs.asObject(rt).asArray(rt), this);
+
+  scheduler->scheduleOnUI([=] {
+    auto mapperFunction = mapperShareable->getValue(*runtime).asObject(*runtime).asFunction(*runtime);
+    auto mapper = std::make_shared<Mapper>(this, newMapperId, std::move(mapperFunction), inputMutables, outputMutables);
+    mapperRegistry->startMapper(mapper);
+    maybeRequestRender();
+  });
+
+  return jsi::Value((double)newMapperId);
+}
+
+void NativeReanimatedModule::stopMapper(jsi::Runtime &rt, const jsi::Value &mapperId)
+{
+  unsigned long id = mapperId.asNumber();
+  scheduler->scheduleOnUI([=] {
+    mapperRegistry->stopMapper(id);
+  });
+}
+
+jsi::Value NativeReanimatedModule::registerEventHandler(jsi::Runtime &rt, const jsi::Value &eventHash, const jsi::Value &worklet)
+{
+  static unsigned long EVENT_HANDLER_ID = 1;
+
+  unsigned long newRegistrationId = EVENT_HANDLER_ID++;
+  auto eventName = eventHash.asString(rt).utf8(rt);
+  auto handlerShareable = ShareableValue::adapt(rt, worklet, this);
+
+  scheduler->scheduleOnUI([=] {
+    auto handlerFunction = handlerShareable->getValue(*runtime).asObject(*runtime).asFunction(*runtime);
+    auto handler = std::make_shared<EventHandler>(newRegistrationId, eventName, std::move(handlerFunction));
+    eventHandlerRegistry->registerEventHandler(handler);
+  });
+
+  return jsi::Value((double)newRegistrationId);
+}
+
+void NativeReanimatedModule::unregisterEventHandler(jsi::Runtime &rt, const jsi::Value &registrationId)
+{
+  unsigned long id = registrationId.asNumber();
+  scheduler->scheduleOnUI([=] {
+    eventHandlerRegistry->unregisterEventHandler(id);
+  });
+}
+
+jsi::Value NativeReanimatedModule::getViewProp(jsi::Runtime &rt, const jsi::Value &viewTag, const jsi::Value &propName, const jsi::Value &callback)
+{
+
+  const int viewTagInt = (int)viewTag.asNumber();
+  std::string propNameStr = propName.asString(rt).utf8(rt);
+  jsi::Function fun = callback.getObject(rt).asFunction(rt);
+  std::shared_ptr<jsi::Function> funPtr(new jsi::Function(std::move(fun)));
+
+  scheduler->scheduleOnUI([&rt, viewTagInt, funPtr, this, propNameStr]() {
+    const jsi::String propNameValue = jsi::String::createFromUtf8(rt, propNameStr);
+    jsi::Value result = propObtainer(rt, viewTagInt, propNameValue);
+    std::string resultStr = result.asString(rt).utf8(rt);
+
+    scheduler->scheduleOnJS([&rt, resultStr, funPtr]() {
+      const jsi::String resultValue = jsi::String::createFromUtf8(rt, resultStr);
+      funPtr->call(rt, resultValue);
+    });
+  });
+
+  return jsi::Value::undefined();
+}
+
+void NativeReanimatedModule::onEvent(std::string eventName, std::string eventAsString)
+{
+   try
+    {
+      eventHandlerRegistry->processEvent(*runtime, eventName, eventAsString);
+      mapperRegistry->execute(*runtime);
+      if (mapperRegistry->needRunOnRender())
+      {
+        maybeRequestRender();
+      }
+    }
+    catch (...)
+    {
+      if (!errorHandler->raise())
+      {
+        throw;
+      }
+    }
+}
+
+void NativeReanimatedModule::maybeRequestRender()
+{
+  if (!renderRequested)
+  {
+    renderRequested = true;
+    requestRender([this](double timestampMs) {
+      this->renderRequested = false;
+      this->onRender(timestampMs);
+    });
+  }
+}
+
+void NativeReanimatedModule::onRender(double timestampMs)
+{
+  try
+  {
+    mapperRegistry->execute(*runtime);
+
+    std::vector<FrameCallback> callbacks = frameCallbacks;
+    frameCallbacks.clear();
+    for (auto callback : callbacks)
+    {
+      callback(timestampMs);
+    }
+
+    if (mapperRegistry->needRunOnRender())
+    {
+      maybeRequestRender();
+    }
+  }
+  catch (...)
+  {
+    if (!errorHandler->raise())
+    {
+      throw;
+    }
+  }
+}
+
+NativeReanimatedModule::~NativeReanimatedModule()
+{
+  StoreUser::clearStore();
+}
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModuleSpec.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModuleSpec.cpp
new file mode 100644
index 0000000..22927a7
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/NativeModules/NativeReanimatedModuleSpec.cpp
@@ -0,0 +1,121 @@
+#include "NativeReanimatedModuleSpec.h"
+
+namespace reanimated {
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_installCoreFunctions(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+    ->installCoreFunctions(rt, std::move(args[0]));
+  return jsi::Value::undefined();
+}
+
+// SharedValue
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_makeShareable(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  return static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+    ->makeShareable(rt, std::move(args[0]));
+}
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_makeMutable(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  return static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+    ->makeMutable(rt, std::move(args[0]));
+}
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_makeRemote(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  return static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+    ->makeRemote(rt, std::move(args[0]));
+}
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_startMapper(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  return static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+      ->startMapper(rt, std::move(args[0]), std::move(args[1]), std::move(args[2]));
+}
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_stopMapper(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+      ->stopMapper(rt, std::move(args[0]));
+  return jsi::Value::undefined();
+}
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_registerEventHandler(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  return static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+      ->registerEventHandler(rt, std::move(args[0]), std::move(args[1]));
+}
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_unregisterEventHandler(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+      ->unregisterEventHandler(rt, std::move(args[0]));
+  return jsi::Value::undefined();
+}
+
+static jsi::Value __hostFunction_NativeReanimatedModuleSpec_getViewProp(
+    jsi::Runtime &rt,
+    TurboModule &turboModule,
+    const jsi::Value *args,
+    size_t count) {
+  static_cast<NativeReanimatedModuleSpec *>(&turboModule)
+        ->getViewProp(rt, std::move(args[0]), std::move(args[1]), std::move(args[2]));
+    return jsi::Value::undefined();
+}
+
+NativeReanimatedModuleSpec::NativeReanimatedModuleSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule("NativeReanimated", jsInvoker) {
+  methodMap_["installCoreFunctions"] = MethodMetadata{
+    1, __hostFunction_NativeReanimatedModuleSpec_installCoreFunctions};
+
+
+  methodMap_["makeShareable"] = MethodMetadata{
+      1, __hostFunction_NativeReanimatedModuleSpec_makeShareable};
+  methodMap_["makeMutable"] = MethodMetadata{
+      1, __hostFunction_NativeReanimatedModuleSpec_makeMutable};
+  methodMap_["makeRemote"] = MethodMetadata{
+      1, __hostFunction_NativeReanimatedModuleSpec_makeRemote};
+      
+
+  methodMap_["startMapper"] = MethodMetadata{
+    3, __hostFunction_NativeReanimatedModuleSpec_startMapper};
+  methodMap_["stopMapper"] = MethodMetadata{
+    1, __hostFunction_NativeReanimatedModuleSpec_stopMapper};
+
+  methodMap_["registerEventHandler"] = MethodMetadata{
+    2, __hostFunction_NativeReanimatedModuleSpec_registerEventHandler};
+  methodMap_["unregisterEventHandler"] = MethodMetadata{
+    1, __hostFunction_NativeReanimatedModuleSpec_unregisterEventHandler};
+
+  methodMap_["getViewProp"] = MethodMetadata{
+    3, __hostFunction_NativeReanimatedModuleSpec_getViewProp};
+}
+
+}
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/EventHandlerRegistry.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/EventHandlerRegistry.cpp
new file mode 100644
index 0000000..eaaa071
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/EventHandlerRegistry.cpp
@@ -0,0 +1,34 @@
+#include "EventHandlerRegistry.h"
+#include "EventHandler.h"
+
+namespace reanimated {
+
+static jsi::Value eval(jsi::Runtime &rt, const char *code) {
+  return rt.global().getPropertyAsFunction(rt, "eval").call(rt, code);
+}
+
+void EventHandlerRegistry::registerEventHandler(std::shared_ptr<EventHandler> eventHandler) {
+  eventMappings[eventHandler->eventName][eventHandler->id] = eventHandler;
+  eventHandlers[eventHandler->id] = eventHandler;
+}
+
+void EventHandlerRegistry::unregisterEventHandler(unsigned long id) {
+  auto handlerIt = eventHandlers.find(id);
+  if (handlerIt != eventHandlers.end()) {
+    eventMappings[handlerIt->second->eventName].erase(id);
+  }
+}
+
+void EventHandlerRegistry::processEvent(jsi::Runtime &rt, std::string eventName, std::string eventPayload) {
+  auto handlersIt = eventMappings.find(eventName);
+  if (handlersIt != eventMappings.end()) {
+    // TODO: use jsi::Value::createFromJsonUtf8
+    auto eventObject = eval(rt, ("(" + eventPayload + ")").c_str()).asObject(rt).getProperty(rt, "NativeMap");
+    eventObject.asObject(rt).setProperty(rt, "eventName", jsi::String::createFromUtf8(rt, eventName));
+    for (auto handler : handlersIt->second) {
+      handler.second->process(rt, eventObject);
+    }
+  }
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/MapperRegistry.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/MapperRegistry.cpp
new file mode 100644
index 0000000..d5226ca
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/MapperRegistry.cpp
@@ -0,0 +1,141 @@
+#include "MapperRegistry.h"
+#include "Mapper.h"
+#include <map>
+#include <array>
+#include <set>
+
+namespace reanimated {
+
+void MapperRegistry::startMapper(std::shared_ptr<Mapper> mapper) {
+  mappers[mapper->id] = mapper;
+  updatedSinceLastExecute = true;
+}
+
+void MapperRegistry::stopMapper(unsigned long id) {
+  mappers.erase(id);
+  updatedSinceLastExecute = true;
+}
+
+void MapperRegistry::execute(jsi::Runtime &rt) {
+  if (updatedSinceLastExecute) {
+    updateOrder();
+    updatedSinceLastExecute = false;
+  }
+  for (auto & mapper : sortedMappers) {
+    if (mapper->dirty) {
+      mapper->execute(rt);
+    }
+  }
+}
+
+bool MapperRegistry::needRunOnRender() {
+  return updatedSinceLastExecute; // TODO: also run if input nodes are dirty
+}
+
+void MapperRegistry::updateOrder() { // Topological sorting
+  //sortedMappers.clear();
+
+  struct NodeID {
+    std::shared_ptr<Mapper> mapper;
+    std::shared_ptr<MutableValue> mutableValue;
+
+    NodeID(std::shared_ptr<Mapper> mapper) {
+      if (mapper == nullptr) {
+        throw std::runtime_error("Graph couldn't be sorted (Mapper cannot be nullptr)");
+      }
+      this->mapper = mapper;
+    }
+
+    NodeID(std::shared_ptr<MutableValue> mutableValue) {
+      if (mutableValue == nullptr) {
+        throw std::runtime_error("Graph couldn't be sorted (Mutable cannot be nullptr)");
+      }
+      this->mutableValue = mutableValue;
+    }
+
+    bool isMutable() const {
+      return mutableValue != nullptr;
+    }
+
+    bool operator<(const NodeID& other) const
+    {
+      if (isMutable() != other.isMutable())
+        return isMutable() < other.isMutable();
+
+      if (isMutable()) {
+        return mutableValue < other.mutableValue;
+      }
+
+      return mapper < other.mapper;
+    }
+  };
+
+  std::map<NodeID, int> deg;
+
+  std::map<std::shared_ptr<MutableValue>, std::vector<std::shared_ptr<Mapper>>> mappersThatUseSharedValue;
+
+  std::set<std::pair<int, NodeID>> nodes;
+
+  std::function<void(NodeID)> update = [&] (NodeID id) {
+    auto entry = std::make_pair(deg[id], id);
+    if (nodes.find(entry) == nodes.end()) return;
+    nodes.erase(entry);
+    entry.first--;
+    deg[id]--;
+    nodes.insert(entry);
+  };
+
+  for (auto & entry : mappers) {
+    auto id = NodeID(entry.second);
+    auto & mapper = entry.second;
+    deg[id] = mapper->inputs.size();
+    nodes.insert(std::make_pair(deg[id], id));
+
+    for (auto sharedValue : mapper->inputs) {
+      auto sharedValueID = NodeID(sharedValue);
+      mappersThatUseSharedValue[sharedValue].push_back(mapper);
+      if (deg.count(sharedValue) == 0) {
+        deg[sharedValueID] = 0;
+      }
+    }
+
+    for (auto sharedValue : mapper->outputs) {
+      deg[NodeID(sharedValue)]++;
+    }
+  }
+
+  for (auto & entry : deg) {
+    auto id = entry.first;
+    if (id.isMutable()) {
+      nodes.insert(std::make_pair(entry.second, id));
+    }
+  }
+
+  while (nodes.size() > 0 and nodes.begin()->first == 0) {
+    auto entry = *nodes.begin();
+    nodes.erase(entry);
+
+    auto id = entry.second;
+    std::vector<NodeID> toUpdate;
+
+    if (id.isMutable()) {
+      for (auto id : mappersThatUseSharedValue[id.mutableValue]) {
+        toUpdate.push_back(id);
+      }
+    } else {
+      for (auto sharedValue : id.mapper->outputs) {
+        toUpdate.push_back(NodeID(sharedValue));
+      }
+
+      sortedMappers.push_back(id.mapper);
+    }
+
+    for (auto & id : toUpdate) update(id);
+  }
+
+  if (nodes.size() > 0) {
+    throw std::runtime_error("Cycle in mappers graph!");
+  }
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/WorkletsCache.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/WorkletsCache.cpp
new file mode 100644
index 0000000..4cf01fe
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Registries/WorkletsCache.cpp
@@ -0,0 +1,28 @@
+#include "WorkletsCache.h"
+#include "ShareableValue.h"
+#include "FrozenObject.h"
+
+using namespace facebook;
+
+namespace reanimated
+{
+
+jsi::Value eval(jsi::Runtime &rt, const char *code) {
+  return rt.global().getPropertyAsFunction(rt, "eval").call(rt, code);
+}
+
+jsi::Function function(jsi::Runtime &rt, const std::string& code) {
+  return eval(rt, ("(" + code + ")").c_str()).getObject(rt).getFunction(rt);
+}
+
+std::shared_ptr<jsi::Function> WorkletsCache::getFunction(jsi::Runtime &rt, std::shared_ptr<FrozenObject> frozenObj) {
+  long long workletHash = frozenObj->map["__workletHash"]->numberValue;
+  if (worklets.count(workletHash) == 0) {
+    jsi::Function fun = function(rt, frozenObj->map["asString"]->stringValue);
+    std::shared_ptr<jsi::Function> funPtr(new jsi::Function(std::move(fun)));
+    worklets[workletHash] = funPtr;
+  }
+  return worklets[workletHash];
+}
+
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/FrozenObject.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/FrozenObject.cpp
new file mode 100644
index 0000000..9c2c2c3
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/FrozenObject.cpp
@@ -0,0 +1,23 @@
+#include "FrozenObject.h"
+#include "SharedParent.h"
+#include "ShareableValue.h"
+
+namespace reanimated {
+
+FrozenObject::FrozenObject(jsi::Runtime &rt, const jsi::Object &object, NativeReanimatedModule *module) {
+  auto propertyNames = object.getPropertyNames(rt);
+  for (size_t i = 0, count = propertyNames.size(rt); i < count; i++) {
+    auto propertyName = propertyNames.getValueAtIndex(rt, i).asString(rt);
+    map[propertyName.utf8(rt)] = ShareableValue::adapt(rt, object.getProperty(rt, propertyName), module);
+  }
+}
+
+jsi::Object FrozenObject::shallowClone(jsi::Runtime &rt) {
+  jsi::Object object(rt);
+  for (auto prop : map) {
+    object.setProperty(rt, jsi::String::createFromUtf8(rt, prop.first), prop.second->getValue(rt));
+  }
+  return object;
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/MutableValue.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/MutableValue.cpp
new file mode 100644
index 0000000..0196c98
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/MutableValue.cpp
@@ -0,0 +1,113 @@
+#include "MutableValue.h"
+#include "SharedParent.h"
+#include "ShareableValue.h"
+#include "NativeReanimatedModule.h"
+
+namespace reanimated {
+
+void MutableValue::setValue(jsi::Runtime &rt, const jsi::Value &newValue) {
+  std::lock_guard<std::mutex> lock(readWriteMutex);
+  value = ShareableValue::adapt(rt, newValue, module);
+  
+  std::shared_ptr<MutableValue> thiz = shared_from_this();
+  auto notifyListeners = [thiz] () {
+    for (auto listener : thiz->listeners) {
+      listener.second();
+    }
+  };
+  
+  if (module->isUIRuntime(rt)) {
+    notifyListeners();
+  } else {
+    module->scheduler->scheduleOnUI([notifyListeners] {
+      notifyListeners();
+    });
+  } 
+}
+
+jsi::Value MutableValue::getValue(jsi::Runtime &rt) {
+  std::lock_guard<std::mutex> lock(readWriteMutex);
+  return value->getValue(rt);
+}
+
+void MutableValue::set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &newValue) {
+  auto propName = name.utf8(rt);
+
+  if (module->isHostRuntime(rt)) {
+    if (propName == "value") {
+      auto shareable = ShareableValue::adapt(rt, newValue, module);
+      module->scheduler->scheduleOnUI([this, shareable] {
+        jsi::Runtime &rt = *this->module->runtime.get();
+        auto setterProxy = jsi::Object::createFromHostObject(rt, std::make_shared<MutableValueSetterProxy>(shared_from_this()));
+        jsi::Value newValue = shareable->getValue(rt);
+        module->valueSetter->getValue(rt)
+          .asObject(rt)
+          .asFunction(rt)
+          .callWithThis(rt, setterProxy, newValue);
+      });
+    }
+    return;
+  }
+
+  // UI thread
+  if (propName == "value") {
+    auto setterProxy = jsi::Object::createFromHostObject(rt, std::make_shared<MutableValueSetterProxy>(shared_from_this()));
+    module->valueSetter->getValue(rt)
+      .asObject(rt)
+      .asFunction(rt)
+      .callWithThis(rt, setterProxy, newValue);
+  } else if (propName == "_animation") {
+    // TODO: assert to allow animation to be set from UI only
+    if (animation.expired()) {
+      animation = getWeakRef(rt);
+    }
+    *animation.lock() = jsi::Value(rt, newValue);
+  }
+}
+
+jsi::Value MutableValue::get(jsi::Runtime &rt, const jsi::PropNameID &name) {
+  auto propName = name.utf8(rt);
+
+  if (propName == "value") {
+    return getValue(rt);
+  }
+
+  if (module->isUIRuntime(rt)) {
+    // _value and _animation should be accessed from UI only
+    if (propName == "_value") {
+      return getValue(rt);
+    } else if (propName == "_animation") {
+      // TODO: assert to allow animation to be read from UI only
+      if (animation.expired()) {
+        animation = getWeakRef(rt);
+      }
+      return jsi::Value(rt, *(animation.lock()));
+    }
+  }
+
+  return jsi::Value::undefined();
+}
+
+std::vector<jsi::PropNameID> MutableValue::getPropertyNames(jsi::Runtime &rt) {
+  std::vector<jsi::PropNameID> result;
+  result.push_back(jsi::PropNameID::forUtf8(rt, std::string("value")));
+  return result;
+}
+
+MutableValue::MutableValue(jsi::Runtime &rt, const jsi::Value &initial, NativeReanimatedModule *module):
+module(module), value(ShareableValue::adapt(rt, initial, module)) {
+}
+
+unsigned long int MutableValue::addListener(unsigned long id, std::function<void ()> listener) {
+  listeners[id] = listener;
+  return id;
+}
+
+void MutableValue::removeListener(unsigned long listenerId) {
+  if (listeners.count(listenerId) > 0) {
+    listeners.erase(listenerId);
+  }
+}
+
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/MutableValueSetterProxy.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/MutableValueSetterProxy.cpp
new file mode 100644
index 0000000..f282ed7
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/MutableValueSetterProxy.cpp
@@ -0,0 +1,43 @@
+#include "MutableValueSetterProxy.h"
+#include "SharedParent.h"
+#include "MutableValue.h"
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+void MutableValueSetterProxy::set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &newValue) {
+  auto propName = name.utf8(rt);
+  if (propName == "value") {
+    // you call `this.value` inside of value setter, we should throw
+  } else if (propName == "_value") {
+    mutableValue->setValue(rt, newValue);
+  } else if (propName == "_animation") {
+    // TODO: assert to allow animation to be set from UI only
+    if (mutableValue->animation.expired()) {
+      mutableValue->animation = mutableValue->getWeakRef(rt);
+    }
+    *mutableValue->animation.lock() = jsi::Value(rt, newValue);
+  }
+}
+
+jsi::Value MutableValueSetterProxy::get(jsi::Runtime &rt, const jsi::PropNameID &name) {
+  auto propName = name.utf8(rt);
+
+  if (propName == "value") {
+    return mutableValue->getValue(rt);
+  } else if (propName == "_value") {
+    return mutableValue->getValue(rt);
+  } else if (propName == "_animation") {
+    if (mutableValue->animation.expired()) {
+      mutableValue->animation = mutableValue->getWeakRef(rt);
+    }
+    return jsi::Value(rt, *mutableValue->animation.lock());
+  }
+
+  return jsi::Value::undefined();
+}
+
+}
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/RemoteObject.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/RemoteObject.cpp
new file mode 100644
index 0000000..c3efbcc
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/RemoteObject.cpp
@@ -0,0 +1,41 @@
+#include "RemoteObject.h"
+#include "SharedParent.h"
+#include "NativeReanimatedModule.h"
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+void RemoteObject::maybeInitializeOnUIRuntime(jsi::Runtime &rt) {
+  if (initializer.get() != nullptr) {
+    backing = getWeakRef(rt);
+    *backing.lock() = initializer->shallowClone(rt);
+    initializer = nullptr;
+  }
+}
+
+jsi::Value RemoteObject::get(jsi::Runtime &rt, const jsi::PropNameID &name) {
+  if (module->isUIRuntime(rt)) {
+    return backing.lock()->getObject(rt).getProperty(rt, name);
+  }
+  return jsi::Value::undefined();
+}
+
+void RemoteObject::set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &value) {
+  if (module->isUIRuntime(rt)) {
+    backing.lock()->getObject(rt).setProperty(rt, name, value);
+  }
+  // TODO: we should throw if trying to update remote from host runtime
+}
+
+std::vector<jsi::PropNameID> RemoteObject::getPropertyNames(jsi::Runtime &rt) {
+  std::vector<jsi::PropNameID> res;
+  auto propertyNames = backing.lock()->getObject(rt).getPropertyNames(rt);
+  for (size_t i = 0, size = propertyNames.size(rt); i < size; i++) {
+    res.push_back(jsi::PropNameID::forString(rt, propertyNames.getValueAtIndex(rt, i).asString(rt)));
+  }
+  return res;
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/ShareableValue.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/ShareableValue.cpp
new file mode 100644
index 0000000..f97b888
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/SharedItems/ShareableValue.cpp
@@ -0,0 +1,345 @@
+#include "ShareableValue.h"
+#include "SharedParent.h"
+#include "NativeReanimatedModule.h"
+#include "Logger.h"
+#include "MutableValue.h"
+#include "MutableValueSetterProxy.h"
+#include "RemoteObject.h"
+#include "FrozenObject.h"
+
+namespace reanimated {
+
+const char *HIDDEN_HOST_OBJECT_PROP = "__reanimatedHostObjectRef";
+const char *ALREADY_CONVERTED= "__alreadyConverted";
+  
+void addHiddenProperty(jsi::Runtime &rt,
+                       jsi::Value &&value,
+                       jsi::Object &obj,
+                       const char *name) {
+  jsi::Object globalObject = rt.global().getPropertyAsObject(rt, "Object");
+  jsi::Function defineProperty = globalObject.getPropertyAsFunction(rt, "defineProperty");
+  jsi::String internalPropName = jsi::String::createFromUtf8(rt, name);
+  jsi::Object paramForDefineProperty(rt);
+  paramForDefineProperty.setProperty(rt, "enumerable", false);
+  paramForDefineProperty.setProperty(rt, "value", value);
+  defineProperty.call(rt, obj, internalPropName, paramForDefineProperty);
+}
+
+void freeze(jsi::Runtime &rt, jsi::Object &obj) {
+  jsi::Object globalObject = rt.global().getPropertyAsObject(rt, "Object");
+  jsi::Function freeze = globalObject.getPropertyAsFunction(rt, "freeze");
+  freeze.call(rt, obj);
+}
+
+void ShareableValue::adaptCache(jsi::Runtime &rt, const jsi::Value &value) {
+  // when adapting from host object we can assign cached value immediately such that we avoid
+  // running `toJSValue` in the future when given object is accessed
+  if (module->isUIRuntime(rt)) {
+    if (remoteValue.expired()) {
+      remoteValue = getWeakRef(rt);
+    }
+    (*remoteValue.lock()) = jsi::Value(rt, value);
+  } else {
+    hostValue = std::make_unique<jsi::Value>(rt, value);
+  }
+}
+
+void ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType objectType) {
+  bool isRNRuntime = !(module->isUIRuntime(rt));
+  if (value.isObject()) {
+    jsi::Object object = value.asObject(rt);
+    jsi::Value hiddenValue = object.getProperty(rt, HIDDEN_HOST_OBJECT_PROP);
+    if (!(hiddenValue.isUndefined())) {
+      jsi::Object hiddenProperty = hiddenValue.asObject(rt);
+      if (hiddenProperty.isHostObject<FrozenObject>(rt)) {
+        type = ValueType::ObjectType;
+        if (object.hasProperty(rt, "__worklet") && object.isFunction(rt)) {
+          type = ValueType::WorkletFunctionType;
+        }
+        frozenObject = hiddenProperty.getHostObject<FrozenObject>(rt);
+        if (object.hasProperty(rt, ALREADY_CONVERTED)) {
+          adaptCache(rt, value);
+        }
+        return;
+      }
+    }
+  }
+  
+  if (objectType == ValueType::MutableValueType) {
+    type = ValueType::MutableValueType;
+    mutableValue = std::make_shared<MutableValue>(rt, value, module);
+  } else if (value.isUndefined()) {
+    type = ValueType::UndefinedType;
+  } else if (value.isNull()) {
+    type = ValueType::NullType;
+  } else if (value.isBool()) {
+    type = ValueType::BoolType;
+    boolValue = value.getBool();
+  } else if (value.isNumber()) {
+    type = ValueType::NumberType;
+    numberValue = value.asNumber();
+  } else if (value.isString()) {
+    type = ValueType::StringType;
+    stringValue = value.asString(rt).utf8(rt);
+  } else if (value.isObject()) {
+    auto object = value.asObject(rt);
+    if (object.isFunction(rt)) {
+      if (object.getProperty(rt, "__worklet").isUndefined()) {
+        // not a worklet, we treat this as a host function
+        type = ValueType::HostFunctionType;
+        hostRuntime = &rt;
+        hostFunction = std::make_shared<jsi::Function>(object.asFunction(rt));
+      } else {
+        // a worklet
+        type = ValueType::WorkletFunctionType;
+        frozenObject = std::make_shared<FrozenObject>(rt, object, module);
+        if (isRNRuntime) {
+          addHiddenProperty(rt, createHost(rt, frozenObject), object, HIDDEN_HOST_OBJECT_PROP);
+        }
+      }
+    } else if (object.isArray(rt)) {
+      type = ValueType::ArrayType;
+      auto array = object.asArray(rt);
+      for (size_t i = 0, size = array.size(rt); i < size; i++) {
+        frozenArray.push_back(adapt(rt, array.getValueAtIndex(rt, i), module));
+      }
+    } else if (object.isHostObject<MutableValue>(rt)) {
+      type = ValueType::MutableValueType;
+      mutableValue = object.getHostObject<MutableValue>(rt);
+      adaptCache(rt, value);
+    } else if (object.isHostObject<RemoteObject>(rt)) {
+      type = ValueType::RemoteObjectType;
+      remoteObject = object.getHostObject<RemoteObject>(rt);
+      adaptCache(rt, value);
+    } else if (objectType == ValueType::RemoteObjectType) {
+      type = ValueType::RemoteObjectType;
+      remoteObject = std::make_shared<RemoteObject>(rt, object, module);
+    } else {
+      // create frozen object based on a copy of a given object
+      type = ValueType::ObjectType;
+      frozenObject = std::make_shared<FrozenObject>(rt, object, module);
+      if (isRNRuntime) {
+        addHiddenProperty(rt, createHost(rt, frozenObject), object, HIDDEN_HOST_OBJECT_PROP);
+        freeze(rt, object);
+      }
+    }
+  } else if (value.isSymbol()) {
+    type = ValueType::StringType;
+    stringValue = value.asSymbol(rt).toString(rt);
+  } else {
+    throw "Invalid value type";
+  }
+}
+
+std::shared_ptr<ShareableValue> ShareableValue::adapt(jsi::Runtime &rt, const jsi::Value &value, NativeReanimatedModule *module, ValueType valueType) {
+  auto sv = std::shared_ptr<ShareableValue>(new ShareableValue(module));
+  sv->adapt(rt, value, valueType);
+  return sv;
+}
+
+jsi::Value ShareableValue::getValue(jsi::Runtime &rt) {
+  // TODO: maybe we can cache toJSValue results on a per-runtime basis, need to avoid ref loops
+  if (module->isUIRuntime(rt)) {
+    if (remoteValue.expired()) {
+      auto ref = getWeakRef(rt);
+      remoteValue = ref;
+    }
+    
+    if (remoteValue.lock()->isUndefined()) {
+      (*remoteValue.lock()) = jsi::Value(rt, toJSValue(rt));
+    }
+    return jsi::Value(rt, *remoteValue.lock());
+  } else {
+    if (hostValue.get() == nullptr) {
+      hostValue = std::make_unique<jsi::Value>(rt, toJSValue(rt));
+    }
+    return jsi::Value(rt, *hostValue);
+  }
+}
+
+jsi::Object ShareableValue::createHost(jsi::Runtime &rt, std::shared_ptr<jsi::HostObject> host) {
+  return jsi::Object::createFromHostObject(rt, host);
+}
+
+jsi::Value createFrozenWrapper(jsi::Runtime &rt, std::shared_ptr<FrozenObject> frozenObject) {
+  jsi::Object __reanimatedHiddenHost = jsi::Object::createFromHostObject(rt, frozenObject);
+  jsi::Object obj = frozenObject->shallowClone(rt);
+  jsi::Object globalObject = rt.global().getPropertyAsObject(rt, "Object");
+  jsi::Function freeze = globalObject.getPropertyAsFunction(rt, "freeze");
+  addHiddenProperty(rt, std::move(__reanimatedHiddenHost), obj, HIDDEN_HOST_OBJECT_PROP);
+  addHiddenProperty(rt, true, obj, ALREADY_CONVERTED);
+  return freeze.call(rt, obj);
+}
+
+jsi::Value ShareableValue::toJSValue(jsi::Runtime &rt) {
+  switch (type) {
+    case ValueType::UndefinedType:
+      return jsi::Value::undefined();
+    case ValueType::NullType:
+      return jsi::Value::null();
+    case ValueType::BoolType:
+      return jsi::Value(boolValue);
+    case ValueType::NumberType:
+      return jsi::Value(numberValue);
+    case ValueType::StringType:
+      return jsi::Value(rt, jsi::String::createFromAscii(rt, stringValue));
+    case ValueType::ObjectType:
+      return createFrozenWrapper(rt, frozenObject);
+    case ValueType::ArrayType: {
+      jsi::Array array(rt, frozenArray.size());
+      for (size_t i = 0; i < frozenArray.size(); i++) {
+        array.setValueAtIndex(rt, i, frozenArray[i]->toJSValue(rt));
+      }
+      return array;
+    }
+    case ValueType::RemoteObjectType:
+     if (module->isUIRuntime(rt)) {
+        remoteObject->maybeInitializeOnUIRuntime(rt);
+      }
+      return createHost(rt, remoteObject);
+    case ValueType::MutableValueType:
+      return createHost(rt, mutableValue);
+    case ValueType::HostFunctionType:
+      if (hostRuntime == &rt) {
+        // function is accessed from the same runtime it was crated, we just return same function obj
+        return jsi::Value(rt, *hostFunction);
+      } else {
+        // function is accessed from a different runtme, we wrap function in host func that'd enqueue
+        // call on an appropriate thread
+        auto module = this->module;
+        auto hostFunction = this->hostFunction;
+        auto hostRuntime = this->hostRuntime;
+        auto clb = [module, hostFunction, hostRuntime](
+            jsi::Runtime &rt,
+            const jsi::Value &thisValue,
+            const jsi::Value *args,
+            size_t count
+            ) -> jsi::Value {
+          // TODO: we should find thread based on runtime such that we could also call UI methods
+          // from RN and not only RN methods from UI
+          
+          std::vector<std::shared_ptr<ShareableValue>> params;
+          for (int i = 0; i < count; ++i) {
+            params.push_back(ShareableValue::adapt(rt, args[i], module));
+          }
+
+          std::function<void()> job = [hostFunction, hostRuntime, params] {
+            jsi::Value * args = new jsi::Value[params.size()];
+            for (int i = 0; i < params.size(); ++i) {
+              args[i] = params[i]->getValue(*hostRuntime);
+            }
+
+            jsi::Value returnedValue;
+
+            returnedValue = hostFunction->call(*hostRuntime,
+                                              static_cast<const jsi::Value*>(args),
+                                              (size_t)params.size());
+
+            delete [] args;
+             // ToDo use returned value to return promise
+          };
+
+          module->scheduler->scheduleOnJS(job);
+          return jsi::Value::undefined();
+        };
+        return jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "hostFunction"), 0, clb);
+      }
+    case ValueType::WorkletFunctionType:
+      auto module = this->module;
+      auto frozenObject = this->frozenObject;
+      if (module->isUIRuntime(rt)) {
+        // when running on UI thread we prep a function
+
+        auto jsThis = std::make_shared<jsi::Object>(frozenObject->shallowClone(*module->runtime));
+        std::shared_ptr<jsi::Function> funPtr(module->workletsCache->getFunction(rt, frozenObject));
+        
+        // HACK ALERT: there is a special case of "setter" function where we don't want to pass
+        // closure as "this". Here we handle that case separately;
+        if (module->valueSetter.get() == this) {
+          return jsi::Value(rt, *funPtr);
+        }
+
+        auto clb = [=](
+                   jsi::Runtime &rt,
+                   const jsi::Value &thisValue,
+                   const jsi::Value *args,
+                   size_t count
+                   ) mutable -> jsi::Value {
+           jsi::Value oldJSThis = rt.global().getProperty(rt, "jsThis");
+           rt.global().setProperty(rt, "jsThis", *jsThis); //set jsThis
+
+           jsi::Value res = jsi::Value::undefined();
+           try {
+             if (thisValue.isObject()) {
+               res = funPtr->callWithThis(rt, thisValue.asObject(rt), args, count);
+             } else {
+               res = funPtr->call(rt, args, count);
+             }
+           } catch(std::exception &e) {
+               std::string str = e.what();
+             this->module->errorHandler->setError(str);
+             this->module->errorHandler->raise();
+           }
+
+           rt.global().setProperty(rt, "jsThis", oldJSThis); //clean jsThis
+           return res;
+        };
+        return jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "workletFunction"), 0, clb);
+      } else {
+        // when run outside of UI thread we enqueue a call on the UI thread
+        auto retain_this = shared_from_this();
+        auto clb = [retain_this = std::move(retain_this)](
+            jsi::Runtime &rt,
+            const jsi::Value &thisValue,
+            const jsi::Value *args,
+            size_t count
+            ) -> jsi::Value {
+          // TODO: we should find thread based on runtime such that we could also call UI methods
+          // from RN and not only RN methods from UI
+          
+          auto module = retain_this->module;
+
+          std::vector<std::shared_ptr<ShareableValue>> params;
+          for (int i = 0; i < count; ++i) {
+            params.push_back(ShareableValue::adapt(rt, args[i], module));
+          }
+          
+          module->scheduler->scheduleOnUI([retain_this, params, &module] {
+            jsi::Runtime &rt = *retain_this->module->runtime.get();
+            auto jsThis = createFrozenWrapper(rt, retain_this->frozenObject).getObject(rt);
+            auto code = jsThis.getProperty(rt, "asString").asString(rt).utf8(rt);
+            std::shared_ptr<jsi::Function> funPtr(retain_this->module->workletsCache->getFunction(rt, retain_this->frozenObject));
+            
+            jsi::Value * args = new jsi::Value[params.size()];
+            for (int i = 0; i < params.size(); ++i) {
+              args[i] = params[i]->getValue(rt);
+            }
+            
+            jsi::Value returnedValue;
+            
+            jsi::Value oldJSThis = rt.global().getProperty(rt, "jsThis");
+            rt.global().setProperty(rt, "jsThis", jsThis); //set jsThis
+            try {
+              returnedValue = funPtr->call(rt,
+                                             static_cast<const jsi::Value*>(args),
+                                             (size_t)params.size());
+            
+            } catch(std::exception &e) {
+              std::string str = e.what();
+              module->errorHandler->setError(str);
+              module->errorHandler->raise();
+            }
+            rt.global().setProperty(rt, "jsThis", oldJSThis); //clean jsThis
+            
+            delete [] args;
+            // ToDo use returned value to return promise
+          });
+          return jsi::Value::undefined();
+        };
+        return jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "workletFunction"), 0, clb);
+      }
+  }
+  throw "convert error";
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/EventHandler.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/EventHandler.cpp
new file mode 100644
index 0000000..5b01e04
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/EventHandler.cpp
@@ -0,0 +1,9 @@
+#include "EventHandler.h"
+
+namespace reanimated {
+
+void EventHandler::process(jsi::Runtime &rt, jsi::Value &eventValue) {
+  handler.callWithThis(rt, handler, eventValue);
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/JSIStoreValueUser.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/JSIStoreValueUser.cpp
new file mode 100644
index 0000000..26b6b29
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/JSIStoreValueUser.cpp
@@ -0,0 +1,34 @@
+#include "JSIStoreValueUser.h"
+
+namespace reanimated {
+
+int identifier = 0;
+std::atomic<int> StoreUser::ctr;
+std::unordered_map<int, std::vector<std::shared_ptr<jsi::Value>>> StoreUser::store;
+
+std::weak_ptr<jsi::Value> StoreUser::getWeakRef(jsi::Runtime &rt) {
+  if (StoreUser::store.count(identifier) == 0) {
+    StoreUser::store[identifier] = std::vector<std::shared_ptr<jsi::Value>>();
+  }
+  std::shared_ptr<jsi::Value> sv = std::make_shared<jsi::Value>(rt, jsi::Value::undefined());
+  StoreUser::store[identifier].push_back(sv);
+  
+  return sv;
+}
+
+void StoreUser::removeRefs() {
+  if (StoreUser::store.count(identifier) > 0) {
+    StoreUser::store.erase(identifier);
+  }
+}
+
+StoreUser::~StoreUser() {
+  removeRefs();
+}
+
+
+void StoreUser::clearStore() {
+  StoreUser::store.clear();
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/Mapper.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/Mapper.cpp
new file mode 100644
index 0000000..59c7690
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/Mapper.cpp
@@ -0,0 +1,37 @@
+#include "Mapper.h"
+#include "SharedParent.h"
+#include "MutableValue.h"
+
+namespace reanimated {
+
+Mapper::Mapper(NativeReanimatedModule *module,
+               unsigned long id,
+               jsi::Function &&mapper,
+               std::vector<std::shared_ptr<MutableValue>> inputs,
+               std::vector<std::shared_ptr<MutableValue>> outputs):
+id(id),
+module(module),
+mapper(std::move(mapper)),
+inputs(inputs),
+outputs(outputs) {
+  auto markDirty = [this, module]() {
+    this->dirty = true;
+    module->maybeRequestRender();
+  };
+  for (auto input : inputs) {
+    input->addListener(id, markDirty);
+  }
+}
+
+void Mapper::execute(jsi::Runtime &rt) {
+  dirty = false;
+  mapper.callWithThis(rt, mapper);
+}
+
+Mapper::~Mapper() {
+  for (auto input : inputs) {
+    input->removeListener(id);
+  }
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/RuntimeDecorator.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/RuntimeDecorator.cpp
new file mode 100644
index 0000000..e1d4669
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/RuntimeDecorator.cpp
@@ -0,0 +1,118 @@
+#include "RuntimeDecorator.h"
+#include "Logger.h"
+#include <unordered_map>
+#include <memory>
+
+namespace reanimated {
+
+void RuntimeDecorator::addNativeObjects(jsi::Runtime &rt,
+                                        UpdaterFunction updater,
+                                        RequestFrameFunction requestFrame,
+                                        ScrollToFunction scrollTo,
+                                        MeasuringFunction measure) {
+  rt.global().setProperty(rt, "_WORKLET", jsi::Value(true));
+  
+  jsi::Object dummyGlobal(rt);
+  auto dummyFunction = [requestFrame](
+     jsi::Runtime &rt,
+     const jsi::Value &thisValue,
+     const jsi::Value *args,
+     size_t count
+     ) -> jsi::Value {
+   return jsi::Value::undefined();
+  };
+  jsi::Function __reanimatedWorkletInit = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "__reanimatedWorkletInit"), 1, dummyFunction);
+  
+  dummyGlobal.setProperty(rt, "__reanimatedWorkletInit", __reanimatedWorkletInit);
+  rt.global().setProperty(rt, "global", dummyGlobal);
+  
+  rt.global().setProperty(rt, "jsThis", jsi::Value::undefined());
+
+  auto callback = [](
+      jsi::Runtime &rt,
+      const jsi::Value &thisValue,
+      const jsi::Value *args,
+      size_t count
+      ) -> jsi::Value {
+    const jsi::Value *value = &args[0];
+    if (value->isString()) {
+      Logger::log(value->getString(rt).utf8(rt).c_str());
+    } else if (value->isNumber()) {
+      Logger::log(value->getNumber());
+    } else if (value->isUndefined()) {
+      Logger::log("undefined");
+    } else {
+      Logger::log("unsupported value type");
+    }
+    return jsi::Value::undefined();
+    };
+  jsi::Value log = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_log"), 1, callback);
+	rt.global().setProperty(rt, "_log", log);
+
+
+  auto clb = [updater](
+      jsi::Runtime &rt,
+      const jsi::Value &thisValue,
+      const jsi::Value *args,
+      size_t count
+      ) -> jsi::Value {
+    const auto viewTag = args[0].asNumber();
+    const auto params = args[1].asObject(rt);
+    updater(rt, viewTag, params);
+    return jsi::Value::undefined();
+  };
+  jsi::Value updateProps = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_updateProps"), 2, clb);
+  rt.global().setProperty(rt, "_updateProps", updateProps);
+
+
+  auto clb2 = [requestFrame](
+      jsi::Runtime &rt,
+      const jsi::Value &thisValue,
+      const jsi::Value *args,
+      size_t count
+      ) -> jsi::Value {
+    auto fun = std::make_shared<jsi::Function>(args[0].asObject(rt).asFunction(rt));
+    requestFrame([&rt, fun](double timestampMs) {
+      fun->call(rt, jsi::Value(timestampMs));
+    });
+    return jsi::Value::undefined();
+  };
+  jsi::Value requestAnimationFrame = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "requestAnimationFrame"), 1, clb2);
+  rt.global().setProperty(rt, "requestAnimationFrame", requestAnimationFrame);
+  
+  auto clb3 = [scrollTo](
+      jsi::Runtime &rt,
+      const jsi::Value &thisValue,
+      const jsi::Value *args,
+      size_t count
+      ) -> jsi::Value {
+    int viewTag = (int)args[0].asNumber();
+    double x = args[1].asNumber();
+    double y = args[2].asNumber();
+    bool animated = args[3].getBool();
+    scrollTo(viewTag, x, y, animated);
+    return jsi::Value::undefined();
+  };
+  jsi::Value scrollToFunction = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_scrollTo"), 4, clb3);
+  rt.global().setProperty(rt, "_scrollTo", scrollToFunction);
+  
+  auto clb4 = [measure](
+      jsi::Runtime &rt,
+      const jsi::Value &thisValue,
+      const jsi::Value *args,
+      size_t count
+      ) -> jsi::Value {
+    int viewTag = (int)args[0].asNumber();
+    auto result = measure(viewTag);
+    jsi::Object resultObject(rt);
+    for (auto &i:result) {
+      resultObject.setProperty(rt, i.first.c_str(), i.second);
+    }
+    return resultObject;
+  };
+  jsi::Value measureFunction = jsi::Function::createFromHostFunction(rt, jsi::PropNameID::forAscii(rt, "_measure"), 1, clb4);
+  rt.global().setProperty(rt, "_measure", measureFunction);
+  
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/Scheduler.cpp b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/Scheduler.cpp
new file mode 100644
index 0000000..6146385
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/Tools/Scheduler.cpp
@@ -0,0 +1,25 @@
+#include "Scheduler.h"
+
+namespace reanimated
+{
+
+void Scheduler::scheduleOnUI(std::function<void()> job) {
+  uiJobs.push(std::move(job));
+}
+
+void Scheduler::scheduleOnJS(std::function<void()> job) {
+  jsCallInvoker_->invokeAsync(std::move(job));
+}
+
+void Scheduler::triggerUI() {
+  auto job = uiJobs.pop();
+  job();
+}
+
+void Scheduler::setJSCallInvoker(std::shared_ptr<facebook::react::CallInvoker> jsCallInvoker) {
+  jsCallInvoker_ = jsCallInvoker;
+}
+
+Scheduler::~Scheduler() {}
+
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModule.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModule.h
new file mode 100644
index 0000000..820c7f7
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModule.h
@@ -0,0 +1,76 @@
+#pragma once
+
+#include "NativeReanimatedModuleSpec.h"
+#include "Scheduler.h"
+#include "ErrorHandler.h"
+#include "WorkletsCache.h"
+#include "RuntimeDecorator.h"
+#include "PlatformDepMethodsHolder.h"
+#include <unistd.h>
+#include <memory>
+#include <vector>
+
+namespace reanimated
+{
+
+using FrameCallback = std::function<void(double)>;
+
+class ShareableValue;
+class MutableValue;
+class MapperRegistry;
+class EventHandlerRegistry;
+
+class NativeReanimatedModule : public NativeReanimatedModuleSpec
+{
+  friend ShareableValue;
+  friend MutableValue;
+  
+  public:
+    NativeReanimatedModule(std::shared_ptr<CallInvoker> jsInvoker,
+                           std::shared_ptr<Scheduler> scheduler,
+                           std::unique_ptr<jsi::Runtime> rt,
+                           std::shared_ptr<ErrorHandler> errorHandler,
+                           std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer,
+                           PlatformDepMethodsHolder platformDepMethodsHolder);
+
+    virtual ~NativeReanimatedModule();
+
+    void installCoreFunctions(jsi::Runtime &rt, const jsi::Value &valueSetter) override;
+
+    jsi::Value makeShareable(jsi::Runtime &rt, const jsi::Value &value) override;
+    jsi::Value makeMutable(jsi::Runtime &rt, const jsi::Value &value) override;
+    jsi::Value makeRemote(jsi::Runtime &rt, const jsi::Value &value) override;
+
+    jsi::Value startMapper(jsi::Runtime &rt, const jsi::Value &worklet, const jsi::Value &inputs, const jsi::Value &outputs) override;
+    void stopMapper(jsi::Runtime &rt, const jsi::Value &mapperId) override;
+
+    jsi::Value registerEventHandler(jsi::Runtime &rt, const jsi::Value &eventHash, const jsi::Value &worklet) override;
+    void unregisterEventHandler(jsi::Runtime &rt, const jsi::Value &registrationId) override;
+
+    jsi::Value getViewProp(jsi::Runtime &rt, const jsi::Value &viewTag, const jsi::Value &propName, const jsi::Value &callback) override;
+    
+    void onRender(double timestampMs);
+    void onEvent(std::string eventName, std::string eventAsString);
+
+    void maybeRequestRender();
+
+    bool isUIRuntime(jsi::Runtime &rt);
+    bool isHostRuntime(jsi::Runtime &rt);
+
+  private:
+    std::unique_ptr<jsi::Runtime> runtime;
+    std::shared_ptr<MapperRegistry> mapperRegistry;
+    std::shared_ptr<EventHandlerRegistry> eventHandlerRegistry;
+    std::function<void(FrameCallback)> requestRender;
+    std::shared_ptr<jsi::Value> dummyEvent;
+    std::vector<FrameCallback> frameCallbacks;
+    bool renderRequested = false;
+    std::function<jsi::Value(jsi::Runtime &, const int, const jsi::String &)> propObtainer;
+  public:
+  std::shared_ptr<ErrorHandler> errorHandler;
+  std::shared_ptr<WorkletsCache> workletsCache;
+  std::shared_ptr<ShareableValue> valueSetter;
+  std::shared_ptr<Scheduler> scheduler;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModuleSpec.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModuleSpec.h
new file mode 100644
index 0000000..aa6eb42
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/NativeModules/NativeReanimatedModuleSpec.h
@@ -0,0 +1,45 @@
+#pragma once
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#ifdef ONANDROID
+  #include "TurboModule.h"
+#else
+  #include <ReactCommon/TurboModule.h>
+#endif
+
+#include <ReactCommon/CallInvoker.h>
+
+using namespace facebook;
+using namespace react;
+
+namespace reanimated
+{
+
+class JSI_EXPORT NativeReanimatedModuleSpec : public TurboModule {
+ protected:
+  NativeReanimatedModuleSpec(std::shared_ptr<CallInvoker> jsInvoker);
+
+ public:
+  virtual void installCoreFunctions(jsi::Runtime &rt, const jsi::Value &valueSetter) = 0;
+
+  // SharedValue
+  virtual jsi::Value makeShareable(jsi::Runtime &rt, const jsi::Value &value) = 0;
+  virtual jsi::Value makeMutable(jsi::Runtime &rt, const jsi::Value &value) = 0;
+  virtual jsi::Value makeRemote(jsi::Runtime &rt, const jsi::Value &value) = 0;
+
+  // mappers
+  virtual jsi::Value startMapper(jsi::Runtime &rt, const jsi::Value &worklet, const jsi::Value &inputs, const jsi::Value &outputs) = 0;
+  virtual void stopMapper(jsi::Runtime &rt, const jsi::Value &mapperId) = 0;
+
+  // events
+  virtual jsi::Value registerEventHandler(jsi::Runtime &rt, const jsi::Value &eventHash, const jsi::Value &worklet) = 0;
+  virtual void unregisterEventHandler(jsi::Runtime &rt, const jsi::Value &registrationId) = 0;
+
+  // views
+  virtual jsi::Value getViewProp(jsi::Runtime &rt, const jsi::Value &viewTag, const jsi::Value &propName, const jsi::Value &callback) = 0;
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/EventHandlerRegistry.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/EventHandlerRegistry.h
new file mode 100644
index 0000000..db5070c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/EventHandlerRegistry.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include <vector>
+#include <map>
+#include <set>
+#include <unordered_map>
+#include <string>
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class EventHandler;
+
+class EventHandlerRegistry {
+  std::map<std::string, std::unordered_map<unsigned long, std::shared_ptr<EventHandler>>> eventMappings;
+  std::map<unsigned long, std::shared_ptr<EventHandler>> eventHandlers;
+
+public:
+  void registerEventHandler(std::shared_ptr<EventHandler> eventHandler);
+  void unregisterEventHandler(unsigned long id);
+
+  void processEvent(jsi::Runtime &rt, std::string eventName, std::string eventPayload);
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/MapperRegistry.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/MapperRegistry.h
new file mode 100644
index 0000000..c12fdd6
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/MapperRegistry.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include <vector>
+#include <unordered_map>
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class Mapper;
+
+class MapperRegistry {
+  std::unordered_map<unsigned long, std::shared_ptr<Mapper>> mappers;
+  std::vector<std::shared_ptr<Mapper>> sortedMappers;
+  void updateOrder();
+  bool updatedSinceLastExecute = false;
+
+public:
+  void startMapper(std::shared_ptr<Mapper> mapper);
+  void stopMapper(unsigned long id);
+
+  void execute(jsi::Runtime &rt);
+
+  bool needRunOnRender();
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/WorkletsCache.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/WorkletsCache.h
new file mode 100644
index 0000000..0ede04c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Registries/WorkletsCache.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <stdio.h>
+#include <unordered_map>
+#include <jsi/jsi.h>
+#include <memory>
+
+namespace reanimated
+{
+
+using namespace facebook;
+
+class FrozenObject;
+
+class WorkletsCache {
+  std::unordered_map<long long, std::shared_ptr<jsi::Function>> worklets;
+public:
+  std::shared_ptr<jsi::Function> getFunction(jsi::Runtime & rt, std::shared_ptr<reanimated::FrozenObject> frozenObj);
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/FrozenObject.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/FrozenObject.h
new file mode 100644
index 0000000..126fd41
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/FrozenObject.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "WorkletsCache.h"
+#include "SharedParent.h"
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class FrozenObject : public jsi::HostObject {
+  friend WorkletsCache;
+  friend void extractMutables(jsi::Runtime &rt,
+                              std::shared_ptr<ShareableValue> sv,
+                              std::vector<std::shared_ptr<MutableValue>> &res);
+  friend jsi::Value createFrozenWrapper(ShareableValue *sv,
+                                        jsi::Runtime &rt,
+                                        std::shared_ptr<FrozenObject> frozenObject);
+  
+  private:
+  std::unordered_map<std::string, std::shared_ptr<ShareableValue>> map;
+
+  public:
+
+  FrozenObject(jsi::Runtime &rt, const jsi::Object &object, NativeReanimatedModule *module);
+  jsi::Object shallowClone(jsi::Runtime &rt);
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValue.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValue.h
new file mode 100644
index 0000000..523540d
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValue.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "SharedParent.h"
+#include "MutableValueSetterProxy.h"
+#include <mutex>
+#include <jsi/jsi.h>
+#include <map>
+#include "JSIStoreValueUser.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+class MutableValue : public jsi::HostObject, public std::enable_shared_from_this<MutableValue>, public StoreUser {
+  private:
+  friend MutableValueSetterProxy;
+  NativeReanimatedModule *module;
+  std::mutex readWriteMutex;
+  std::shared_ptr<ShareableValue> value;
+  std::weak_ptr<jsi::Value> animation;
+  std::map<unsigned long, std::function<void()>> listeners;
+
+  void setValue(jsi::Runtime &rt, const jsi::Value &newValue);
+  jsi::Value getValue(jsi::Runtime &rt);
+
+  public:
+  MutableValue(jsi::Runtime &rt, const jsi::Value &initial, NativeReanimatedModule *module);
+
+  public:
+  void set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &value);
+  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &name);
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime &rt);
+  unsigned long addListener(unsigned long listenerId, std::function<void()> listener);
+  void removeListener(unsigned long listenerId);
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValueSetterProxy.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValueSetterProxy.h
new file mode 100644
index 0000000..60234f3
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/MutableValueSetterProxy.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "SharedParent.h"
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class MutableValueSetterProxy: public jsi::HostObject {
+private:
+  friend MutableValue;
+  std::shared_ptr<MutableValue> mutableValue;
+public:
+  MutableValueSetterProxy(std::shared_ptr<MutableValue> mutableValue): mutableValue(std::move(mutableValue)) {}
+  void set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &value);
+  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &name);
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/RemoteObject.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/RemoteObject.h
new file mode 100644
index 0000000..6354422
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/RemoteObject.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include "SharedParent.h"
+#include "FrozenObject.h"
+#include "JSIStoreValueUser.h"
+
+using namespace facebook;
+
+namespace reanimated {
+
+class RemoteObject: public jsi::HostObject, public StoreUser {
+private:
+  NativeReanimatedModule *module;
+  std::weak_ptr<jsi::Value> backing;
+  std::unique_ptr<FrozenObject> initializer;
+public:
+  void maybeInitializeOnUIRuntime(jsi::Runtime &rt);
+  RemoteObject(jsi::Runtime &rt, jsi::Object &object, NativeReanimatedModule *module):
+    module(module), initializer(new FrozenObject(rt, object, module)) {}
+  void set(jsi::Runtime &rt, const jsi::PropNameID &name, const jsi::Value &value);
+  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &name);
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime &rt);
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/ShareableValue.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/ShareableValue.h
new file mode 100644
index 0000000..a76031e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/ShareableValue.h
@@ -0,0 +1,52 @@
+#pragma once
+
+#include "WorkletsCache.h"
+#include "SharedParent.h"
+#include "Logger.h"
+#include <string>
+#include <mutex>
+#include <unordered_map>
+#include <jsi/jsi.h>
+#include <JSIStoreValueUser.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class ShareableValue: public std::enable_shared_from_this<ShareableValue>, public StoreUser {
+friend WorkletsCache;
+friend void extractMutables(jsi::Runtime &rt,
+                            std::shared_ptr<ShareableValue> sv,
+                            std::vector<std::shared_ptr<MutableValue>> &res);
+private:
+  NativeReanimatedModule *module;
+  bool boolValue;
+  double numberValue;
+  std::string stringValue;
+  std::shared_ptr<jsi::Function> hostFunction;
+  jsi::Runtime *hostRuntime;
+  std::shared_ptr<FrozenObject> frozenObject;
+  std::shared_ptr<RemoteObjectInitializer> remoteObjectInitializer;
+  std::shared_ptr<RemoteObject> remoteObject;
+  std::vector<std::shared_ptr<ShareableValue>> frozenArray;
+
+  std::unique_ptr<jsi::Value> hostValue;
+  std::weak_ptr<jsi::Value> remoteValue;
+
+  jsi::Value toJSValue(jsi::Runtime &rt);
+
+  jsi::Object createHost(jsi::Runtime &rt, std::shared_ptr<jsi::HostObject> host);
+
+  ShareableValue(NativeReanimatedModule *module): module(module) {}
+  void adapt(jsi::Runtime &rt, const jsi::Value &value, ValueType objectType);
+  void adaptCache(jsi::Runtime &rt, const jsi::Value &value);
+
+public:
+  ValueType type = ValueType::UndefinedType;
+  std::shared_ptr<MutableValue> mutableValue;
+  static std::shared_ptr<ShareableValue> adapt(jsi::Runtime &rt, const jsi::Value &value, NativeReanimatedModule *module, ValueType objectType = ValueType::UndefinedType);
+  jsi::Value getValue(jsi::Runtime &rt);
+
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/SharedParent.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/SharedParent.h
new file mode 100644
index 0000000..63b5370
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SharedItems/SharedParent.h
@@ -0,0 +1,25 @@
+#pragma once
+
+namespace reanimated {
+
+enum class ValueType {
+  UndefinedType,
+  NullType,
+  BoolType,
+  NumberType,
+  StringType,
+  ObjectType, /* frozen object, can only be set and never modified */
+  ArrayType, /* frozen array, can only be set and never modified */
+  RemoteObjectType, /* object that can be instantiated on host side and modified on the remote (worklet) side */
+  MutableValueType, /* object with 'value' property that can be updated and read from any thread */
+  HostFunctionType, /* function that will be executed asynchronously on the host runtime */
+  WorkletFunctionType, /* function that gets run on the UI thread */
+};
+
+class ShareableValue;
+class MutableValue;
+class RemoteObject;
+class RemoteObjectInitializer;
+class NativeReanimatedModule;
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/ErrorHandler.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/ErrorHandler.h
new file mode 100644
index 0000000..793296c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/ErrorHandler.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "Scheduler.h"
+#include <string>
+
+namespace reanimated
+{
+
+struct ErrorWrapper {
+  std::string message = "";
+  bool handled = true;
+};
+
+class ErrorHandler {
+  public:
+    bool raise() {
+      if (getError()->handled) {
+        return false;
+      }
+      this->getScheduler()->scheduleOnUI([this]() mutable {
+        this->raiseSpec();
+      });
+      return true;
+    }
+    virtual std::shared_ptr<Scheduler> getScheduler() = 0;
+    virtual std::shared_ptr<ErrorWrapper> getError() = 0;
+    virtual void setError(std::string message) = 0;
+    virtual ~ErrorHandler() {}
+  protected:
+    virtual void raiseSpec() = 0;
+};
+
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/Logger.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/Logger.h
new file mode 100644
index 0000000..828ba65
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/Logger.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "LoggerInterface.h"
+#include <memory>
+
+namespace reanimated
+{
+
+class Logger {
+  public:
+  template<typename T>
+    static void log(T value) {
+      if (instance == nullptr) {
+        throw std::runtime_error("no logger specified");
+      }
+      instance->log(value);
+    };
+  private:
+    static std::unique_ptr<LoggerInterface> instance;
+};
+
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/LoggerInterface.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/LoggerInterface.h
new file mode 100644
index 0000000..28ea2c9
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/LoggerInterface.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace reanimated
+{
+
+class LoggerInterface {
+  public:
+    virtual void log(const char* str) = 0;
+    virtual void log(double d) = 0;
+    virtual void log(int i) = 0;
+    virtual void log(bool b) = 0;
+    virtual ~LoggerInterface() {}
+};
+
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/SpeedChecker.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/SpeedChecker.h
new file mode 100644
index 0000000..406dd14
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/SpecTools/SpeedChecker.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#define CHECK_SPEED 0
+
+#include "Logger.h"
+
+namespace reanimated
+{
+
+class SpeedChecker {
+public:
+  static void checkSpeed(std::string tag, std::function<void()> fun) {
+#if CHECK_SPEED
+    auto start = std::chrono::system_clock::now();
+#endif
+    fun();
+#if CHECK_SPEED
+    auto end = std::chrono::system_clock::now();
+    std::chrono::duration<double> elapsed_seconds = end-start;
+    tag += " " + std::to_string(elapsed_seconds.count()) + "s";
+    Logger::log(tag.c_str());
+#endif
+  }
+};
+
+}
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/EventHandler.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/EventHandler.h
new file mode 100644
index 0000000..bf663f0
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/EventHandler.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include <string>
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class EventHandlerRegistry;
+
+class EventHandler {
+  friend EventHandlerRegistry;
+
+private:
+  unsigned long id;
+  std::string eventName;
+  jsi::Function handler;
+
+public:
+  EventHandler(unsigned long id,
+               std::string eventName,
+               jsi::Function &&handler): id(id), eventName(eventName), handler(std::move(handler)) {}
+  void process(jsi::Runtime &rt, jsi::Value &eventValue);
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/JSIStoreValueUser.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/JSIStoreValueUser.h
new file mode 100644
index 0000000..da26369
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/JSIStoreValueUser.h
@@ -0,0 +1,33 @@
+#ifndef JSIStoreValueUser_h
+#define JSIStoreValueUser_h
+
+#include <stdio.h>
+#include <memory>
+#include <vector>
+#include <unordered_map>
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class StoreUser {
+  int identifier = 0;
+  static std::atomic<int> ctr;
+  static std::unordered_map<int, std::vector<std::shared_ptr<jsi::Value>>> store;
+  
+public:
+  StoreUser() {
+    identifier = StoreUser::ctr++;
+  }
+  
+  std::weak_ptr<jsi::Value> getWeakRef(jsi::Runtime &rt);
+  void removeRefs();
+  
+  static void clearStore();
+  virtual ~StoreUser();
+};
+
+}
+
+#endif /* JSIStoreValueUser_h */
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/Mapper.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/Mapper.h
new file mode 100644
index 0000000..5af1226
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/Mapper.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include "ShareableValue.h"
+#include "NativeReanimatedModule.h"
+#include <stdio.h>
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+class MapperRegistry;
+
+class Mapper : public std::enable_shared_from_this<Mapper> {
+  friend MapperRegistry;
+private:
+  unsigned long id;
+  NativeReanimatedModule *module;
+  jsi::Function mapper;
+  std::vector<std::shared_ptr<MutableValue>> inputs;
+  std::vector<std::shared_ptr<MutableValue>> outputs;
+  bool dirty = true;
+
+public:
+  Mapper(NativeReanimatedModule *module,
+         unsigned long id,
+         jsi::Function &&mapper,
+         std::vector<std::shared_ptr<MutableValue>> inputs,
+         std::vector<std::shared_ptr<MutableValue>> outputs);
+  void execute(jsi::Runtime &rt);
+  virtual ~Mapper();
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/PlatformDepMethodsHolder.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/PlatformDepMethodsHolder.h
new file mode 100644
index 0000000..6105df0
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/PlatformDepMethodsHolder.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include <stdio.h>
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated
+{
+
+using UpdaterFunction = std::function<void(jsi::Runtime &rt, int viewTag, const jsi::Object& object)>;
+using RequestRender = std::function<void(std::function<void(double)>)>;
+using ScrollToFunction = std::function<void(int, double, double, bool)>;
+using MeasuringFunction = std::function<std::vector<std::pair<std::string, double>>(int)>;
+
+struct PlatformDepMethodsHolder {
+  RequestRender requestRender;
+  UpdaterFunction updaterFunction;
+  ScrollToFunction scrollToFunction;
+  MeasuringFunction measuringFunction;
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/RuntimeDecorator.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/RuntimeDecorator.h
new file mode 100644
index 0000000..d67511c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/RuntimeDecorator.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "PlatformDepMethodsHolder.h"
+#include <stdio.h>
+#include <jsi/jsi.h>
+
+using namespace facebook;
+
+namespace reanimated {
+
+using RequestFrameFunction = std::function<void(std::function<void(double)>)>;
+
+class RuntimeDecorator {
+public:
+  static void addNativeObjects(jsi::Runtime &rt,
+                               UpdaterFunction updater,
+                               RequestFrameFunction requestFrame,
+                               ScrollToFunction scrollTo,
+                               MeasuringFunction measure);
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/Scheduler.h b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/Scheduler.h
new file mode 100644
index 0000000..0d37616
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/Common/cpp/headers/Tools/Scheduler.h
@@ -0,0 +1,88 @@
+#pragma once
+
+#include <queue>
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include <functional>
+#include <ReactCommon/CallInvoker.h>
+
+namespace reanimated
+{
+
+//
+// Copyright (c) 2013 Juan Palacios juan.palacios.puyana@gmail.com
+// Subject to the BSD 2-Clause License
+// - see < http://opensource.org/licenses/BSD-2-Clause>
+//
+template <typename T>
+class Queue
+{
+ public:
+
+  T pop()
+  {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    while (queue_.empty())
+    {
+      cond_.wait(mlock);
+    }
+    auto item = queue_.front();
+    queue_.pop();
+    return item;
+  }
+
+  void pop(T& item)
+  {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    while (queue_.empty())
+    {
+      cond_.wait(mlock);
+    }
+    item = queue_.front();
+    queue_.pop();
+  }
+
+  void push(const T& item)
+  {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    queue_.push(item);
+    mlock.unlock();
+    cond_.notify_one();
+  }
+
+  void push(T&& item)
+  {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    queue_.push(std::move(item));
+    mlock.unlock();
+    cond_.notify_one();
+  }
+
+  size_t getSize() {
+    std::unique_lock<std::mutex> mlock(mutex_);
+    const size_t res = queue_.size();
+    mlock.unlock();
+    cond_.notify_one();
+    return res;
+  }
+
+ private:
+  std::queue<T> queue_;
+  std::mutex mutex_;
+  std::condition_variable cond_;
+};
+
+class Scheduler {
+  public:
+    void scheduleOnJS(std::function<void()> job);
+    void setJSCallInvoker(std::shared_ptr<facebook::react::CallInvoker> jsCallInvoker);
+    virtual void scheduleOnUI(std::function<void()> job);
+    virtual void triggerUI();
+    virtual ~Scheduler();
+  protected:
+    Queue<std::function<void()>> uiJobs;
+    std::shared_ptr<facebook::react::CallInvoker> jsCallInvoker_;
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/LICENSE b/node_modules/react-native-reanimated/react-native-reanimated/LICENSE
new file mode 100644
index 0000000..5b3d7fc
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2016 Krzysztof Magiera
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/README.md b/node_modules/react-native-reanimated/react-native-reanimated/README.md
new file mode 100644
index 0000000..a2d9d66
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/README.md
@@ -0,0 +1,36 @@
+<p align="center">
+  <h1 align="center">React Native Reanimated</h1>
+  <h3 align="center">React Native's Animated library reimplemented</h3>
+</p>
+
+> Reanimated 2 is here! Check out our [documentation page](https://docs.swmansion.com/react-native-reanimated/) for more information
+
+React Native Reanimated provides a more comprehensive,
+low level abstraction for the Animated library API to be built
+on top of and hence allow for much greater flexibility especially when it
+comes to gesture based interactions.
+
+## Installation
+
+Check out [installation](https://docs.swmansion.com/react-native-reanimated/docs/next/installation) section of our docs for the detailed installation instructions.
+
+## Documentation
+
+Check out our dedicated documentation page for info about this library, API reference and more: [https://docs.swmansion.com/react-native-reanimated/docs/](https://docs.swmansion.com/react-native-reanimated/docs/)
+
+## Examples
+
+The source code for the example (showcase) app is under the [`Example/`](https://github.com/software-mansion/react-native-reanimated/blob/master/Example/) directory.
+If you want to play with the API but don't feel like trying it on a real app, you can run the example project. Check Example/ directory README for installation instructions.
+
+## License
+
+Reanimated library is licensed under [The MIT License](LICENSE).
+
+## Credits
+
+This project has been build and is maintained thanks to the support from [Shopify](https://shopify.com), [Expo.io](https://expo.io) and [Software Mansion](https://swmansion.com)
+
+[![shopify](https://avatars1.githubusercontent.com/u/8085?v=3&s=100 'Shopify.com')](https://shopify.com)
+[![expo](https://avatars2.githubusercontent.com/u/12504344?v=3&s=100 'Expo.io')](https://expo.io)
+[![swm](https://logo.swmansion.com/logo?color=white&variant=desktop&width=150&tag=react-native-reanimated-github 'Software Mansion')](https://swmansion.com)
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/RNReanimated.podspec b/node_modules/react-native-reanimated/react-native-reanimated/RNReanimated.podspec
new file mode 100644
index 0000000..c926c51
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/RNReanimated.podspec
@@ -0,0 +1,85 @@
+require "json"
+
+package = JSON.parse(File.read(File.join(__dir__, "package.json")))
+
+reactVersion = '0.0.0'
+
+begin
+  reactVersion = JSON.parse(File.read(File.join(__dir__, "..", "react-native", "package.json")))["version"]
+rescue
+  reactVersion = '0.63.2'
+end
+
+folly_flags = '-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1'
+folly_compiler_flags = folly_flags + ' ' + '-Wno-comma -Wno-shorten-64-to-32'
+folly_version = '2020.01.13.00'
+boost_compiler_flags = '-Wno-documentation'
+
+Pod::Spec.new do |s|
+  s.name         = "RNReanimated"
+  s.version      = package["version"]
+  s.summary      = package["description"]
+  s.description  = <<-DESC
+                  RNReanimated
+                   DESC
+  s.homepage     = "https://github.com/software-mansion/react-native-reanimated"
+  s.license      = "MIT"
+  # s.license    = { :type => "MIT", :file => "FILE_LICENSE" }
+  s.author       = { "author" => "author@domain.cn" }
+  s.platforms    = { :ios => "9.0", :tvos => "9.0" }
+  s.source       = { :git => "https://github.com/software-mansion/react-native-reanimated.git", :tag => "#{s.version}" }
+
+  s.source_files =
+      "ios/**/*.{mm,h,m}",
+      "Common/cpp/**/*.cpp",
+      "Common/cpp/headers/**/*.h"
+  
+  s.pod_target_xcconfig    = {
+    "USE_HEADERMAP" => "YES",
+    "HEADER_SEARCH_PATHS" => "\"$(PODS_TARGET_SRCROOT)/ReactCommon\" \"$(PODS_TARGET_SRCROOT)\" \"$(PODS_ROOT)/Folly\" \"$(PODS_ROOT)/boost-for-react-native\" \"$(PODS_ROOT)/DoubleConversion\" \"$(PODS_ROOT)/Headers/Private/React-Core\" "
+  }
+  s.compiler_flags = folly_compiler_flags + ' ' + boost_compiler_flags
+  s.xcconfig               = { 
+    "CLANG_CXX_LANGUAGE_STANDARD" => "gnu++14",
+    "HEADER_SEARCH_PATHS" => "\"$(PODS_ROOT)/boost-for-react-native\" \"$(PODS_ROOT)/glog\" \"$(PODS_ROOT)/Folly\"",
+                               "OTHER_CFLAGS" => "$(inherited)" + " " + folly_flags  }
+
+  s.requires_arc = true
+
+  s.dependency "React"
+  s.dependency 'FBLazyVector'
+  s.dependency 'FBReactNativeSpec'
+  s.dependency 'RCTRequired'
+  s.dependency 'RCTTypeSafety'
+  s.dependency 'React-Core'
+  s.dependency 'React-CoreModules'
+  s.dependency 'React-Core/DevSupport'
+  s.dependency 'React-RCTActionSheet'
+  s.dependency 'React-RCTNetwork'
+  s.dependency 'React-RCTAnimation'
+  s.dependency 'React-RCTLinking'
+  s.dependency 'React-RCTBlob'
+  s.dependency 'React-RCTSettings'
+  s.dependency 'React-RCTText'
+  s.dependency 'React-RCTVibration'
+  s.dependency 'React-RCTImage'
+  s.dependency 'React-Core/RCTWebSocket'
+  s.dependency 'React-cxxreact'
+  s.dependency 'React-jsi'
+  s.dependency 'React-jsiexecutor'
+  s.dependency 'React-jsinspector'
+  s.dependency 'ReactCommon/turbomodule/core'
+  s.dependency 'Yoga'
+  s.dependency 'DoubleConversion'
+  s.dependency 'glog'
+
+  if reactVersion.match(/^0.62/) 
+    s.dependency 'ReactCommon/callinvoker'
+  else
+    s.dependency 'React-callinvoker'
+  end
+
+  s.dependency 'Folly'
+
+end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/android/build.gradle b/node_modules/react-native-reanimated/react-native-reanimated/android/build.gradle
new file mode 100644
index 0000000..37fe363
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/android/build.gradle
@@ -0,0 +1,9 @@
+import groovy.json.JsonSlurper;
+configurations.maybeCreate("default")
+
+def inputFile = new File(projectDir, '../../react-native/package.json')
+def json = new JsonSlurper().parseText(inputFile.text)
+def reactNativeVersion = json.version as String
+def (major, minor, patch) = reactNativeVersion.tokenize('.')
+
+artifacts.add("default", file("react-native-reanimated-${minor}.aar"))
\ No newline at end of file
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated-62.aar b/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated-62.aar
new file mode 100644
index 0000000..e98c56c
Binary files /dev/null and b/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated-62.aar differ
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated-63.aar b/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated-63.aar
new file mode 100644
index 0000000..17ef040
Binary files /dev/null and b/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated-63.aar differ
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated.aar b/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated.aar
new file mode 100644
index 0000000..4f97d86
Binary files /dev/null and b/node_modules/react-native-reanimated/react-native-reanimated/android/react-native-reanimated.aar differ
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/android/src/AndroidManifest.xml b/node_modules/react-native-reanimated/react-native-reanimated/android/src/AndroidManifest.xml
new file mode 100644
index 0000000..586ffb9
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/android/src/AndroidManifest.xml
@@ -0,0 +1,5 @@
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.swmansion.reanimated">
+
+</manifest>
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedProxyPackage.java b/node_modules/react-native-reanimated/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedProxyPackage.java
new file mode 100644
index 0000000..177ea17
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/android/src/main/java/com/swmansion/reanimated/ReanimatedProxyPackage.java
@@ -0,0 +1,15 @@
+package com.swmansion.reanimated;
+
+import com.facebook.react.ReactPackage;
+import com.facebook.react.bridge.NativeModule;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.uimanager.ViewManager;
+
+import java.util.Arrays;
+import java.util.List;
+
+import com.swmansion.reanimated.ReanimatedPackage;
+
+public class ReanimatedPackage implements ReactPackage {
+  // dummy package
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/.DS_Store b/node_modules/react-native-reanimated/react-native-reanimated/ios/.DS_Store
new file mode 100644
index 0000000..8de4422
Binary files /dev/null and b/node_modules/react-native-reanimated/react-native-reanimated/ios/.DS_Store differ
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAAlwaysNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAAlwaysNode.h
new file mode 100644
index 0000000..589251c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAAlwaysNode.h
@@ -0,0 +1,4 @@
+#import "REANode.h"
+
+@interface REAAlwaysNode : REANode <REAFinalNode>
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAAlwaysNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAAlwaysNode.m
new file mode 100644
index 0000000..0e3efa3
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAAlwaysNode.m
@@ -0,0 +1,36 @@
+#import "REAAlwaysNode.h"
+#import "REAUtils.h"
+#import "REANodesManager.h"
+#import "REAStyleNode.h"
+#import "REAModule.h"
+#import <React/RCTLog.h>
+#import <React/RCTConvert.h>
+#import <React/RCTUIManager.h>
+
+@implementation REAAlwaysNode
+{
+  NSNumber * _nodeToBeEvaluated;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+    if ((self = [super initWithID:nodeID config:config])) {
+      _nodeToBeEvaluated = [RCTConvert NSNumber:config[@"what"]];
+      REA_LOG_ERROR_IF_NIL(_nodeToBeEvaluated, @"Reanimated: First argument passed to always node is either of wrong type or is missing.");
+    }
+    return self;
+}
+
+- (id)evaluate
+{
+  [[self.nodesManager findNodeByID:_nodeToBeEvaluated] value];
+  return @(0);
+}
+
+- (void)update
+{
+  [self value];
+}
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABezierNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABezierNode.h
new file mode 100644
index 0000000..0e0a953
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABezierNode.h
@@ -0,0 +1,5 @@
+#import "REANode.h"
+
+@interface REABezierNode : REANode
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABezierNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABezierNode.m
new file mode 100644
index 0000000..1c311fe
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABezierNode.m
@@ -0,0 +1,103 @@
+#include <tgmath.h>
+
+#import "REABezierNode.h"
+#import "REAUtils.h"
+#import "REANodesManager.h"
+#import <React/RCTConvert.h>
+#import <React/RCTLog.h>
+
+#define EPS 1e-5
+
+@implementation REABezierNode {
+  CGFloat ax, bx, cx, ay, by, cy;
+  NSNumber *_inputNodeID;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _inputNodeID = [RCTConvert NSNumber:config[@"input"]];
+    REA_LOG_ERROR_IF_NIL(_inputNodeID, @"Reanimated: First argument passed to bezier node is either of wrong type or is missing.");
+
+    CGFloat mX1 = [config[@"mX1"] doubleValue];
+    CGFloat mY1 = [config[@"mY1"] doubleValue];
+    CGFloat mX2 = [config[@"mX2"] doubleValue];
+    CGFloat mY2 = [config[@"mY2"] doubleValue];
+
+    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
+    cx = 3.0 * mX1;
+    bx = 3.0 * (mX2 - mX1) - cx;
+    ax = 1.0 - cx -bx;
+
+    cy = 3.0 * mY1;
+    by = 3.0 * (mY2 - mY1) - cy;
+    ay = 1.0 - cy - by;
+  }
+  return self;
+}
+
+- (CGFloat)sampleCurveX:(CGFloat)t
+{
+  // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
+  return ((ax * t + bx) * t + cx) * t;
+}
+
+- (CGFloat)sampleCurveY:(CGFloat)t
+{
+  return ((ay * t + by) * t + cy) * t;
+}
+
+- (CGFloat)sampleCurveDerivativeX:(CGFloat)t
+{
+  return (3.0 * ax * t + 2.0 * bx) * t + cx;
+}
+
+- (CGFloat)solveCurveX:(CGFloat)x withEpsilon:(CGFloat)epsilon
+{
+  CGFloat t0, t1, t2, x2, d2;
+  NSUInteger i;
+
+  // First try a few iterations of Newton's method -- normally very fast.
+  for (t2 = x, i = 0; i < 8; i++) {
+    x2 = [self sampleCurveX:t2] - x;
+    if (fabs (x2) < epsilon)
+      return t2;
+    d2 = [self sampleCurveDerivativeX:t2];
+    if (fabs(d2) < 1e-6)
+      break;
+    t2 = t2 - x2 / d2;
+  }
+
+  // Fall back to the bisection method for reliability.
+  t0 = 0.0;
+  t1 = 1.0;
+  t2 = x;
+
+  if (t2 < t0)
+    return t0;
+  if (t2 > t1)
+    return t1;
+
+  while (t0 < t1) {
+    x2 = [self sampleCurveX:t2];
+    if (fabs(x2 - x) < epsilon)
+      return t2;
+    if (x > x2)
+      t0 = t2;
+    else
+      t1 = t2;
+    t2 = (t1 - t0) * .5 + t0;
+  }
+
+  // Failure.
+  return t2;
+}
+
+- (id)evaluate
+{
+  CGFloat x = [[[self.nodesManager findNodeByID:_inputNodeID] value] doubleValue];
+  CGFloat y = [self sampleCurveY:[self solveCurveX:x withEpsilon:EPS]];
+  return @(y);
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABlockNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABlockNode.h
new file mode 100644
index 0000000..54f412c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABlockNode.h
@@ -0,0 +1,5 @@
+#import "REANode.h"
+
+@interface REABlockNode : REANode
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABlockNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABlockNode.m
new file mode 100644
index 0000000..daa29e6
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REABlockNode.m
@@ -0,0 +1,25 @@
+#import "REABlockNode.h"
+#import "REANodesManager.h"
+
+@implementation REABlockNode {
+  NSArray<NSNumber *> *_block;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _block = config[@"block"];
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  id result;
+  for (NSNumber *inputID in _block) {
+    result = [[self.nodesManager findNodeByID:inputID] value];
+  }
+  return result;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACallFuncNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACallFuncNode.h
new file mode 100644
index 0000000..4502724
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACallFuncNode.h
@@ -0,0 +1,7 @@
+
+#import "REANode.h"
+
+@interface REACallFuncNode : REANode
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACallFuncNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACallFuncNode.m
new file mode 100644
index 0000000..e864e71
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACallFuncNode.m
@@ -0,0 +1,67 @@
+
+
+#import "REACallFuncNode.h"
+#import "REAFunctionNode.h"
+#import "REAUtils.h"
+#import "REAParamNode.h"
+#import "REANodesManager.h"
+
+@implementation REACallFuncNode {
+  NSNumber *_whatNodeID;
+  NSArray<NSNumber *> *_args;
+  NSArray<NSNumber *> *_params;
+  NSString* _prevCallID;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _whatNodeID = config[@"what"];
+    REA_LOG_ERROR_IF_NIL(_whatNodeID, @"Reanimated: First argument passed to callFunc node is either of wrong type or is missing.");
+    _args = config[@"args"];
+    _params = config[@"params"];
+    _prevCallID = NULL;
+  }
+  return self;
+}
+
+- (void)beginContext
+{
+  // To ensure that functions can be called multiple times in the same animation frame 
+  // (functions might have different parameters and might be called multiple times)
+  // we inform the current update context about where we are called from by setting the
+  // current call id - this will ensure that memoization is correct for function nodes.
+  _prevCallID = self.updateContext.callID;
+  self.updateContext.callID = [NSString stringWithFormat:@"%@/%@", self.updateContext.callID, [self.nodeID stringValue]];
+  
+  // A CallFuncNode has a reference to a function node which holds the node graph that should
+  // be updated. A Function node has a list of ParamNodes which are basically nodes that can
+  // reference other nodes. When we start a new function call we update the parameter nodes
+  // with the current arguments:
+  for (NSUInteger i = 0; i < _params.count; i++) {
+    NSNumber *paramID = [_params objectAtIndex:i];
+    REAParamNode *param = (REAParamNode *)[self.nodesManager findNodeByID:paramID];
+    [param beginContext:_args[i] prevCallID:_prevCallID];
+  }
+}
+
+- (void)endContext
+{
+  for (NSUInteger i = 0; i < _params.count; i++) {
+    NSNumber *paramID = [_params objectAtIndex:i];
+    REAParamNode *param = (REAParamNode *)[self.nodesManager findNodeByID:paramID];
+    [param endContext];
+  }
+  self.updateContext.callID = _prevCallID;
+}
+
+- (id)evaluate
+{
+  [self beginContext];
+  REAFunctionNode *what = (REAFunctionNode *)[self.nodesManager findNodeByID:_whatNodeID];
+  NSNumber *newValue = [what value];
+  [self endContext];
+  return newValue;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAClockNodes.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAClockNodes.h
new file mode 100644
index 0000000..fc0fc08
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAClockNodes.h
@@ -0,0 +1,19 @@
+#import "REANode.h"
+
+@interface REAClockNode : REANode
+@property (nonatomic, readonly) BOOL isRunning;
+- (void)start;
+- (void)stop;
+@end
+
+@interface REAClockOpNode : REANode
+@end
+
+@interface REAClockStartNode : REAClockOpNode
+@end
+
+@interface REAClockStopNode : REAClockOpNode
+@end
+
+@interface REAClockTestNode : REAClockOpNode
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAClockNodes.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAClockNodes.m
new file mode 100644
index 0000000..ba5aa00
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAClockNodes.m
@@ -0,0 +1,116 @@
+#import "REAClockNodes.h"
+#import "REAUtils.h"
+#import "REANodesManager.h"
+#import "REAParamNode.h"
+#import <React/RCTConvert.h>
+#import <React/RCTLog.h>
+
+@interface REAClockNode ()
+
+@property (nonatomic) NSNumber *lastTimestampMs;
+
+@end
+
+@implementation REAClockNode
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _isRunning = NO;
+  }
+  return self;
+}
+
+- (void)start
+{
+  if (_isRunning) return;
+  _isRunning = YES;
+
+  __block __weak void (^weak_animationClb)(CADisplayLink *displayLink);
+  void (^animationClb)(CADisplayLink *displayLink);
+  __weak REAClockNode *weakSelf = self;
+
+  weak_animationClb = animationClb = ^(CADisplayLink *displayLink) {
+    if (!weakSelf.isRunning) return;
+    [weakSelf markUpdated];
+    [weakSelf.nodesManager postOnAnimation:weak_animationClb];
+  };
+
+  [self.nodesManager postOnAnimation:animationClb];
+}
+
+- (void)stop
+{
+  _isRunning = false;
+}
+
+- (id)evaluate
+{
+  return @(self.nodesManager.currentAnimationTimestamp * 1000.);
+}
+
+@end
+
+@implementation REAClockOpNode {
+  NSNumber *_clockNodeID;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _clockNodeID = [RCTConvert NSNumber:config[@"clock"]];
+    REA_LOG_ERROR_IF_NIL(_clockNodeID, @"Reanimated: First argument passed to clock node is either of wrong type or is missing.");
+  }
+  return self;
+}
+
+- (REANode*)clockNode
+{
+  return (REANode*)[self.nodesManager findNodeByID:_clockNodeID];
+}
+
+@end
+
+@implementation REAClockStartNode
+
+- (id)evaluate
+{
+  REANode* node = [self clockNode];
+  if ([node isKindOfClass:[REAParamNode class]]) {
+    [(REAParamNode* )node start];
+  } else {
+    [(REAClockNode* )node start];
+  }
+  return @(0);
+}
+
+@end
+
+@implementation REAClockStopNode
+
+- (id)evaluate
+{
+  REANode* node = [self clockNode];
+  if ([node isKindOfClass:[REAParamNode class]]) {
+    [(REAParamNode* )node stop];
+  } else {
+    [(REAClockNode* )node stop];
+  }
+  return @(0);
+}
+
+
+@end
+
+@implementation REAClockTestNode
+
+- (id)evaluate
+{
+  REANode* node = [self clockNode];
+  if ([node isKindOfClass:[REAParamNode class]]) {
+    return @(((REAParamNode* )node).isRunning ? 1 : 0);
+  }
+  return @([(REAClockNode* )node isRunning] ? 1 : 0);
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAConcatNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAConcatNode.h
new file mode 100644
index 0000000..d275eec
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAConcatNode.h
@@ -0,0 +1,6 @@
+#import "REANode.h"
+
+@interface REAConcatNode : REANode
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAConcatNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAConcatNode.m
new file mode 100644
index 0000000..57cbdeb
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAConcatNode.m
@@ -0,0 +1,32 @@
+#import "REAConcatNode.h"
+#import "REAValueNode.h"
+#import "REANodesManager.h"
+
+@implementation REAConcatNode {
+  NSArray<NSNumber *> *_input;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _input = config[@"input"];
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  NSMutableString *result = [NSMutableString new];
+  for (int i = 0; i < _input.count; i++) {
+    NSObject *val = [[self.nodesManager findNodeByID:_input[i]] value];
+    if ([val isKindOfClass:[NSNumber class]]) {
+      [result appendString:[(NSNumber *)val stringValue]];
+    }
+    if ([val isKindOfClass:[NSString class]]) {
+      [result appendString:val];
+    }
+  }
+  return result;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACondNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACondNode.h
new file mode 100644
index 0000000..3e4a173
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACondNode.h
@@ -0,0 +1,5 @@
+#import "REANode.h"
+
+@interface REACondNode : REANode
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACondNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACondNode.m
new file mode 100644
index 0000000..d011840
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REACondNode.m
@@ -0,0 +1,34 @@
+#import "REACondNode.h"
+#import "REANodesManager.h"
+#import <React/RCTConvert.h>
+#import "REAUtils.h"
+#import <React/RCTLog.h>
+
+@implementation REACondNode {
+  NSNumber *_condNodeID;
+  NSNumber *_ifBlockID;
+  NSNumber *_elseBlockID;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _condNodeID = [RCTConvert NSNumber:config[@"cond"]];
+    REA_LOG_ERROR_IF_NIL(_condNodeID, @"Reanimated: First argument passed to cond node is either of wrong type or is missing.");
+    _ifBlockID = [RCTConvert NSNumber:config[@"ifBlock"]];
+    REA_LOG_ERROR_IF_NIL(_ifBlockID, @"Reanimated: Second argument passed to cond node is either of wrong type or is missing.");
+    _elseBlockID = [RCTConvert NSNumber:config[@"elseBlock"]];
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  id cond = [[self.nodesManager findNodeByID:_condNodeID] value];
+  if ([cond doubleValue]) {
+    return [[self.nodesManager findNodeByID:_ifBlockID] value];
+  }
+  return _elseBlockID != nil ? [[self.nodesManager findNodeByID:_elseBlockID] value] : @(0);
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/READebugNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/READebugNode.h
new file mode 100644
index 0000000..cd7cd3e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/READebugNode.h
@@ -0,0 +1,5 @@
+#import "REANode.h"
+
+@interface READebugNode : REANode
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/READebugNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/READebugNode.m
new file mode 100644
index 0000000..b0321ad
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/READebugNode.m
@@ -0,0 +1,29 @@
+#import "READebugNode.h"
+#import "REAUtils.h"
+#import "REANodesManager.h"
+#import <React/RCTConvert.h>
+#import <React/RCTLog.h>
+
+@implementation READebugNode {
+  NSNumber *_valueNodeID;
+  NSString *_message;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _message = [RCTConvert NSString:config[@"message"]];
+    _valueNodeID = [RCTConvert NSNumber:config[@"value"]];
+    REA_LOG_ERROR_IF_NIL(_valueNodeID, @"Reanimated: Second argument passed to debug node is either of wrong type or is missing.");
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  id value = [[self.nodesManager findNodeByID:_valueNodeID] value];
+  NSLog(@"%@ %@", _message, value);
+  return value;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAEventNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAEventNode.h
new file mode 100644
index 0000000..73027f1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAEventNode.h
@@ -0,0 +1,9 @@
+#import "REANode.h"
+
+#import <React/RCTEventDispatcher.h>
+
+@interface REAEventNode : REANode
+
+- (void)processEvent:(id<RCTEvent>)event;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAEventNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAEventNode.m
new file mode 100644
index 0000000..5187153
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAEventNode.m
@@ -0,0 +1,35 @@
+#import "REAEventNode.h"
+#import "REANodesManager.h"
+#import "REAValueNode.h"
+
+@implementation REAEventNode {
+  NSArray *_argMapping;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _argMapping = config[@"argMapping"];
+  }
+  return self;
+}
+
+- (void)processEvent:(id<RCTEvent>)event
+{
+  NSArray *args = event.arguments;
+  // argMapping is an array of eventPaths, each even path ends with a target node ID
+  for (NSArray *eventPath in _argMapping) {
+    // Supported events args are in the following order: viewTag, eventName, eventData.
+    id value = args[2];
+    for (NSUInteger i = 0; i < eventPath.count; i++) {
+      if (i < eventPath.count - 1) {
+        value = [value valueForKey:eventPath[i]];
+      } else {
+        REAValueNode *node = (REAValueNode *)[self.nodesManager findNodeByID:eventPath[i]];
+        [node setValue:value];
+      }
+    }
+  }
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAFunctionNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAFunctionNode.h
new file mode 100644
index 0000000..4b6ef73
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAFunctionNode.h
@@ -0,0 +1,7 @@
+
+#import "REANode.h"
+
+@interface REAFunctionNode : REANode
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAFunctionNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAFunctionNode.m
new file mode 100644
index 0000000..ad5c310
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAFunctionNode.m
@@ -0,0 +1,24 @@
+
+#import "REAFunctionNode.h"
+#import "REAParamNode.h"
+#import "REANodesManager.h"
+
+@implementation REAFunctionNode {
+  NSNumber *_nodeToBeEvaluated;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _nodeToBeEvaluated = config[@"what"];
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  REANode *node = [self.nodesManager findNodeByID:_nodeToBeEvaluated];
+  return [node value];
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAJSCallNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAJSCallNode.h
new file mode 100644
index 0000000..f13a803
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAJSCallNode.h
@@ -0,0 +1,5 @@
+#import "REANode.h"
+
+@interface REAJSCallNode : REANode
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAJSCallNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAJSCallNode.m
new file mode 100644
index 0000000..1232297
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAJSCallNode.m
@@ -0,0 +1,31 @@
+#import "REAJSCallNode.h"
+#import "REANodesManager.h"
+#import "REAModule.h"
+
+@implementation REAJSCallNode {
+  NSArray<NSNumber *> *_input;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _input = config[@"input"];
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  NSMutableArray *args = [NSMutableArray arrayWithCapacity:_input.count];
+  for (NSUInteger i = 0; i < _input.count; i++) {
+    args[i] = [[self.nodesManager findNodeByID:_input[i]] value];
+  }
+
+  [self.nodesManager.reanimatedModule
+   sendEventWithName:@"onReanimatedCall"
+   body:@{@"id": self.nodeID, @"args": args }];
+
+  return @(0);
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REANode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REANode.h
new file mode 100644
index 0000000..0ef571d
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REANode.h
@@ -0,0 +1,41 @@
+#import <Foundation/Foundation.h>
+#import <UIKit/UIKit.h>
+
+@class REANodesManager;
+
+typedef NSNumber* REANodeID;
+
+@protocol REAFinalNode
+
+- (void)update;
+
+@end
+
+@interface REAUpdateContext : NSObject
+@property (nonatomic) NSString* callID;
+@end
+
+@interface REANode : NSObject
+
++ (void)runPropUpdates:(nonnull REAUpdateContext *)context;
+
+- (instancetype)initWithID:(REANodeID)nodeID
+                    config:(NSDictionary<NSString *, id> *)config NS_DESIGNATED_INITIALIZER;
+
+@property (nonatomic, weak, nullable) REANodesManager *nodesManager;
+@property (nonatomic, nullable) REAUpdateContext *updateContext;
+@property (nonatomic, readonly, nonnull) REANodeID nodeID;
+
+- (_Nullable id)evaluate;
+- (_Nullable id)value;
+- (void)markUpdated;
+
+- (void)addChild:(REANode *)child NS_REQUIRES_SUPER;
+- (void)removeChild:(REANode *)child NS_REQUIRES_SUPER;
+
+- (void)dangerouslyRescheduleEvaluate;
+- (void)forceUpdateMemoizedValue:(id)value;
+
+- (void)onDrop;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REANode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REANode.m
new file mode 100644
index 0000000..ac8efdd
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REANode.m
@@ -0,0 +1,157 @@
+#import "REANode.h"
+#import "REANodesManager.h"
+
+#import <React/RCTDefines.h>
+
+@interface REAUpdateContext ()
+
+@property (nonatomic, nonnull) NSMutableArray<REANode *> *updatedNodes;
+@property (nonatomic) NSNumber* loopID;
+
+@end
+
+@implementation REAUpdateContext
+
+- (instancetype)init
+{
+  if ((self = [super init])) {
+    _loopID = [[NSNumber alloc] initWithInt:1];
+    _updatedNodes = [NSMutableArray new];
+    _callID = @"";
+  }
+  return self;
+}
+
+@end
+
+
+@interface REANode ()
+
+@property (nonatomic) NSMutableDictionary<REANodeID, NSNumber*>* lastLoopID;
+@property (nonatomic) NSMutableDictionary<REANodeID, id>* memoizedValue;
+@property (nonatomic, nullable) NSMutableArray<REANode *> *childNodes;
+
+@end
+
+@implementation REANode
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super init])) {
+    _nodeID = nodeID;
+    _lastLoopID = [NSMutableDictionary dictionary];
+    _memoizedValue = [NSMutableDictionary dictionary];
+    _lastLoopID[@""] = 0;
+  }
+  return self;
+}
+
+RCT_NOT_IMPLEMENTED(- (instancetype)init)
+
+- (void)dangerouslyRescheduleEvaluate
+{
+  _lastLoopID[self.updateContext.callID] = 0;
+  [self markUpdated];
+}
+
+- (void)forceUpdateMemoizedValue:(id)value
+{
+  _memoizedValue[self.updateContext.callID] = value;
+  [self markUpdated];
+}
+
+- (id)evaluate
+{
+  return 0;
+}
+
+- (id)value
+{
+  if (![_lastLoopID objectForKey:_updateContext.callID] || [[_lastLoopID objectForKey:_updateContext.callID] longValue] < [_updateContext.loopID longValue]) {
+    [_lastLoopID setObject:_updateContext.loopID forKey:_updateContext.callID];
+    id val = [self evaluate];
+    [_memoizedValue setObject:(val == nil ? [NSNull null] : val) forKey:_updateContext.callID];
+    return val;
+  }
+  id memoizedValue = [_memoizedValue objectForKey:_updateContext.callID];
+  return [memoizedValue isKindOfClass:[NSNull class]] ? nil : memoizedValue;
+}
+
+- (void)addChild:(REANode *)child
+{
+  if (!_childNodes) {
+    _childNodes = [NSMutableArray new];
+  }
+  if (child) {
+    [_childNodes addObject:child];
+    [child dangerouslyRescheduleEvaluate];
+  }
+}
+
+- (void)removeChild:(REANode *)child
+{
+  if (child) {
+    [_childNodes removeObject:child];
+  }
+}
+
+- (void)markUpdated
+{
+  [_updateContext.updatedNodes addObject:self];
+  [self.nodesManager postRunUpdatesAfterAnimation];
+}
+
++ (NSMutableArray<REANode *> *)updatedNodes
+{
+  static NSMutableArray<REANode *> *updatedNodes;
+  static dispatch_once_t onceToken;
+  dispatch_once(&onceToken, ^{
+    updatedNodes = [NSMutableArray new];
+  });
+  return updatedNodes;
+}
+
++ (void)findAndUpdateNodes:(nonnull REANode *)node
+            withVisitedSet:(NSMutableSet<REANode *> *)visitedNodes
+            withFinalNodes:(NSMutableArray<id<REAFinalNode>> *)finalNodes
+{
+  if ([visitedNodes containsObject:node]) {
+    return;
+  } else {
+    [visitedNodes addObject:node];
+  }
+  for (REANode *child in node.childNodes) {
+    [self findAndUpdateNodes:child withVisitedSet:visitedNodes withFinalNodes:finalNodes];
+  }
+  if ([node conformsToProtocol:@protocol(REAFinalNode)]) {
+    [finalNodes addObject:(id<REAFinalNode>)node];
+  }
+}
+
++ (void)runPropUpdates:(REAUpdateContext *)context
+{
+  NSMutableSet<REANode *> *visitedNodes = [NSMutableSet new];
+  NSMutableArray<id<REAFinalNode>> *finalNodes = [NSMutableArray new];
+  for (NSUInteger i = 0; i < context.updatedNodes.count; i++) {
+    [self findAndUpdateNodes:context.updatedNodes[i]
+              withVisitedSet:visitedNodes
+              withFinalNodes:finalNodes];
+    if (i == context.updatedNodes.count - 1) {
+      while (finalNodes.count > 0) {
+        // NSMutableArray used for stack implementation
+        [[finalNodes lastObject] update];
+        [finalNodes removeLastObject];
+      }
+    }
+  }
+
+  [context.updatedNodes removeAllObjects];
+  context.loopID = [[NSNumber alloc] initWithLong:context.loopID.longValue + 1];
+}
+
+- (void)onDrop
+{
+  //noop
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAOperatorNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAOperatorNode.h
new file mode 100644
index 0000000..50c1689
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAOperatorNode.h
@@ -0,0 +1,5 @@
+#import "REANode.h"
+
+@interface REAOperatorNode : REANode
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAOperatorNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAOperatorNode.m
new file mode 100644
index 0000000..915dd0f
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAOperatorNode.m
@@ -0,0 +1,114 @@
+#include <tgmath.h>
+
+#import "REAOperatorNode.h"
+#import "REANodesManager.h"
+
+typedef id (^REAOperatorBlock)(NSArray<REANode *> *inputNodes);
+
+#define REA_REDUCE(OP) ^(NSArray<REANode *> *inputNodes) { \
+double acc = [[inputNodes[0] value] doubleValue]; \
+for (NSUInteger i = 1; i < inputNodes.count; i++) { \
+  double a = acc, b = [[inputNodes[i] value] doubleValue]; \
+  acc = OP; \
+} \
+return @(acc); \
+}
+
+#define REA_SINGLE(OP) ^(NSArray<REANode *> *inputNodes) { \
+double a = [[inputNodes[0] value] doubleValue]; \
+return @(OP); \
+}
+
+#define REA_INFIX(OP) ^(NSArray<REANode *> *inputNodes) { \
+double a = [[inputNodes[0] value] doubleValue]; \
+double b = [[inputNodes[1] value] doubleValue]; \
+return @(OP); \
+}
+
+@implementation REAOperatorNode {
+  NSArray<NSNumber *> *_input;
+  NSMutableArray<REANode *> *_inputNodes;
+  REAOperatorBlock _op;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  static NSDictionary *OPS;
+  static dispatch_once_t opsToken;
+  dispatch_once(&opsToken, ^{
+    OPS = @{
+            // arithmetic
+            @"add": REA_REDUCE(a + b),
+            @"sub": REA_REDUCE(a - b),
+            @"multiply": REA_REDUCE(a * b),
+            @"divide": REA_REDUCE(a / b),
+            @"pow": REA_REDUCE(pow(a, b)),
+            @"modulo": REA_REDUCE(fmod(fmod(a, b) + b, b)),
+            @"sqrt": REA_SINGLE(sqrt(a)),
+            @"log": REA_SINGLE(log(a)),
+            @"sin": REA_SINGLE(sin(a)),
+            @"cos": REA_SINGLE(cos(a)),
+            @"tan": REA_SINGLE(tan(a)),
+            @"acos": REA_SINGLE(acos(a)),
+            @"asin": REA_SINGLE(asin(a)),
+            @"atan": REA_SINGLE(atan(a)),
+            @"exp": REA_SINGLE(exp(a)),
+            @"round": REA_SINGLE(round(a)),
+            @"abs": REA_SINGLE(fabs(a)),
+            @"ceil": REA_SINGLE(ceil(a)),
+            @"floor": REA_SINGLE(floor(a)),
+            @"max": REA_REDUCE(MAX(a, b)),
+            @"min": REA_REDUCE(MIN(a, b)),
+
+            // logical
+            @"and": ^(NSArray<REANode *> *inputNodes) {
+              BOOL res = [[inputNodes[0] value] doubleValue];
+              for (NSUInteger i = 1; i < inputNodes.count && res; i++) {
+                res = res && [[inputNodes[i] value] doubleValue];
+              }
+              return res ? @(1.) : @(0.);
+            },
+            @"or": ^(NSArray<REANode *> *inputNodes) {
+              BOOL res = [[inputNodes[0] value] doubleValue];
+              for (NSUInteger i = 1; i < inputNodes.count && !res; i++) {
+                res = res || [[inputNodes[i] value] doubleValue];
+              }
+              return res ? @(1.) : @(0.);
+            },
+            @"not": REA_SINGLE(!a),
+            @"defined": ^(NSArray<REANode *> *inputNodes) {
+              id val = [inputNodes[0] value];
+              id res = @(val != nil && !([val isKindOfClass:[NSNumber class]] && isnan([val doubleValue])));
+              return res;
+            },
+
+            // comparing
+            @"lessThan": REA_INFIX(a < b),
+            @"eq": REA_INFIX(a == b),
+            @"greaterThan": REA_INFIX(a > b),
+            @"lessOrEq": REA_INFIX(a <= b),
+            @"greaterOrEq": REA_INFIX(a >= b),
+             @"neq": REA_INFIX(a != b),
+            };
+  });
+  if ((self = [super initWithID:nodeID config:config])) {
+    _input = config[@"input"];
+    _inputNodes = [NSMutableArray arrayWithCapacity:_input.count];
+    _op = OPS[config[@"op"]];
+    if (!_op) {
+      RCTLogError(@"Operator '%@' not found", config[@"op"]);
+    }
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  for (NSUInteger i = 0; i < _input.count; i++) {
+    _inputNodes[i] = [self.nodesManager findNodeByID:_input[i]];
+  }
+  return _op(_inputNodes);
+}
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAParamNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAParamNode.h
new file mode 100644
index 0000000..b5e97e8
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAParamNode.h
@@ -0,0 +1,12 @@
+#import "REAValueNode.h"
+
+@interface REAParamNode : REAValueNode
+
+- (void)beginContext:(NSNumber*) ref
+          prevCallID:(NSNumber*) prevCallID;
+- (void)endContext;
+- (void)start;
+- (void)stop;
+- (BOOL)isRunning;
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAParamNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAParamNode.m
new file mode 100644
index 0000000..6b8e27f
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAParamNode.m
@@ -0,0 +1,81 @@
+#import "REAParamNode.h"
+#import "REAValueNode.h"
+#import "REANodesManager.h"
+#import "REAClockNodes.h"
+
+@implementation REAParamNode {
+  NSMutableArray<REANodeID> *_argstack;
+  NSString *_prevCallID;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _argstack = [NSMutableArray<REANodeID> arrayWithCapacity:0];
+  }
+  return self;
+}
+
+- (void)setValue:(NSNumber *)value
+{
+  REANode *node = [self.nodesManager findNodeByID:[_argstack lastObject]];
+  NSString *callID = self.updateContext.callID;
+  self.updateContext.callID = _prevCallID;
+  [(REAValueNode*)node setValue:value];
+  self.updateContext.callID = callID;
+  [self forceUpdateMemoizedValue:value];
+}
+
+- (void)beginContext:(NSNumber*) ref
+          prevCallID:(NSString*) prevCallID
+{
+  _prevCallID = prevCallID;
+  [_argstack addObject:ref];
+}
+
+- (void)endContext
+{
+  [_argstack removeLastObject];
+}
+
+
+- (id)evaluate
+{
+  NSString *callID = self.updateContext.callID;
+  self.updateContext.callID = _prevCallID;
+  REANode * node = [self.nodesManager findNodeByID:[_argstack lastObject]];
+  id val = [node value];
+  self.updateContext.callID = callID;
+  return val;
+}
+
+- (void)start
+{
+  REANode* node = [self.nodesManager findNodeByID:[_argstack lastObject]];
+  if ([node isKindOfClass:[REAParamNode class]]) {
+    [(REAParamNode* )node start];
+  } else {
+    [(REAClockNode* )node start];
+  }
+}
+
+- (void)stop
+{
+  REANode* node = [self.nodesManager findNodeByID:[_argstack lastObject]];
+  if ([node isKindOfClass:[REAParamNode class]]) {
+    [(REAParamNode* )node stop];
+  } else {
+    [(REAClockNode* )node stop];
+  }
+}
+
+- (BOOL)isRunning
+{
+  REANode* node = [self.nodesManager findNodeByID:[_argstack lastObject]];
+  if ([node isKindOfClass:[REAParamNode class]]) {
+    return [(REAParamNode* )node isRunning];
+  }
+  return [(REAClockNode* )node isRunning];
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAPropsNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAPropsNode.h
new file mode 100644
index 0000000..05171f1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAPropsNode.h
@@ -0,0 +1,11 @@
+#import "REANode.h"
+
+@interface REAPropsNode : REANode <REAFinalNode>
+
+- (void)connectToView:(NSNumber *_Nonnull)viewTag
+             viewName:(NSString *_Nonnull)viewName;
+
+- (void)disconnectFromView:(NSNumber *_Nonnull)viewTag;
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAPropsNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAPropsNode.m
new file mode 100644
index 0000000..3212537
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAPropsNode.m
@@ -0,0 +1,101 @@
+#import "REAPropsNode.h"
+
+#import "REANodesManager.h"
+#import "REAStyleNode.h"
+#import "REAModule.h"
+
+#import <React/RCTLog.h>
+#import <React/RCTUIManager.h>
+#import "React/RCTComponentData.h"
+
+@implementation REAPropsNode
+{
+  NSNumber *_connectedViewTag;
+  NSString *_connectedViewName;
+  NSMutableDictionary<NSString *, REANodeID> *_propsConfig;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID
+                    config:(NSDictionary<NSString *,id> *)config
+{
+  if (self = [super initWithID:nodeID config:config]) {
+    _propsConfig = config[@"props"];
+  }
+  return self;
+}
+
+- (void)connectToView:(NSNumber *)viewTag
+             viewName:(NSString *)viewName
+{
+  _connectedViewTag = viewTag;
+  _connectedViewName = viewName;
+  [self dangerouslyRescheduleEvaluate];
+}
+
+- (void)disconnectFromView:(NSNumber *)viewTag
+{
+  _connectedViewTag = nil;
+  _connectedViewName = nil;
+}
+
+- (id)evaluate
+{
+  NSMutableDictionary *uiProps = [NSMutableDictionary new];
+  NSMutableDictionary *nativeProps = [NSMutableDictionary new];
+  NSMutableDictionary *jsProps = [NSMutableDictionary new];
+  
+  void (^addBlock)(NSString *key, id obj, BOOL * stop) = ^(NSString *key, id obj, BOOL * stop){
+    if ([self.nodesManager.uiProps containsObject:key]) {
+      uiProps[key] = obj;
+    } else if ([self.nodesManager.nativeProps containsObject:key]) {
+      nativeProps[key] = obj;
+    } else {
+      jsProps[key] = obj;
+    }
+  };
+  
+  for (NSString *prop in _propsConfig) {
+    REANode *propNode = [self.nodesManager findNodeByID:_propsConfig[prop]];
+    
+    if ([propNode isKindOfClass:[REAStyleNode class]]) {
+      [[propNode value] enumerateKeysAndObjectsUsingBlock:addBlock];
+    } else {
+      addBlock(prop, [propNode value], nil);
+    }
+  }
+  
+  if (_connectedViewTag != nil) {
+    if (uiProps.count > 0) {
+      [self.nodesManager.uiManager
+       synchronouslyUpdateViewOnUIThread:_connectedViewTag
+       viewName:_connectedViewName
+       props:uiProps];
+    }
+    if (nativeProps.count > 0) {
+      [self.nodesManager enqueueUpdateViewOnNativeThread:_connectedViewTag viewName:_connectedViewName nativeProps:nativeProps];
+    }
+    if (jsProps.count > 0) {
+      [self.nodesManager.reanimatedModule
+       sendEventWithName:@"onReanimatedPropsChange"
+       body:@{@"viewTag": _connectedViewTag, @"props": jsProps }];
+    }
+  }
+  
+  return @(0);
+}
+
+- (void)update
+{
+  // Since we are updating nodes after detaching them from views there is a time where it's
+  // possible that the view was disconnected and still receive an update, this is normal and we can
+  // simply skip that update.
+  if (!_connectedViewTag) {
+    return;
+  }
+
+  // triger for side effect
+  [self value];
+}
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REASetNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REASetNode.h
new file mode 100644
index 0000000..5bc6a38
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REASetNode.h
@@ -0,0 +1,6 @@
+#import "REANode.h"
+
+@interface REASetNode : REANode
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REASetNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REASetNode.m
new file mode 100644
index 0000000..9be5b1e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REASetNode.m
@@ -0,0 +1,32 @@
+#import "REASetNode.h"
+#import "REAUtils.h"
+#import <React/RCTConvert.h>
+#import <React/RCTLog.h>
+#import "REAValueNode.h"
+#import "REANodesManager.h"
+
+@implementation REASetNode {
+  NSNumber *_whatNodeID;
+  NSNumber *_valueNodeID;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _whatNodeID = [RCTConvert NSNumber:config[@"what"]];
+    REA_LOG_ERROR_IF_NIL(_whatNodeID, @"Reanimated: First argument passed to set node is either of wrong type or is missing.");
+    _valueNodeID = [RCTConvert NSNumber:config[@"value"]];
+    REA_LOG_ERROR_IF_NIL(_valueNodeID, @"Reanimated: Second argument passed to set node is either of wrong type or is missing.");
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  NSNumber *newValue = [[self.nodesManager findNodeByID:_valueNodeID] value];
+  REAValueNode *what = (REAValueNode *)[self.nodesManager findNodeByID:_whatNodeID];
+  [what setValue:newValue];
+  return newValue;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAStyleNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAStyleNode.h
new file mode 100644
index 0000000..58bc7ba
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAStyleNode.h
@@ -0,0 +1,6 @@
+#import "REANode.h"
+
+@interface REAStyleNode : REANode
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAStyleNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAStyleNode.m
new file mode 100644
index 0000000..fbd80a7
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAStyleNode.m
@@ -0,0 +1,30 @@
+#import "REAStyleNode.h"
+
+#import "REANodesManager.h"
+
+@implementation REAStyleNode
+{
+  NSMutableDictionary<NSString *, REANodeID> *_styleConfig;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID
+                    config:(NSDictionary<NSString *, id> *)config;
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _styleConfig = config[@"style"];
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  NSMutableDictionary *styles = [NSMutableDictionary new];
+  for (NSString *prop in _styleConfig) {
+    REANode *propNode = [self.nodesManager findNodeByID:_styleConfig[prop]];
+    styles[prop] = [propNode value];
+  }
+
+  return styles;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REATransformNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REATransformNode.h
new file mode 100644
index 0000000..51ae259
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REATransformNode.h
@@ -0,0 +1,6 @@
+#import "REANode.h"
+
+@interface REATransformNode : REANode
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REATransformNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REATransformNode.m
new file mode 100644
index 0000000..ff427ca
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REATransformNode.m
@@ -0,0 +1,38 @@
+#import "REATransformNode.h"
+#import <React/RCTConvert.h>
+#import "REANodesManager.h"
+
+@implementation REATransformNode
+{
+  NSArray<id> *_transformConfigs;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID config:(NSDictionary<NSString *,id> *)config
+{
+  if ((self = [super initWithID:nodeID config:config])) {
+    _transformConfigs = config[@"transform"];
+  }
+  return self;
+}
+
+- (id)evaluate
+{
+  NSMutableArray<NSDictionary *> *transform = [NSMutableArray arrayWithCapacity:_transformConfigs.count];
+  for (NSDictionary *transformConfig in _transformConfigs) {
+    NSString *property = transformConfig[@"property"];
+    REANodeID nodeID = [RCTConvert NSNumber:transformConfig[@"nodeID"]];
+    NSNumber *value;
+    if (nodeID) {
+      REANode *node = [self.nodesManager findNodeByID:nodeID];
+      value = [node value];
+    } else {
+      value = transformConfig[@"value"];
+    }
+    [transform addObject:@{property: value}];
+  }
+
+  return transform;
+}
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAValueNode.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAValueNode.h
new file mode 100644
index 0000000..8de5023
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAValueNode.h
@@ -0,0 +1,11 @@
+#import <UIKit/UIKit.h>
+
+#import "REANode.h"
+
+@class REAValueNode;
+
+@interface REAValueNode : REANode
+
+- (void)setValue:(NSNumber *)value;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAValueNode.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAValueNode.m
new file mode 100644
index 0000000..16254d1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Nodes/REAValueNode.m
@@ -0,0 +1,28 @@
+#import "REAValueNode.h"
+
+@implementation REAValueNode {
+  NSNumber *_value;
+}
+
+- (instancetype)initWithID:(REANodeID)nodeID
+                    config:(NSDictionary<NSString *, id> *)config
+{
+    if (self = [super initWithID:nodeID config:config]) {
+        _value = config[@"value"];
+    }
+    return self;
+}
+
+- (void)setValue:(NSNumber *)value
+{
+  _value = value;
+  [self forceUpdateMemoizedValue:value];
+}
+
+- (id)evaluate
+{
+  return _value;
+}
+
+@end
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/REAModule.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/REAModule.h
new file mode 100644
index 0000000..85ac1fb
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/REAModule.h
@@ -0,0 +1,16 @@
+#import <React/RCTBridgeModule.h>
+#import <React/RCTEventDispatcher.h>
+#import <React/RCTEventEmitter.h>
+#import <React/RCTUIManager.h>
+#import <React/RCTUIManagerObserverCoordinator.h>
+#import <React/RCTUIManagerUtils.h>
+
+#import "REAValueNode.h"
+
+extern RCTBridge *_bridge_reanimated;
+
+@interface REAModule : RCTEventEmitter <RCTBridgeModule, RCTEventDispatcherObserver, RCTUIManagerObserver>
+
+@property (nonatomic, readonly) REANodesManager *nodesManager;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/REAModule.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/REAModule.m
new file mode 100644
index 0000000..e349282
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/REAModule.m
@@ -0,0 +1,197 @@
+#import "REAModule.h"
+
+#import "REANodesManager.h"
+#import "Transitioning/REATransitionManager.h"
+#import "native/NativeProxy.h"
+
+typedef void (^AnimatedOperation)(REANodesManager *nodesManager);
+
+RCTBridge *_bridge_reanimated = nil;
+
+@implementation REAModule
+{
+  NSMutableArray<AnimatedOperation> *_operations;
+  REATransitionManager *_transitionManager;
+}
+
+RCT_EXPORT_MODULE(ReanimatedModule);
+
+- (void)invalidate
+{
+  _bridge_reanimated = nil;
+  _transitionManager = nil;
+  [_nodesManager invalidate];
+  [self.bridge.eventDispatcher removeDispatchObserver:self];
+  [self.bridge.uiManager.observerCoordinator removeObserver:self];
+}
+
+- (dispatch_queue_t)methodQueue
+{
+  // This module needs to be on the same queue as the UIManager to avoid
+  // having to lock `_operations` and `_preOperations` since `uiManagerWillPerformMounting`
+  // will be called from that queue.
+  return RCTGetUIManagerQueue();
+}
+
+- (void)setBridge:(RCTBridge *)bridge
+{
+  [super setBridge:bridge];
+
+  _nodesManager = [[REANodesManager alloc] initWithModule:self
+                                                uiManager:self.bridge.uiManager];
+  _operations = [NSMutableArray new];
+
+  _transitionManager = [[REATransitionManager alloc] initWithUIManager:self.bridge.uiManager];
+
+  [bridge.eventDispatcher addDispatchObserver:self];
+  [bridge.uiManager.observerCoordinator addObserver:self];
+}
+
+#pragma mark -- Transitioning API
+
+RCT_EXPORT_METHOD(animateNextTransition:(nonnull NSNumber *)rootTag config:(NSDictionary *)config)
+{
+  [_transitionManager animateNextTransitionInRoot:rootTag withConfig:config];
+}
+
+#pragma mark -- API
+
+RCT_EXPORT_METHOD(createNode:(nonnull NSNumber *)nodeID
+                  config:(NSDictionary<NSString *, id> *)config)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager createNode:nodeID config:config];
+  }];
+}
+
+RCT_EXPORT_METHOD(dropNode:(nonnull NSNumber *)nodeID)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager dropNode:nodeID];
+  }];
+}
+
+RCT_EXPORT_METHOD(getValue:(nonnull NSNumber *)nodeID
+                  callback:(RCTResponseSenderBlock)callback) {
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager getValue:nodeID callback:(RCTResponseSenderBlock)callback];
+  }];
+}
+
+RCT_EXPORT_METHOD(connectNodes:(nonnull NSNumber *)parentID
+                  childTag:(nonnull NSNumber *)childID)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager connectNodes:parentID childID:childID];
+  }];
+}
+
+RCT_EXPORT_METHOD(disconnectNodes:(nonnull NSNumber *)parentID
+                  childTag:(nonnull NSNumber *)childID)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager disconnectNodes:parentID childID:childID];
+  }];
+}
+
+RCT_EXPORT_METHOD(connectNodeToView:(nonnull NSNumber *)nodeID
+                  viewTag:(nonnull NSNumber *)viewTag)
+{
+  NSString *viewName = [self.bridge.uiManager viewNameForReactTag:viewTag];
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager connectNodeToView:nodeID viewTag:viewTag viewName:viewName];
+  }];
+}
+
+RCT_EXPORT_METHOD(disconnectNodeFromView:(nonnull NSNumber *)nodeID
+                  viewTag:(nonnull NSNumber *)viewTag)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager disconnectNodeFromView:nodeID viewTag:viewTag];
+  }];
+}
+
+RCT_EXPORT_METHOD(attachEvent:(nonnull NSNumber *)viewTag
+                  eventName:(nonnull NSString *)eventName
+                  eventNodeID:(nonnull NSNumber *)eventNodeID)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager attachEvent:viewTag eventName:eventName eventNodeID:eventNodeID];
+  }];
+}
+
+RCT_EXPORT_METHOD(detachEvent:(nonnull NSNumber *)viewTag
+                  eventName:(nonnull NSString *)eventName
+                  eventNodeID:(nonnull NSNumber *)eventNodeID)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager detachEvent:viewTag eventName:eventName eventNodeID:eventNodeID];
+  }];
+}
+
+RCT_EXPORT_METHOD(configureProps:(nonnull NSArray<NSString *> *)nativeProps
+                         uiProps:(nonnull NSArray<NSString *> *)uiProps)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager configureProps:[NSSet setWithArray:nativeProps] uiProps:[NSSet setWithArray:uiProps]];
+  }];
+}
+
+RCT_EXPORT_METHOD(setValue:(nonnull NSNumber *)nodeID
+                  newValue:(nonnull NSNumber *)newValue
+                  )
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager setValueForNodeID:nodeID value:newValue];
+  }];
+}
+
+RCT_EXPORT_METHOD(triggerRender)
+{
+  [self addOperationBlock:^(REANodesManager *nodesManager) {
+    [nodesManager postRunUpdatesAfterAnimation];
+  }];
+}
+
+#pragma mark -- Batch handling
+
+- (void)addOperationBlock:(AnimatedOperation)operation
+{
+  [_operations addObject:operation];
+}
+
+#pragma mark - RCTUIManagerObserver
+
+- (void)uiManagerWillPerformMounting:(RCTUIManager *)uiManager
+{
+  if (_operations.count == 0) {
+    return;
+  }
+
+  NSArray<AnimatedOperation> *operations = _operations;
+  _operations = [NSMutableArray new];
+
+  REANodesManager *nodesManager = _nodesManager;
+
+  [uiManager addUIBlock:^(__unused RCTUIManager *manager, __unused NSDictionary<NSNumber *, UIView *> *viewRegistry) {
+    for (AnimatedOperation operation in operations) {
+      operation(nodesManager);
+    }
+    [nodesManager operationsBatchDidComplete];
+  }];
+}
+
+#pragma mark -- Events
+
+- (NSArray<NSString *> *)supportedEvents
+{
+  return @[@"onReanimatedCall", @"onReanimatedPropsChange"];
+}
+
+- (void)eventDispatcherWillDispatchEvent:(id<RCTEvent>)event
+{
+  // Events can be dispatched from any queue
+  [_nodesManager dispatchEvent:event];
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/REANodesManager.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/REANodesManager.h
new file mode 100644
index 0000000..a4c3213
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/REANodesManager.h
@@ -0,0 +1,88 @@
+#import <Foundation/Foundation.h>
+
+#import "REANode.h"
+#import <React/RCTBridgeModule.h>
+#import <React/RCTUIManager.h>
+
+@class REAModule;
+
+typedef void (^REAOnAnimationCallback)(CADisplayLink *displayLink);
+typedef void (^REANativeAnimationOp)(RCTUIManager *uiManager);
+typedef void (^REAEventHandler)(NSString *eventName, id<RCTEvent> event);
+
+@interface REANodesManager : NSObject
+
+@property (nonatomic, weak, nullable) RCTUIManager *uiManager;
+@property (nonatomic, weak, nullable) REAModule *reanimatedModule;
+@property (nonatomic, readonly) CFTimeInterval currentAnimationTimestamp;
+
+@property (nonatomic, nullable) NSSet<NSString *> *uiProps;
+@property (nonatomic, nullable) NSSet<NSString *> *nativeProps;
+
+- (nonnull instancetype)initWithModule:(REAModule *)reanimatedModule
+                             uiManager:(nonnull RCTUIManager *)uiManager;
+
+- (REANode* _Nullable)findNodeByID:(nonnull REANodeID)nodeID;
+
+- (void)invalidate;
+
+- (void)operationsBatchDidComplete;
+
+//
+
+- (void)postOnAnimation:(REAOnAnimationCallback)clb;
+- (void)postRunUpdatesAfterAnimation;
+- (void)registerEventHandler:(REAEventHandler)eventHandler;
+- (void)enqueueUpdateViewOnNativeThread:(nonnull NSNumber *)reactTag
+                               viewName:(NSString *) viewName
+                            nativeProps:(NSMutableDictionary *)nativeProps;
+- (void)getValue:(REANodeID)nodeID
+        callback:(RCTResponseSenderBlock)callback;
+
+// graph
+
+- (void)createNode:(nonnull REANodeID)tag
+            config:(NSDictionary<NSString *, id> *__nonnull)config;
+
+- (void)dropNode:(nonnull REANodeID)tag;
+
+- (void)connectNodes:(nonnull REANodeID)parentID
+             childID:(nonnull REANodeID)childID;
+
+- (void)disconnectNodes:(nonnull REANodeID)parentID
+                childID:(nonnull REANodeID)childID;
+
+- (void)connectNodeToView:(nonnull REANodeID)nodeID
+                  viewTag:(nonnull NSNumber *)viewTag
+                 viewName:(nonnull NSString *)viewName;
+
+- (void)disconnectNodeFromView:(nonnull REANodeID)nodeID
+                       viewTag:(nonnull NSNumber *)viewTag;
+
+- (void)attachEvent:(nonnull NSNumber *)viewTag
+          eventName:(nonnull NSString *)eventName
+        eventNodeID:(nonnull REANodeID)eventNodeID;
+
+- (void)detachEvent:(nonnull NSNumber *)viewTag
+          eventName:(nonnull NSString *)eventName
+        eventNodeID:(nonnull REANodeID)eventNodeID;
+
+// configuration
+
+- (void)configureProps:(nonnull NSSet<NSString *> *)nativeProps
+               uiProps:(nonnull NSSet<NSString *> *)uiProps;
+
+- (void)updateProps:(nonnull NSDictionary *)props
+      ofViewWithTag:(nonnull NSNumber *)viewTag
+           viewName:(nonnull NSString *)viewName;
+
+- (NSString*)obtainProp:(nonnull NSNumber *)viewTag
+          propName:(nonnull NSString *)propName;
+
+// events
+
+- (void)dispatchEvent:(id<RCTEvent>)event;
+
+- (void)setValueForNodeID:(nonnull NSNumber *)nodeID value:(nonnull NSNumber *)newValue;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/REANodesManager.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/REANodesManager.m
new file mode 100644
index 0000000..e6f926b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/REANodesManager.m
@@ -0,0 +1,535 @@
+#import "REANodesManager.h"
+
+#import <React/RCTConvert.h>
+
+#import "Nodes/REANode.h"
+#import "Nodes/REAPropsNode.h"
+#import "Nodes/REAStyleNode.h"
+#import "Nodes/REATransformNode.h"
+#import "Nodes/REAValueNode.h"
+#import "Nodes/REABlockNode.h"
+#import "Nodes/REACondNode.h"
+#import "Nodes/REAOperatorNode.h"
+#import "Nodes/REASetNode.h"
+#import "Nodes/READebugNode.h"
+#import "Nodes/REAClockNodes.h"
+#import "Nodes/REAJSCallNode.h"
+#import "Nodes/REABezierNode.h"
+#import "Nodes/REAEventNode.h"
+#import "REAModule.h"
+#import "Nodes/REAAlwaysNode.h"
+#import "Nodes/REAConcatNode.h"
+#import "Nodes/REAParamNode.h"
+#import "Nodes/REAFunctionNode.h"
+#import "Nodes/REACallFuncNode.h"
+#import <React/RCTShadowView.h>
+
+// Interface below has been added in order to use private methods of RCTUIManager,
+// RCTUIManager#UpdateView is a React Method which is exported to JS but in
+// Objective-C it stays private
+// RCTUIManager#setNeedsLayout is a method which updated layout only which
+// in its turn will trigger relayout if no batch has been activated
+
+@interface RCTUIManager ()
+
+- (void)updateView:(nonnull NSNumber *)reactTag
+          viewName:(NSString *)viewName
+             props:(NSDictionary *)props;
+
+- (void)setNeedsLayout;
+
+@end
+
+@interface REANodesManager() <RCTUIManagerObserver>
+
+@property BOOL shouldInterceptMountingBlock;
+
+@end
+
+
+@implementation REANodesManager
+{
+  NSMutableDictionary<REANodeID, REANode *> *_nodes;
+  NSMapTable<NSString *, REANode *> *_eventMapping;
+  NSMutableArray<id<RCTEvent>> *_eventQueue;
+  CADisplayLink *_displayLink;
+  REAUpdateContext *_updateContext;
+  BOOL _wantRunUpdates;
+  BOOL _processingDirectEvent;
+  NSMutableArray<REAOnAnimationCallback> *_onAnimationCallbacks;
+  NSMutableArray<REANativeAnimationOp> *_operationsInBatch;
+  REAEventHandler _eventHandler;
+  volatile void (^_mounting)(void);
+}
+
+- (instancetype)initWithModule:(REAModule *)reanimatedModule
+                     uiManager:(RCTUIManager *)uiManager
+{
+  if ((self = [super init])) {
+    _reanimatedModule = reanimatedModule;
+    _uiManager = uiManager;
+    _nodes = [NSMutableDictionary new];
+    _eventMapping = [NSMapTable strongToWeakObjectsMapTable];
+    _eventQueue = [NSMutableArray new];
+    _updateContext = [REAUpdateContext new];
+    _wantRunUpdates = NO;
+    _onAnimationCallbacks = [NSMutableArray new];
+    _operationsInBatch = [NSMutableArray new];
+    _shouldInterceptMountingBlock = NO;
+    [[uiManager observerCoordinator] addObserver:self];
+  }
+  return self;
+}
+
+- (void)dealloc {
+  [[_uiManager observerCoordinator] removeObserver:self];
+}
+
+- (void)invalidate
+{
+  _eventHandler = nil;
+  [self stopUpdatingOnAnimationFrame];
+}
+
+- (void)operationsBatchDidComplete
+{
+  if (_displayLink) {
+    // if display link is set it means some of the operations that have run as a part of the batch
+    // requested updates. We want updates to be run in the same frame as in which operations have
+    // been scheduled as it may mean the new view has just been mounted and expects its initial
+    // props to be calculated.
+    // Unfortunately if the operation has just scheduled animation callback it won't run until the
+    // next frame, so it's being triggered manually.
+    _wantRunUpdates = YES;
+    [self performOperations];
+  }
+}
+
+- (REANode *)findNodeByID:(REANodeID)nodeID
+{
+  return _nodes[nodeID];
+}
+
+- (void)postOnAnimation:(REAOnAnimationCallback)clb
+{
+  [_onAnimationCallbacks addObject:clb];
+  [self startUpdatingOnAnimationFrame];
+}
+
+- (void)postRunUpdatesAfterAnimation
+{
+  _wantRunUpdates = YES;
+  if (!_processingDirectEvent) {
+    [self startUpdatingOnAnimationFrame];
+  }
+}
+
+- (void)registerEventHandler:(REAEventHandler)eventHandler
+{
+  _eventHandler = eventHandler;
+}
+
+- (void)startUpdatingOnAnimationFrame
+{
+  if (!_displayLink) {
+    // Setting _currentAnimationTimestamp here is connected with manual triggering of performOperations
+    // in operationsBatchDidComplete. If new node has been created and clock has not been started,
+    // _displayLink won't be initialized soon enough and _displayLink.timestamp will be 0.
+    // However, CADisplayLink is using CACurrentMediaTime so if there's need to perform one more
+    // evaluation, it could be used it here. In usual case, CACurrentMediaTime is not being used in
+    // favor of setting it with _displayLink.timestamp in onAnimationFrame method.
+    _currentAnimationTimestamp = CACurrentMediaTime();
+    _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(onAnimationFrame:)];
+    [_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
+  }
+}
+
+- (void)stopUpdatingOnAnimationFrame
+{
+  if (_displayLink) {
+    [_displayLink invalidate];
+    _displayLink = nil;
+  }
+}
+
+- (void)onAnimationFrame:(CADisplayLink *)displayLink
+{
+  _currentAnimationTimestamp = _displayLink.timestamp;
+
+  // We process all enqueued events first
+  for (NSUInteger i = 0; i < _eventQueue.count; i++) {
+    id<RCTEvent> event = _eventQueue[i];
+    [self processEvent:event];
+  }
+  [_eventQueue removeAllObjects];
+
+  NSArray<REAOnAnimationCallback> *callbacks = _onAnimationCallbacks;
+  _onAnimationCallbacks = [NSMutableArray new];
+
+  // When one of the callbacks would postOnAnimation callback we don't want
+  // to process it until the next frame. This is why we cpy the array before
+  // we iterate over it
+  for (REAOnAnimationCallback block in callbacks) {
+    block(displayLink);
+  }
+
+  [self performOperations];
+
+  if (_onAnimationCallbacks.count == 0) {
+    [self stopUpdatingOnAnimationFrame];
+  }
+}
+
+- (BOOL)uiManager:(RCTUIManager *)manager performMountingWithBlock:(RCTUIManagerMountingBlock)block {
+  if (_shouldInterceptMountingBlock) {
+    _mounting = block;
+    return YES;
+  }
+  return NO;
+}
+
+- (void)performOperations
+{
+  if (_wantRunUpdates) {
+    [REANode runPropUpdates:_updateContext];
+  }
+  if (_operationsInBatch.count != 0) {
+    NSMutableArray<REANativeAnimationOp> *copiedOperationsQueue = _operationsInBatch;
+    _operationsInBatch = [NSMutableArray new];
+    
+    __weak typeof(self) weakSelf = self;
+    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
+    RCTExecuteOnUIManagerQueue(^{
+      __typeof__(self) strongSelf = weakSelf;
+      if (strongSelf == nil) {
+        return;
+      }
+      NSMutableArray *pendingUIBlocks = [strongSelf.uiManager valueForKey:@"_pendingUIBlocks"];
+      bool canPerformLayout = ([pendingUIBlocks count] == 0);
+      
+      if (!canPerformLayout) {
+        dispatch_semaphore_signal(semaphore);
+      }
+      
+      for (int i = 0; i < copiedOperationsQueue.count; i++) {
+        copiedOperationsQueue[i](strongSelf.uiManager);
+      }
+      
+      if (canPerformLayout) {
+        strongSelf.shouldInterceptMountingBlock = YES;
+        [strongSelf.uiManager batchDidComplete];
+        strongSelf.shouldInterceptMountingBlock = NO;
+        dispatch_semaphore_signal(semaphore);
+      } else {
+        [strongSelf.uiManager setNeedsLayout];
+      }
+    });
+    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
+    
+    if (_mounting) {
+      _mounting();
+      _mounting = nil;
+    }
+  }
+  _wantRunUpdates = NO;
+}
+
+- (void)enqueueUpdateViewOnNativeThread:(nonnull NSNumber *)reactTag
+                               viewName:(NSString *) viewName
+                            nativeProps:(NSMutableDictionary *)nativeProps {
+  [_operationsInBatch addObject:^(RCTUIManager *uiManager) {
+    [uiManager updateView:reactTag viewName:viewName props:nativeProps];
+  }];
+}
+
+- (void)getValue:(REANodeID)nodeID
+        callback:(RCTResponseSenderBlock)callback
+{
+  id val = _nodes[nodeID].value;
+  if (val) {
+    callback(@[val]);
+  } else {
+    // NULL is not an object and it's not possible to pass it as callback's argument
+    callback(@[[NSNull null]]);
+  }
+}
+
+#pragma mark -- Graph
+
+- (void)createNode:(REANodeID)nodeID
+            config:(NSDictionary<NSString *, id> *)config
+{
+  static NSDictionary *map;
+  static dispatch_once_t mapToken;
+  dispatch_once(&mapToken, ^{
+    map = @{@"props": [REAPropsNode class],
+            @"style": [REAStyleNode class],
+            @"transform": [REATransformNode class],
+            @"value": [REAValueNode class],
+            @"block": [REABlockNode class],
+            @"cond": [REACondNode class],
+            @"op": [REAOperatorNode class],
+            @"set": [REASetNode class],
+            @"debug": [READebugNode class],
+            @"clock": [REAClockNode class],
+            @"clockStart": [REAClockStartNode class],
+            @"clockStop": [REAClockStopNode class],
+            @"clockTest": [REAClockTestNode class],
+            @"call": [REAJSCallNode class],
+            @"bezier": [REABezierNode class],
+            @"event": [REAEventNode class],
+            @"always": [REAAlwaysNode class],
+            @"concat": [REAConcatNode class],
+            @"param": [REAParamNode class],
+            @"func": [REAFunctionNode class],
+            @"callfunc": [REACallFuncNode class]
+//            @"listener": nil,
+            };
+  });
+
+  NSString *nodeType = [RCTConvert NSString:config[@"type"]];
+
+  Class nodeClass = map[nodeType];
+  if (!nodeClass) {
+    RCTLogError(@"Animated node type %@ not supported natively", nodeType);
+    return;
+  }
+
+  REANode *node = [[nodeClass alloc] initWithID:nodeID config:config];
+  node.nodesManager = self;
+  node.updateContext = _updateContext;
+  _nodes[nodeID] = node;
+}
+
+- (void)dropNode:(REANodeID)nodeID
+{
+  REANode *node = _nodes[nodeID];
+  if (node) {
+    [node onDrop];
+    [_nodes removeObjectForKey:nodeID];
+  }
+}
+
+- (void)connectNodes:(nonnull NSNumber *)parentID childID:(nonnull REANodeID)childID
+{
+  RCTAssertParam(parentID);
+  RCTAssertParam(childID);
+
+  REANode *parentNode = _nodes[parentID];
+  REANode *childNode = _nodes[childID];
+
+  RCTAssertParam(childNode);
+
+  [parentNode addChild:childNode];
+}
+
+- (void)disconnectNodes:(REANodeID)parentID childID:(REANodeID)childID
+{
+  RCTAssertParam(parentID);
+  RCTAssertParam(childID);
+
+  REANode *parentNode = _nodes[parentID];
+  REANode *childNode = _nodes[childID];
+
+  RCTAssertParam(childNode);
+
+  [parentNode removeChild:childNode];
+}
+
+- (void)connectNodeToView:(REANodeID)nodeID
+                  viewTag:(NSNumber *)viewTag
+                 viewName:(NSString *)viewName
+{
+  RCTAssertParam(nodeID);
+  REANode *node = _nodes[nodeID];
+  RCTAssertParam(node);
+
+  if ([node isKindOfClass:[REAPropsNode class]]) {
+    [(REAPropsNode *)node connectToView:viewTag viewName:viewName];
+  }
+}
+
+- (void)disconnectNodeFromView:(REANodeID)nodeID
+                       viewTag:(NSNumber *)viewTag
+{
+  RCTAssertParam(nodeID);
+  REANode *node = _nodes[nodeID];
+  RCTAssertParam(node);
+
+  if ([node isKindOfClass:[REAPropsNode class]]) {
+    [(REAPropsNode *)node disconnectFromView:viewTag];
+  }
+}
+
+- (void)attachEvent:(NSNumber *)viewTag
+          eventName:(NSString *)eventName
+        eventNodeID:(REANodeID)eventNodeID
+{
+  RCTAssertParam(eventNodeID);
+  REANode *eventNode = _nodes[eventNodeID];
+  RCTAssert([eventNode isKindOfClass:[REAEventNode class]], @"Event node is of an invalid type");
+
+  NSString *key = [NSString stringWithFormat:@"%@%@",
+                   viewTag,
+                   RCTNormalizeInputEventName(eventName)];
+  RCTAssert([_eventMapping objectForKey:key] == nil, @"Event handler already set for the given view and event type");
+  [_eventMapping setObject:eventNode forKey:key];
+}
+
+- (void)detachEvent:(NSNumber *)viewTag
+          eventName:(NSString *)eventName
+        eventNodeID:(REANodeID)eventNodeID
+{
+  NSString *key = [NSString stringWithFormat:@"%@%@",
+                   viewTag,
+                   RCTNormalizeInputEventName(eventName)];
+  [_eventMapping removeObjectForKey:key];
+}
+
+- (void)processEvent:(id<RCTEvent>)event
+{
+  NSString *key = [NSString stringWithFormat:@"%@%@",
+                   event.viewTag,
+                   RCTNormalizeInputEventName(event.eventName)];
+  REAEventNode *eventNode = [_eventMapping objectForKey:key];
+  [eventNode processEvent:event];
+}
+
+- (void)processDirectEvent:(id<RCTEvent>)event
+{
+  _processingDirectEvent = YES;
+  [self processEvent:event];
+  [self performOperations];
+  _processingDirectEvent = NO;
+}
+
+- (BOOL)isDirectEvent:(id<RCTEvent>)event
+{
+  static NSArray<NSString *> *directEventNames;
+  static dispatch_once_t directEventNamesToken;
+  dispatch_once(&directEventNamesToken, ^{
+    directEventNames = @[
+      @"topContentSizeChange",
+      @"topMomentumScrollBegin",
+      @"topMomentumScrollEnd",
+      @"topScroll",
+      @"topScrollBeginDrag",
+      @"topScrollEndDrag"
+    ];
+  });
+
+  return [directEventNames containsObject:RCTNormalizeInputEventName(event.eventName)];
+}
+
+- (void)dispatchEvent:(id<RCTEvent>)event
+{
+  NSString *key = [NSString stringWithFormat:@"%@%@",
+                   event.viewTag,
+                   RCTNormalizeInputEventName(event.eventName)];
+
+  NSString *eventHash = [NSString stringWithFormat:@"%@%@",
+  event.viewTag,
+  event.eventName];
+
+  if (_eventHandler != nil) {
+    __weak REAEventHandler eventHandler = _eventHandler;
+    __weak typeof(self) weakSelf = self;
+    RCTExecuteOnMainQueue(^void(){
+      __typeof__(self) strongSelf = weakSelf;
+      if (strongSelf == nil) {
+        return;
+      }
+      eventHandler(eventHash, event);
+      if ([strongSelf isDirectEvent:event]) {
+        [strongSelf performOperations];
+      }
+    });
+  }
+
+  REANode *eventNode = [_eventMapping objectForKey:key];
+
+  if (eventNode != nil) {
+    if ([self isDirectEvent:event]) {
+      // Bypass the event queue/animation frames and process scroll events
+      // immediately to avoid getting out of sync with the scroll position
+      [self processDirectEvent:event];
+    } else {
+      // enqueue node to be processed
+      [_eventQueue addObject:event];
+      [self startUpdatingOnAnimationFrame];
+    }
+  }
+}
+
+- (void)configureProps:(NSSet<NSString *> *)nativeProps
+               uiProps:(NSSet<NSString *> *)uiProps
+{
+  _uiProps = uiProps;
+  _nativeProps = nativeProps;
+}
+
+- (void)setValueForNodeID:(nonnull NSNumber *)nodeID value:(nonnull NSNumber *)newValue
+{
+  RCTAssertParam(nodeID);
+
+  REANode *node = _nodes[nodeID];
+
+  REAValueNode *valueNode = (REAValueNode *)node;
+  [valueNode setValue:newValue];
+}
+
+- (void)updateProps:(nonnull NSDictionary *)props
+      ofViewWithTag:(nonnull NSNumber *)viewTag
+           viewName:(nonnull NSString *)viewName
+{
+  // TODO: refactor PropsNode to also use this function
+  NSMutableDictionary *uiProps = [NSMutableDictionary new];
+  NSMutableDictionary *nativeProps = [NSMutableDictionary new];
+  NSMutableDictionary *jsProps = [NSMutableDictionary new];
+
+  void (^addBlock)(NSString *key, id obj, BOOL * stop) = ^(NSString *key, id obj, BOOL * stop){
+    if ([self.uiProps containsObject:key]) {
+      uiProps[key] = obj;
+    } else if ([self.nativeProps containsObject:key]) {
+      nativeProps[key] = obj;
+    } else {
+      jsProps[key] = obj;
+    }
+  };
+
+  [props enumerateKeysAndObjectsUsingBlock:addBlock];
+
+  if (uiProps.count > 0) {
+    [self.uiManager
+     synchronouslyUpdateViewOnUIThread:viewTag
+     viewName:viewName
+     props:uiProps];
+    }
+    if (nativeProps.count > 0) {
+      [self enqueueUpdateViewOnNativeThread:viewTag viewName:viewName nativeProps:nativeProps];
+    }
+    if (jsProps.count > 0) {
+      [self.reanimatedModule sendEventWithName:@"onReanimatedPropsChange"
+                                          body:@{@"viewTag": viewTag, @"props": jsProps }];
+    }
+}
+
+- (NSString*)obtainProp:(nonnull NSNumber *)viewTag
+               propName:(nonnull NSString *)propName
+{
+    UIView* view = [self.uiManager viewForReactTag:viewTag];
+    
+    NSString* result = [NSString stringWithFormat:@"error: unknown propName %@, currently supported: opacity, zIndex", propName];
+    
+    if ([propName isEqualToString:@"opacity"]) {
+        CGFloat alpha = view.alpha;
+        result = [@(alpha) stringValue];
+    } else if ([propName isEqualToString:@"zIndex"]) {
+        NSInteger zIndex = view.reactZIndex;
+        result = [@(zIndex) stringValue];
+    }
+    
+    return result;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/REAUtils.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/REAUtils.h
new file mode 100644
index 0000000..1eb8ad7
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/REAUtils.h
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+
+#define REA_LOG_ERROR_IF_NIL(value, errorMsg) ({\
+  if (value == nil) RCTLogError(errorMsg);\
+})
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/RNReanimated.xcodeproj/project.pbxproj b/node_modules/react-native-reanimated/react-native-reanimated/ios/RNReanimated.xcodeproj/project.pbxproj
new file mode 100644
index 0000000..df7566c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/RNReanimated.xcodeproj/project.pbxproj
@@ -0,0 +1,609 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 46;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		440FEC2C209062F100EEC73A /* REAPropsNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC0D209062F100EEC73A /* REAPropsNode.m */; };
+		440FEC2D209062F100EEC73A /* REAStyleNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC13209062F100EEC73A /* REAStyleNode.m */; };
+		440FEC2E209062F100EEC73A /* READebugNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC14209062F100EEC73A /* READebugNode.m */; };
+		440FEC2F209062F100EEC73A /* REAClockNodes.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC18209062F100EEC73A /* REAClockNodes.m */; };
+		440FEC30209062F100EEC73A /* REAValueNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC19209062F100EEC73A /* REAValueNode.m */; };
+		440FEC31209062F100EEC73A /* REACondNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1A209062F100EEC73A /* REACondNode.m */; };
+		440FEC32209062F100EEC73A /* REAJSCallNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1B209062F100EEC73A /* REAJSCallNode.m */; };
+		440FEC33209062F100EEC73A /* REABezierNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1C209062F100EEC73A /* REABezierNode.m */; };
+		440FEC34209062F100EEC73A /* REANode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1F209062F100EEC73A /* REANode.m */; };
+		440FEC35209062F100EEC73A /* REATransformNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC20209062F100EEC73A /* REATransformNode.m */; };
+		440FEC36209062F100EEC73A /* REAEventNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC21209062F100EEC73A /* REAEventNode.m */; };
+		440FEC37209062F100EEC73A /* REASetNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC23209062F100EEC73A /* REASetNode.m */; };
+		440FEC38209062F100EEC73A /* REAOperatorNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC24209062F100EEC73A /* REAOperatorNode.m */; };
+		440FEC39209062F100EEC73A /* REABlockNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC25209062F100EEC73A /* REABlockNode.m */; };
+		440FEC3A209062F100EEC73A /* REAModule.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC2A209062F100EEC73A /* REAModule.m */; };
+		440FEC3B209062F100EEC73A /* REANodesManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC2B209062F100EEC73A /* REANodesManager.m */; };
+		44125DC022538E6D003C1762 /* REATransitionManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DBF22538E6D003C1762 /* REATransitionManager.m */; };
+		44125DC322538F68003C1762 /* REATransition.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DC222538F68003C1762 /* REATransition.m */; };
+		44125DC82253906B003C1762 /* REAAllTransitions.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DC72253906A003C1762 /* REAAllTransitions.m */; };
+		44125DCB22539177003C1762 /* REATransitionAnimation.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DCA22539177003C1762 /* REATransitionAnimation.m */; };
+		44125DCE2253A038003C1762 /* REATransitionValues.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DCD2253A038003C1762 /* REATransitionValues.m */; };
+		44125DD12253A3C0003C1762 /* RCTConvert+REATransition.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DD02253A3C0003C1762 /* RCTConvert+REATransition.m */; };
+		660A44292119B821006BFD5E /* REAConcatNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 660A44282119B820006BFD5E /* REAConcatNode.m */; };
+		66240C6920C68DEA00648F55 /* REAAlwaysNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 66240C6820C68DEA00648F55 /* REAAlwaysNode.m */; };
+		A12DA6B722EC228D00E8271A /* REAParamNode.m in Sources */ = {isa = PBXBuildFile; fileRef = A12DA6B622EC228D00E8271A /* REAParamNode.m */; };
+		A12DA6B822EC228D00E8271A /* REAParamNode.m in Sources */ = {isa = PBXBuildFile; fileRef = A12DA6B622EC228D00E8271A /* REAParamNode.m */; };
+		A12DA6BE22EC22E400E8271A /* REAFunctionNode.m in Sources */ = {isa = PBXBuildFile; fileRef = A12DA6BA22EC22E300E8271A /* REAFunctionNode.m */; };
+		A12DA6BF22EC22E400E8271A /* REAFunctionNode.m in Sources */ = {isa = PBXBuildFile; fileRef = A12DA6BA22EC22E300E8271A /* REAFunctionNode.m */; };
+		A12DA6C022EC22E400E8271A /* REACallFuncNode.m in Sources */ = {isa = PBXBuildFile; fileRef = A12DA6BC22EC22E300E8271A /* REACallFuncNode.m */; };
+		A12DA6C122EC22E400E8271A /* REACallFuncNode.m in Sources */ = {isa = PBXBuildFile; fileRef = A12DA6BC22EC22E300E8271A /* REACallFuncNode.m */; };
+		FDBB1777229BF0DE00D1E455 /* REAModule.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC2A209062F100EEC73A /* REAModule.m */; };
+		FDBB1778229BF0DE00D1E455 /* REANodesManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC2B209062F100EEC73A /* REANodesManager.m */; };
+		FDBB1779229BF0E700D1E455 /* REATransitionManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DBF22538E6D003C1762 /* REATransitionManager.m */; };
+		FDBB177A229BF0E700D1E455 /* REATransition.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DC222538F68003C1762 /* REATransition.m */; };
+		FDBB177B229BF0E700D1E455 /* REAAllTransitions.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DC72253906A003C1762 /* REAAllTransitions.m */; };
+		FDBB177C229BF0E700D1E455 /* REATransitionAnimation.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DCA22539177003C1762 /* REATransitionAnimation.m */; };
+		FDBB177D229BF0E700D1E455 /* REATransitionValues.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DCD2253A038003C1762 /* REATransitionValues.m */; };
+		FDBB177E229BF0E700D1E455 /* RCTConvert+REATransition.m in Sources */ = {isa = PBXBuildFile; fileRef = 44125DD02253A3C0003C1762 /* RCTConvert+REATransition.m */; };
+		FDE6D933229BF70F007F6716 /* REAConcatNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 660A44282119B820006BFD5E /* REAConcatNode.m */; };
+		FDE6D934229BF70F007F6716 /* REAAlwaysNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 66240C6820C68DEA00648F55 /* REAAlwaysNode.m */; };
+		FDE6D935229BF70F007F6716 /* REANode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1F209062F100EEC73A /* REANode.m */; };
+		FDE6D936229BF70F007F6716 /* REAValueNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC19209062F100EEC73A /* REAValueNode.m */; };
+		FDE6D937229BF70F007F6716 /* REAStyleNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC13209062F100EEC73A /* REAStyleNode.m */; };
+		FDE6D938229BF70F007F6716 /* REATransformNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC20209062F100EEC73A /* REATransformNode.m */; };
+		FDE6D939229BF70F007F6716 /* REAPropsNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC0D209062F100EEC73A /* REAPropsNode.m */; };
+		FDE6D93A229BF70F007F6716 /* REABlockNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC25209062F100EEC73A /* REABlockNode.m */; };
+		FDE6D93B229BF70F007F6716 /* REACondNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1A209062F100EEC73A /* REACondNode.m */; };
+		FDE6D93C229BF70F007F6716 /* REAOperatorNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC24209062F100EEC73A /* REAOperatorNode.m */; };
+		FDE6D93D229BF70F007F6716 /* REASetNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC23209062F100EEC73A /* REASetNode.m */; };
+		FDE6D93E229BF70F007F6716 /* READebugNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC14209062F100EEC73A /* READebugNode.m */; };
+		FDE6D93F229BF70F007F6716 /* REAClockNodes.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC18209062F100EEC73A /* REAClockNodes.m */; };
+		FDE6D940229BF70F007F6716 /* REAJSCallNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1B209062F100EEC73A /* REAJSCallNode.m */; };
+		FDE6D941229BF70F007F6716 /* REABezierNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC1C209062F100EEC73A /* REABezierNode.m */; };
+		FDE6D942229BF70F007F6716 /* REAEventNode.m in Sources */ = {isa = PBXBuildFile; fileRef = 440FEC21209062F100EEC73A /* REAEventNode.m */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXCopyFilesBuildPhase section */
+		58B511D91A9E6C8500147676 /* CopyFiles */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "include/$(PRODUCT_NAME)";
+			dstSubfolderSpec = 16;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FDBB176C229BF04900D1E455 /* CopyFiles */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "include/$(PRODUCT_NAME)";
+			dstSubfolderSpec = 16;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXCopyFilesBuildPhase section */
+
+/* Begin PBXFileReference section */
+		134814201AA4EA6300B7C361 /* libRNReanimated.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libRNReanimated.a; sourceTree = BUILT_PRODUCTS_DIR; };
+		440FEC01209062F100EEC73A /* REANodesManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REANodesManager.h; sourceTree = "<group>"; };
+		440FEC0A209062F100EEC73A /* REAModule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAModule.h; sourceTree = "<group>"; };
+		440FEC0D209062F100EEC73A /* REAPropsNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAPropsNode.m; sourceTree = "<group>"; };
+		440FEC0E209062F100EEC73A /* REABezierNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REABezierNode.h; sourceTree = "<group>"; };
+		440FEC0F209062F100EEC73A /* REAJSCallNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAJSCallNode.h; sourceTree = "<group>"; };
+		440FEC10209062F100EEC73A /* REAEventNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAEventNode.h; sourceTree = "<group>"; };
+		440FEC11209062F100EEC73A /* REANode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REANode.h; sourceTree = "<group>"; };
+		440FEC12209062F100EEC73A /* REATransformNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REATransformNode.h; sourceTree = "<group>"; };
+		440FEC13209062F100EEC73A /* REAStyleNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAStyleNode.m; sourceTree = "<group>"; };
+		440FEC14209062F100EEC73A /* READebugNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = READebugNode.m; sourceTree = "<group>"; };
+		440FEC15209062F100EEC73A /* REABlockNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REABlockNode.h; sourceTree = "<group>"; };
+		440FEC16209062F100EEC73A /* REAOperatorNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAOperatorNode.h; sourceTree = "<group>"; };
+		440FEC17209062F100EEC73A /* REASetNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REASetNode.h; sourceTree = "<group>"; };
+		440FEC18209062F100EEC73A /* REAClockNodes.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAClockNodes.m; sourceTree = "<group>"; };
+		440FEC19209062F100EEC73A /* REAValueNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAValueNode.m; sourceTree = "<group>"; };
+		440FEC1A209062F100EEC73A /* REACondNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REACondNode.m; sourceTree = "<group>"; };
+		440FEC1B209062F100EEC73A /* REAJSCallNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAJSCallNode.m; sourceTree = "<group>"; };
+		440FEC1C209062F100EEC73A /* REABezierNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REABezierNode.m; sourceTree = "<group>"; };
+		440FEC1D209062F100EEC73A /* REAPropsNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAPropsNode.h; sourceTree = "<group>"; };
+		440FEC1E209062F100EEC73A /* REAStyleNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAStyleNode.h; sourceTree = "<group>"; };
+		440FEC1F209062F100EEC73A /* REANode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REANode.m; sourceTree = "<group>"; };
+		440FEC20209062F100EEC73A /* REATransformNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REATransformNode.m; sourceTree = "<group>"; };
+		440FEC21209062F100EEC73A /* REAEventNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAEventNode.m; sourceTree = "<group>"; };
+		440FEC22209062F100EEC73A /* REAClockNodes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAClockNodes.h; sourceTree = "<group>"; };
+		440FEC23209062F100EEC73A /* REASetNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REASetNode.m; sourceTree = "<group>"; };
+		440FEC24209062F100EEC73A /* REAOperatorNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAOperatorNode.m; sourceTree = "<group>"; };
+		440FEC25209062F100EEC73A /* REABlockNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REABlockNode.m; sourceTree = "<group>"; };
+		440FEC26209062F100EEC73A /* READebugNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = READebugNode.h; sourceTree = "<group>"; };
+		440FEC27209062F100EEC73A /* REACondNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REACondNode.h; sourceTree = "<group>"; };
+		440FEC28209062F100EEC73A /* REAValueNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAValueNode.h; sourceTree = "<group>"; };
+		440FEC2A209062F100EEC73A /* REAModule.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAModule.m; sourceTree = "<group>"; };
+		440FEC2B209062F100EEC73A /* REANodesManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REANodesManager.m; sourceTree = "<group>"; };
+		44125DBE22538E6D003C1762 /* REATransitionManager.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = REATransitionManager.h; sourceTree = "<group>"; };
+		44125DBF22538E6D003C1762 /* REATransitionManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = REATransitionManager.m; sourceTree = "<group>"; };
+		44125DC122538F68003C1762 /* REATransition.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = REATransition.h; sourceTree = "<group>"; };
+		44125DC222538F68003C1762 /* REATransition.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = REATransition.m; sourceTree = "<group>"; };
+		44125DC62253906A003C1762 /* REAAllTransitions.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = REAAllTransitions.h; sourceTree = "<group>"; };
+		44125DC72253906A003C1762 /* REAAllTransitions.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = REAAllTransitions.m; sourceTree = "<group>"; };
+		44125DC922539177003C1762 /* REATransitionAnimation.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = REATransitionAnimation.h; sourceTree = "<group>"; };
+		44125DCA22539177003C1762 /* REATransitionAnimation.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = REATransitionAnimation.m; sourceTree = "<group>"; };
+		44125DCC2253A038003C1762 /* REATransitionValues.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = REATransitionValues.h; sourceTree = "<group>"; };
+		44125DCD2253A038003C1762 /* REATransitionValues.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = REATransitionValues.m; sourceTree = "<group>"; };
+		44125DCF2253A3C0003C1762 /* RCTConvert+REATransition.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "RCTConvert+REATransition.h"; sourceTree = "<group>"; };
+		44125DD02253A3C0003C1762 /* RCTConvert+REATransition.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "RCTConvert+REATransition.m"; sourceTree = "<group>"; };
+		4DA383A8226FA6A400582919 /* REAUtils.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = REAUtils.h; sourceTree = "<group>"; };
+		660A44282119B820006BFD5E /* REAConcatNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAConcatNode.m; sourceTree = "<group>"; };
+		660A442A2119B83E006BFD5E /* REAConcatNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAConcatNode.h; sourceTree = "<group>"; };
+		66240C6720C68DEA00648F55 /* REAAlwaysNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAAlwaysNode.h; sourceTree = "<group>"; };
+		66240C6820C68DEA00648F55 /* REAAlwaysNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAAlwaysNode.m; sourceTree = "<group>"; };
+		A12DA6B622EC228D00E8271A /* REAParamNode.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = REAParamNode.m; sourceTree = "<group>"; };
+		A12DA6B922EC22A900E8271A /* REAParamNode.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = REAParamNode.h; sourceTree = "<group>"; };
+		A12DA6BA22EC22E300E8271A /* REAFunctionNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REAFunctionNode.m; sourceTree = "<group>"; };
+		A12DA6BB22EC22E300E8271A /* REACallFuncNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REACallFuncNode.h; sourceTree = "<group>"; };
+		A12DA6BC22EC22E300E8271A /* REACallFuncNode.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = REACallFuncNode.m; sourceTree = "<group>"; };
+		A12DA6BD22EC22E300E8271A /* REAFunctionNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = REAFunctionNode.h; sourceTree = "<group>"; };
+		FDBB176E229BF04900D1E455 /* libRNReanimated-tvOS.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = "libRNReanimated-tvOS.a"; sourceTree = BUILT_PRODUCTS_DIR; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		58B511D81A9E6C8500147676 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FDBB176B229BF04900D1E455 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		134814211AA4EA7D00B7C361 /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				134814201AA4EA6300B7C361 /* libRNReanimated.a */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		440FEC0C209062F100EEC73A /* Nodes */ = {
+			isa = PBXGroup;
+			children = (
+				A12DA6B922EC22A900E8271A /* REAParamNode.h */,
+				A12DA6B622EC228D00E8271A /* REAParamNode.m */,
+				A12DA6BB22EC22E300E8271A /* REACallFuncNode.h */,
+				A12DA6BC22EC22E300E8271A /* REACallFuncNode.m */,
+				A12DA6BD22EC22E300E8271A /* REAFunctionNode.h */,
+				A12DA6BA22EC22E300E8271A /* REAFunctionNode.m */,
+				660A442A2119B83E006BFD5E /* REAConcatNode.h */,
+				660A44282119B820006BFD5E /* REAConcatNode.m */,
+				66240C6720C68DEA00648F55 /* REAAlwaysNode.h */,
+				66240C6820C68DEA00648F55 /* REAAlwaysNode.m */,
+				440FEC11209062F100EEC73A /* REANode.h */,
+				440FEC1F209062F100EEC73A /* REANode.m */,
+				440FEC28209062F100EEC73A /* REAValueNode.h */,
+				440FEC19209062F100EEC73A /* REAValueNode.m */,
+				440FEC1E209062F100EEC73A /* REAStyleNode.h */,
+				440FEC13209062F100EEC73A /* REAStyleNode.m */,
+				440FEC12209062F100EEC73A /* REATransformNode.h */,
+				440FEC20209062F100EEC73A /* REATransformNode.m */,
+				440FEC1D209062F100EEC73A /* REAPropsNode.h */,
+				440FEC0D209062F100EEC73A /* REAPropsNode.m */,
+				440FEC15209062F100EEC73A /* REABlockNode.h */,
+				440FEC25209062F100EEC73A /* REABlockNode.m */,
+				440FEC27209062F100EEC73A /* REACondNode.h */,
+				440FEC1A209062F100EEC73A /* REACondNode.m */,
+				440FEC16209062F100EEC73A /* REAOperatorNode.h */,
+				440FEC24209062F100EEC73A /* REAOperatorNode.m */,
+				440FEC17209062F100EEC73A /* REASetNode.h */,
+				440FEC23209062F100EEC73A /* REASetNode.m */,
+				440FEC26209062F100EEC73A /* READebugNode.h */,
+				440FEC14209062F100EEC73A /* READebugNode.m */,
+				440FEC22209062F100EEC73A /* REAClockNodes.h */,
+				440FEC18209062F100EEC73A /* REAClockNodes.m */,
+				440FEC0F209062F100EEC73A /* REAJSCallNode.h */,
+				440FEC1B209062F100EEC73A /* REAJSCallNode.m */,
+				440FEC0E209062F100EEC73A /* REABezierNode.h */,
+				440FEC1C209062F100EEC73A /* REABezierNode.m */,
+				440FEC10209062F100EEC73A /* REAEventNode.h */,
+				440FEC21209062F100EEC73A /* REAEventNode.m */,
+			);
+			path = Nodes;
+			sourceTree = "<group>";
+		};
+		44125C76224FBE0B003C1762 /* Transitioning */ = {
+			isa = PBXGroup;
+			children = (
+				44125DBE22538E6D003C1762 /* REATransitionManager.h */,
+				44125DBF22538E6D003C1762 /* REATransitionManager.m */,
+				44125DC122538F68003C1762 /* REATransition.h */,
+				44125DC222538F68003C1762 /* REATransition.m */,
+				44125DC62253906A003C1762 /* REAAllTransitions.h */,
+				44125DC72253906A003C1762 /* REAAllTransitions.m */,
+				44125DC922539177003C1762 /* REATransitionAnimation.h */,
+				44125DCA22539177003C1762 /* REATransitionAnimation.m */,
+				44125DCC2253A038003C1762 /* REATransitionValues.h */,
+				44125DCD2253A038003C1762 /* REATransitionValues.m */,
+				44125DCF2253A3C0003C1762 /* RCTConvert+REATransition.h */,
+				44125DD02253A3C0003C1762 /* RCTConvert+REATransition.m */,
+			);
+			path = Transitioning;
+			sourceTree = "<group>";
+		};
+		58B511D21A9E6C8500147676 = {
+			isa = PBXGroup;
+			children = (
+				4DA383A8226FA6A400582919 /* REAUtils.h */,
+				44125C76224FBE0B003C1762 /* Transitioning */,
+				440FEC0C209062F100EEC73A /* Nodes */,
+				440FEC0A209062F100EEC73A /* REAModule.h */,
+				440FEC2A209062F100EEC73A /* REAModule.m */,
+				440FEC01209062F100EEC73A /* REANodesManager.h */,
+				440FEC2B209062F100EEC73A /* REANodesManager.m */,
+				134814211AA4EA7D00B7C361 /* Products */,
+				FDBB176E229BF04900D1E455 /* libRNReanimated-tvOS.a */,
+			);
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXNativeTarget section */
+		58B511DA1A9E6C8500147676 /* RNReanimated */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 58B511EF1A9E6C8500147676 /* Build configuration list for PBXNativeTarget "RNReanimated" */;
+			buildPhases = (
+				58B511D71A9E6C8500147676 /* Sources */,
+				58B511D81A9E6C8500147676 /* Frameworks */,
+				58B511D91A9E6C8500147676 /* CopyFiles */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = RNReanimated;
+			productName = RCTDataManager;
+			productReference = 134814201AA4EA6300B7C361 /* libRNReanimated.a */;
+			productType = "com.apple.product-type.library.static";
+		};
+		FDBB176D229BF04900D1E455 /* RNReanimated-tvOS */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = FDBB1774229BF04900D1E455 /* Build configuration list for PBXNativeTarget "RNReanimated-tvOS" */;
+			buildPhases = (
+				FDBB176A229BF04900D1E455 /* Sources */,
+				FDBB176B229BF04900D1E455 /* Frameworks */,
+				FDBB176C229BF04900D1E455 /* CopyFiles */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "RNReanimated-tvOS";
+			productName = "RNReanimated-tvOS";
+			productReference = FDBB176E229BF04900D1E455 /* libRNReanimated-tvOS.a */;
+			productType = "com.apple.product-type.library.static";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		58B511D31A9E6C8500147676 /* Project object */ = {
+			isa = PBXProject;
+			attributes = {
+				LastUpgradeCheck = 0920;
+				ORGANIZATIONNAME = Facebook;
+				TargetAttributes = {
+					58B511DA1A9E6C8500147676 = {
+						CreatedOnToolsVersion = 6.1.1;
+					};
+					FDBB176D229BF04900D1E455 = {
+						CreatedOnToolsVersion = 10.2.1;
+						DevelopmentTeam = NZDV3AFAEG;
+						ProvisioningStyle = Automatic;
+					};
+				};
+			};
+			buildConfigurationList = 58B511D61A9E6C8500147676 /* Build configuration list for PBXProject "RNReanimated" */;
+			compatibilityVersion = "Xcode 3.2";
+			developmentRegion = English;
+			hasScannedForEncodings = 0;
+			knownRegions = (
+				English,
+				en,
+			);
+			mainGroup = 58B511D21A9E6C8500147676;
+			productRefGroup = 58B511D21A9E6C8500147676;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				58B511DA1A9E6C8500147676 /* RNReanimated */,
+				FDBB176D229BF04900D1E455 /* RNReanimated-tvOS */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXSourcesBuildPhase section */
+		58B511D71A9E6C8500147676 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				440FEC2E209062F100EEC73A /* READebugNode.m in Sources */,
+				440FEC37209062F100EEC73A /* REASetNode.m in Sources */,
+				440FEC3A209062F100EEC73A /* REAModule.m in Sources */,
+				44125DCE2253A038003C1762 /* REATransitionValues.m in Sources */,
+				44125DC82253906B003C1762 /* REAAllTransitions.m in Sources */,
+				A12DA6B722EC228D00E8271A /* REAParamNode.m in Sources */,
+				44125DC022538E6D003C1762 /* REATransitionManager.m in Sources */,
+				440FEC39209062F100EEC73A /* REABlockNode.m in Sources */,
+				A12DA6C022EC22E400E8271A /* REACallFuncNode.m in Sources */,
+				440FEC33209062F100EEC73A /* REABezierNode.m in Sources */,
+				44125DC322538F68003C1762 /* REATransition.m in Sources */,
+				440FEC2D209062F100EEC73A /* REAStyleNode.m in Sources */,
+				440FEC31209062F100EEC73A /* REACondNode.m in Sources */,
+				44125DD12253A3C0003C1762 /* RCTConvert+REATransition.m in Sources */,
+				440FEC2C209062F100EEC73A /* REAPropsNode.m in Sources */,
+				A12DA6BE22EC22E400E8271A /* REAFunctionNode.m in Sources */,
+				440FEC3B209062F100EEC73A /* REANodesManager.m in Sources */,
+				440FEC36209062F100EEC73A /* REAEventNode.m in Sources */,
+				44125DCB22539177003C1762 /* REATransitionAnimation.m in Sources */,
+				66240C6920C68DEA00648F55 /* REAAlwaysNode.m in Sources */,
+				440FEC2F209062F100EEC73A /* REAClockNodes.m in Sources */,
+				660A44292119B821006BFD5E /* REAConcatNode.m in Sources */,
+				440FEC38209062F100EEC73A /* REAOperatorNode.m in Sources */,
+				440FEC34209062F100EEC73A /* REANode.m in Sources */,
+				440FEC30209062F100EEC73A /* REAValueNode.m in Sources */,
+				440FEC32209062F100EEC73A /* REAJSCallNode.m in Sources */,
+				440FEC35209062F100EEC73A /* REATransformNode.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FDBB176A229BF04900D1E455 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				FDE6D93C229BF70F007F6716 /* REAOperatorNode.m in Sources */,
+				FDE6D93F229BF70F007F6716 /* REAClockNodes.m in Sources */,
+				FDE6D936229BF70F007F6716 /* REAValueNode.m in Sources */,
+				FDE6D941229BF70F007F6716 /* REABezierNode.m in Sources */,
+				FDBB177B229BF0E700D1E455 /* REAAllTransitions.m in Sources */,
+				A12DA6B822EC228D00E8271A /* REAParamNode.m in Sources */,
+				FDE6D93D229BF70F007F6716 /* REASetNode.m in Sources */,
+				FDE6D93A229BF70F007F6716 /* REABlockNode.m in Sources */,
+				A12DA6C122EC22E400E8271A /* REACallFuncNode.m in Sources */,
+				FDE6D939229BF70F007F6716 /* REAPropsNode.m in Sources */,
+				FDBB1778229BF0DE00D1E455 /* REANodesManager.m in Sources */,
+				FDE6D937229BF70F007F6716 /* REAStyleNode.m in Sources */,
+				FDE6D940229BF70F007F6716 /* REAJSCallNode.m in Sources */,
+				FDE6D935229BF70F007F6716 /* REANode.m in Sources */,
+				FDE6D93B229BF70F007F6716 /* REACondNode.m in Sources */,
+				A12DA6BF22EC22E400E8271A /* REAFunctionNode.m in Sources */,
+				FDBB177C229BF0E700D1E455 /* REATransitionAnimation.m in Sources */,
+				FDE6D934229BF70F007F6716 /* REAAlwaysNode.m in Sources */,
+				FDE6D933229BF70F007F6716 /* REAConcatNode.m in Sources */,
+				FDBB177D229BF0E700D1E455 /* REATransitionValues.m in Sources */,
+				FDE6D942229BF70F007F6716 /* REAEventNode.m in Sources */,
+				FDE6D93E229BF70F007F6716 /* READebugNode.m in Sources */,
+				FDE6D938229BF70F007F6716 /* REATransformNode.m in Sources */,
+				FDBB177A229BF0E700D1E455 /* REATransition.m in Sources */,
+				FDBB177E229BF0E700D1E455 /* RCTConvert+REATransition.m in Sources */,
+				FDBB1777229BF0DE00D1E455 /* REAModule.m in Sources */,
+				FDBB1779229BF0E700D1E455 /* REATransitionManager.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin XCBuildConfiguration section */
+		58B511ED1A9E6C8500147676 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_MODULES = YES;
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_COMMA = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INFINITE_RECURSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
+				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
+				CLANG_WARN_STRICT_PROTOTYPES = YES;
+				CLANG_WARN_SUSPICIOUS_MOVE = YES;
+				CLANG_WARN_UNREACHABLE_CODE = YES;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COPY_PHASE_STRIP = NO;
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				ENABLE_TESTABILITY = YES;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
+				MTL_ENABLE_DEBUG_INFO = YES;
+				ONLY_ACTIVE_ARCH = YES;
+				SDKROOT = iphoneos;
+			};
+			name = Debug;
+		};
+		58B511EE1A9E6C8500147676 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_MODULES = YES;
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_COMMA = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INFINITE_RECURSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
+				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
+				CLANG_WARN_STRICT_PROTOTYPES = YES;
+				CLANG_WARN_SUSPICIOUS_MOVE = YES;
+				CLANG_WARN_UNREACHABLE_CODE = YES;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				COPY_PHASE_STRIP = YES;
+				ENABLE_NS_ASSERTIONS = NO;
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
+				MTL_ENABLE_DEBUG_INFO = NO;
+				SDKROOT = iphoneos;
+				VALIDATE_PRODUCT = YES;
+			};
+			name = Release;
+		};
+		58B511F01A9E6C8500147676 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include,
+					"$(SRCROOT)/../../../React/**",
+					"$(SRCROOT)/../../react-native/React/**",
+				);
+				LIBRARY_SEARCH_PATHS = "$(inherited)";
+				OTHER_LDFLAGS = "-ObjC";
+				PRODUCT_NAME = RNReanimated;
+				SKIP_INSTALL = YES;
+			};
+			name = Debug;
+		};
+		58B511F11A9E6C8500147676 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include,
+					"$(SRCROOT)/../../../React/**",
+					"$(SRCROOT)/../../react-native/React/**",
+				);
+				LIBRARY_SEARCH_PATHS = "$(inherited)";
+				OTHER_LDFLAGS = "-ObjC";
+				PRODUCT_NAME = RNReanimated;
+				SKIP_INSTALL = YES;
+			};
+			name = Release;
+		};
+		FDBB1775229BF04900D1E455 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_ANALYZER_NONNULL = YES;
+				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
+				CLANG_ENABLE_OBJC_WEAK = YES;
+				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
+				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
+				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
+				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
+				CODE_SIGN_STYLE = Automatic;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEVELOPMENT_TEAM = NZDV3AFAEG;
+				GCC_C_LANGUAGE_STANDARD = gnu11;
+				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
+				MTL_FAST_MATH = YES;
+				OTHER_LDFLAGS = "-ObjC";
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = appletvos;
+				SKIP_INSTALL = YES;
+				TARGETED_DEVICE_FAMILY = 3;
+				TVOS_DEPLOYMENT_TARGET = 12.2;
+			};
+			name = Debug;
+		};
+		FDBB1776229BF04900D1E455 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_ANALYZER_NONNULL = YES;
+				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
+				CLANG_ENABLE_OBJC_WEAK = YES;
+				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
+				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
+				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
+				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
+				CODE_SIGN_STYLE = Automatic;
+				COPY_PHASE_STRIP = NO;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				DEVELOPMENT_TEAM = NZDV3AFAEG;
+				GCC_C_LANGUAGE_STANDARD = gnu11;
+				MTL_FAST_MATH = YES;
+				OTHER_LDFLAGS = "-ObjC";
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = appletvos;
+				SKIP_INSTALL = YES;
+				TARGETED_DEVICE_FAMILY = 3;
+				TVOS_DEPLOYMENT_TARGET = 12.2;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		58B511D61A9E6C8500147676 /* Build configuration list for PBXProject "RNReanimated" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				58B511ED1A9E6C8500147676 /* Debug */,
+				58B511EE1A9E6C8500147676 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		58B511EF1A9E6C8500147676 /* Build configuration list for PBXNativeTarget "RNReanimated" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				58B511F01A9E6C8500147676 /* Debug */,
+				58B511F11A9E6C8500147676 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		FDBB1774229BF04900D1E455 /* Build configuration list for PBXNativeTarget "RNReanimated-tvOS" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				FDBB1775229BF04900D1E455 /* Debug */,
+				FDBB1776229BF04900D1E455 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 58B511D31A9E6C8500147676 /* Project object */;
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/RNReanimated.xcodeproj/xcshareddata/xcschemes/RNReanimated-tvOS.xcscheme b/node_modules/react-native-reanimated/react-native-reanimated/ios/RNReanimated.xcodeproj/xcshareddata/xcschemes/RNReanimated-tvOS.xcscheme
new file mode 100644
index 0000000..a29d306
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/RNReanimated.xcodeproj/xcshareddata/xcschemes/RNReanimated-tvOS.xcscheme
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "1020"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "FDBB176D229BF04900D1E455"
+               BuildableName = "libRNReanimated-tvOS.a"
+               BlueprintName = "RNReanimated-tvOS"
+               ReferencedContainer = "container:RNReanimated.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "FDBB176D229BF04900D1E455"
+            BuildableName = "libRNReanimated-tvOS.a"
+            BlueprintName = "RNReanimated-tvOS"
+            ReferencedContainer = "container:RNReanimated.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "FDBB176D229BF04900D1E455"
+            BuildableName = "libRNReanimated-tvOS.a"
+            BlueprintName = "RNReanimated-tvOS"
+            ReferencedContainer = "container:RNReanimated.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/RCTConvert+REATransition.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/RCTConvert+REATransition.h
new file mode 100644
index 0000000..17ebf0d
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/RCTConvert+REATransition.h
@@ -0,0 +1,12 @@
+#import <React/RCTConvert.h>
+
+#import "REATransition.h"
+
+@interface RCTConvert (REATransition)
+
++ (REATransitionType)REATransitionType:(id)json;
++ (REATransitionAnimationType)REATransitionAnimationType:(id)json;
++ (REATransitionInterpolationType)REATransitionInterpolationType:(id)json;
++ (REATransitionPropagationType)REATransitionPropagationType:(id)json;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/RCTConvert+REATransition.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/RCTConvert+REATransition.m
new file mode 100644
index 0000000..49dd5c1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/RCTConvert+REATransition.m
@@ -0,0 +1,37 @@
+#import "RCTConvert+REATransition.h"
+
+@implementation RCTConvert (REATransition)
+
+RCT_ENUM_CONVERTER(REATransitionType, (@{
+                                         @"none": @(REATransitionTypeNone),
+                                         @"group": @(REATransitionTypeGroup),
+                                         @"in": @(REATransitionTypeIn),
+                                         @"out": @(REATransitionTypeOut),
+                                         @"change": @(REATransitionTypeChange),
+                                         }), REATransitionTypeNone, integerValue)
+
+RCT_ENUM_CONVERTER(REATransitionAnimationType, (@{
+                                                  @"none": @(REATransitionAnimationTypeNone),
+                                                  @"fade": @(REATransitionAnimationTypeFade),
+                                                  @"scale": @(REATransitionAnimationTypeScale),
+                                                  @"slide-top": @(REATransitionAnimationTypeSlideTop),
+                                                  @"slide-bottom": @(REATransitionAnimationTypeSlideBottom),
+                                                  @"slide-right": @(REATransitionAnimationTypeSlideRight),
+                                                  @"slide-left": @(REATransitionAnimationTypeSlideLeft)
+                                                  }), REATransitionAnimationTypeNone, integerValue)
+
+RCT_ENUM_CONVERTER(REATransitionInterpolationType, (@{
+                                                      @"linear": @(REATransitionInterpolationLinear),
+                                                      @"easeIn": @(REATransitionInterpolationEaseIn),
+                                                      @"easeOut": @(REATransitionInterpolationEaseOut),
+                                                      @"easeInOut": @(REATransitionInterpolationEaseInOut),
+                                                      }), REATransitionInterpolationLinear, integerValue)
+
+RCT_ENUM_CONVERTER(REATransitionPropagationType, (@{
+                                                    @"none": @(REATransitionPropagationNone),
+                                                    @"top": @(REATransitionPropagationTop),
+                                                    @"bottom": @(REATransitionPropagationBottom),
+                                                    @"left": @(REATransitionPropagationLeft),
+                                                    @"right": @(REATransitionPropagationRight)
+                                                    }), REATransitionPropagationNone, integerValue)
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REAAllTransitions.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REAAllTransitions.h
new file mode 100644
index 0000000..8ab0480
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REAAllTransitions.h
@@ -0,0 +1,26 @@
+#import "REATransition.h"
+
+@interface REATransitionGroup : REATransition
+@property (nonatomic) BOOL sequence;
+@property (nonatomic) NSArray *transitions;
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAVisibilityTransition : REATransition
+@property (nonatomic) REATransitionAnimationType animationType;
+- (REATransitionAnimation *)appearView:(UIView*)view inParent:(UIView*)parent;
+- (REATransitionAnimation *)disappearView:(UIView*)view fromParent:(UIView*)parent;
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAInTransition : REAVisibilityTransition
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAOutTransition : REAVisibilityTransition
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAChangeTransition : REATransition
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REAAllTransitions.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REAAllTransitions.m
new file mode 100644
index 0000000..227253f
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REAAllTransitions.m
@@ -0,0 +1,308 @@
+#import <React/RCTViewManager.h>
+
+#import "REAAllTransitions.h"
+#import "RCTConvert+REATransition.h"
+
+@interface REASnapshotRemover : NSObject <CAAnimationDelegate>
+@end
+
+@implementation REASnapshotRemover {
+  UIView *_view;
+}
+
+- (instancetype)initWithView:(UIView *)view;
+{
+  self = [super init];
+  if (self) {
+    _view = view;
+  }
+  return self;
+}
+
+- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
+{
+  [_view removeFromSuperview];
+}
+
+@end
+
+@implementation REATransitionGroup
+
+- (instancetype)initWithConfig:(NSDictionary *)config
+{
+  if (self = [super initWithConfig:config]) {
+    _sequence = [RCTConvert BOOL:config[@"sequence"]];
+    NSArray *transitions = [RCTConvert NSArray:config[@"transitions"]];
+    NSMutableArray<REATransition*> *inflated = [NSMutableArray new];
+    for (NSDictionary *transitionConfig in transitions) {
+      [inflated addObject:[REATransition inflate:transitionConfig]];
+      inflated.lastObject.parent = self;
+    }
+    _transitions = inflated;
+  }
+  return self;
+}
+
+- (instancetype)init
+{
+  if (self = [super init]) {
+    _transitions = [NSMutableArray new];
+  }
+  return self;
+}
+
+- (NSArray<REATransitionAnimation *> *)animationsForTransitioning:(NSMutableDictionary<NSNumber *,REATransitionValues *> *)startValues
+                                                           endValues:(NSMutableDictionary<NSNumber *,REATransitionValues *> *)endValues
+                                                             forRoot:(UIView *)root
+{
+  CFTimeInterval delay = self.delay;
+  NSMutableArray *animations = [NSMutableArray new];
+  for (REATransition *transition in _transitions) {
+    NSArray *subanims = [transition animationsForTransitioning:startValues endValues:endValues forRoot:root];
+    CFTimeInterval finishTime = CACurrentMediaTime();
+    for (REATransitionAnimation *anim in subanims) {
+      [anim delayBy:delay];
+      finishTime = MAX(finishTime, anim.finishTime);
+    }
+    [animations addObjectsFromArray:subanims];
+    if (_sequence) {
+      delay = finishTime - CACurrentMediaTime();
+    }
+  }
+  return animations;
+}
+
+@end
+
+
+@implementation REAVisibilityTransition
+
+- (instancetype)initWithConfig:(NSDictionary *)config
+{
+  if (self = [super initWithConfig:config]) {
+    _animationType = [RCTConvert REATransitionAnimationType:config[@"animation"]];
+  }
+  return self;
+}
+
+- (REATransitionAnimation *)appearView:(UIView *)view
+                                 inParent:(UIView *)parent
+                                  forRoot:(UIView *)root
+{
+  return nil;
+}
+
+- (REATransitionAnimation *)disappearView:(UIView *)view
+                                  fromParent:(UIView *)parent
+                                     forRoot:(UIView *)root
+{
+  return nil;
+}
+
+- (REATransitionAnimation *)animationForTransitioning:(REATransitionValues *)startValues
+                                               endValues:(REATransitionValues *)endValues
+                                                 forRoot:(UIView *)root
+{
+  BOOL isViewAppearing = (startValues == nil);
+  if (isViewAppearing && !IS_LAYOUT_ONLY(endValues.view)) {
+    NSNumber *parentKey = endValues.reactParent.reactTag;
+    REATransitionValues *parentStartValues = [self findStartValuesForKey:parentKey];
+    REATransitionValues *parentEndValues = [self findEndValuesForKey:parentKey];
+    BOOL isParentAppearing = (parentStartValues == nil && parentEndValues != nil);
+    if (!isParentAppearing) {
+      return [self appearView:endValues.view inParent:endValues.parent forRoot:root];
+    }
+  }
+
+  if (endValues == nil && !IS_LAYOUT_ONLY(startValues.view) && startValues.reactParent.window != nil) {
+    startValues.view.center = startValues.centerInReactParent;
+    return [self disappearView:startValues.view fromParent:startValues.reactParent forRoot:root];
+  }
+  return nil;
+}
+
+@end
+
+
+@implementation REAInTransition
+- (instancetype)initWithConfig:(NSDictionary *)config
+{
+  if (self = [super initWithConfig:config]) {
+  }
+  return self;
+}
+
+- (REATransitionAnimation *)appearView:(UIView *)view
+                                 inParent:(UIView *)parent
+                                  forRoot:(UIView *)root
+{
+  CABasicAnimation *animation;
+  switch (self.animationType) {
+    case REATransitionAnimationTypeNone:
+      return nil;
+    case REATransitionAnimationTypeFade: {
+      CGFloat finalOpacity = view.layer.opacity;
+      animation = [CABasicAnimation animationWithKeyPath:@"opacity"];
+      animation.fromValue = @(0.0f);
+      animation.toValue = @(finalOpacity);
+      break;
+    }
+    case REATransitionAnimationTypeScale: {
+      CATransform3D finalTransform = view.layer.transform;
+      animation = [CABasicAnimation animationWithKeyPath:@"transform"];
+      animation.fromValue = [NSValue valueWithCATransform3D:CATransform3DMakeScale(0.0, 0.0, 0)];
+      animation.toValue = [NSValue valueWithCATransform3D:finalTransform];
+      break;
+    }
+    case REATransitionAnimationTypeSlideTop:
+    case REATransitionAnimationTypeSlideBottom:
+    case REATransitionAnimationTypeSlideLeft:
+    case REATransitionAnimationTypeSlideRight: {
+      CGPoint finalPosition = view.layer.position;
+      CGPoint startPosition = finalPosition;
+      switch (self.animationType) {
+        case REATransitionAnimationTypeSlideTop:
+          startPosition.y -= root.frame.size.height;
+          break;
+        case REATransitionAnimationTypeSlideBottom:
+          startPosition.y += root.frame.size.height;
+          break;
+        case REATransitionAnimationTypeSlideLeft:
+          startPosition.x -= root.frame.size.width;
+          break;
+        case REATransitionAnimationTypeSlideRight:
+          startPosition.x += root.frame.size.width;
+          break;
+      }
+      animation = [CABasicAnimation animationWithKeyPath:@"position"];
+      animation.fromValue = @(startPosition);
+      animation.toValue = @(finalPosition);
+      break;
+    }
+  }
+  animation.fillMode = kCAFillModeBackwards;
+
+  return [REATransitionAnimation transitionWithAnimation:animation layer:view.layer andKeyPath:animation.keyPath];
+}
+@end
+
+
+@implementation REAOutTransition
+- (instancetype)initWithConfig:(NSDictionary *)config
+{
+  if (self = [super initWithConfig:config]) {
+  }
+  return self;
+}
+
+- (REATransitionAnimation *)disappearView:(UIView *)view
+                               fromParent:(UIView *)parent
+                                  forRoot:(UIView *)root
+{
+  if (self.animationType == REATransitionAnimationTypeNone) {
+    return nil;
+  }
+  // Add view back to parent temporarily in order to take snapshot
+  [parent addSubview:view];
+  UIView *snapshotView = [view snapshotViewAfterScreenUpdates:NO];
+  [view removeFromSuperview];
+  snapshotView.frame = view.frame;
+  [parent addSubview:snapshotView];
+  CALayer *snapshot = snapshotView.layer;
+
+  CABasicAnimation *animation;
+  switch (self.animationType) {
+    case REATransitionAnimationTypeFade: {
+      CGFloat fromValue = snapshot.opacity;
+      snapshot.opacity = 0.0f;
+      animation = [CABasicAnimation animationWithKeyPath:@"opacity"];
+      animation.fromValue = @(fromValue);
+      animation.toValue = @(0.0f);
+      break;
+    }
+    case REATransitionAnimationTypeScale: {
+      CATransform3D fromValue = snapshot.transform;
+      snapshot.transform = CATransform3DMakeScale(0.001, 0.001, 0.001);
+      animation = [CABasicAnimation animationWithKeyPath:@"transform"];
+      animation.fromValue = [NSValue valueWithCATransform3D:fromValue];
+      animation.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeScale(0.001, 0.001, 0.001)];
+      break;
+    }
+    case REATransitionAnimationTypeSlideTop:
+    case REATransitionAnimationTypeSlideBottom:
+    case REATransitionAnimationTypeSlideLeft:
+    case REATransitionAnimationTypeSlideRight: {
+      CGPoint startPosition = snapshot.position;
+      CGPoint finalPosition = startPosition;
+      switch (self.animationType) {
+        case REATransitionAnimationTypeSlideTop:
+          finalPosition.y -= root.frame.size.height;
+          break;
+        case REATransitionAnimationTypeSlideBottom:
+          finalPosition.y += root.frame.size.height;
+          break;
+        case REATransitionAnimationTypeSlideLeft:
+          finalPosition.x -= root.frame.size.width;
+          break;
+        case REATransitionAnimationTypeSlideRight:
+          finalPosition.x += root.frame.size.width;
+          break;
+      }
+      snapshot.position = finalPosition;
+      animation = [CABasicAnimation animationWithKeyPath:@"position"];
+      animation.fromValue = @(startPosition);
+      animation.toValue = @(finalPosition);
+      break;
+    }
+  }
+  animation.fillMode = kCAFillModeBackwards;
+  animation.delegate = [[REASnapshotRemover alloc] initWithView:snapshotView];
+
+  return [REATransitionAnimation transitionWithAnimation:animation layer:snapshot andKeyPath:animation.keyPath];
+}
+@end
+
+
+@implementation REAChangeTransition
+
+- (REATransitionAnimation *)animationForTransitioning:(REATransitionValues *)startValues
+                                               endValues:(REATransitionValues *)endValues
+                                                 forRoot:(UIView *)root
+{
+  if (startValues == nil || endValues == nil || endValues.view.window == nil) {
+    return nil;
+  }
+  BOOL animatePosition = !CGPointEqualToPoint(startValues.center, endValues.center);
+  BOOL animateBounds = !CGRectEqualToRect(startValues.bounds, endValues.bounds);
+
+  if (!animatePosition && !animateBounds) {
+    return nil;
+  }
+
+  CALayer *layer = endValues.view.layer;
+
+  CAAnimationGroup *group = [CAAnimationGroup animation];
+  group.fillMode = kCAFillModeBackwards;
+
+  NSMutableArray *animations = [NSMutableArray new];
+
+  if (animatePosition) {
+    CGPoint fromValue = layer.presentationLayer.position;
+    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"position"];
+    animation.fromValue = [NSValue valueWithCGPoint:fromValue];
+    animation.toValue = [NSValue valueWithCGPoint:endValues.center];
+    [animations addObject:animation];
+  }
+
+  if (animateBounds) {
+    CGRect fromValue = layer.presentationLayer.bounds;
+    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"bounds"];
+    animation.fromValue = [NSValue valueWithCGRect:fromValue];
+    animation.toValue = [NSValue valueWithCGRect:endValues.bounds];
+    [animations addObject:animation];
+  }
+
+  group.animations = animations;
+  return [REATransitionAnimation transitionWithAnimation:group layer:layer andKeyPath:nil];
+}
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransition.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransition.h
new file mode 100644
index 0000000..6d4d1f0
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransition.h
@@ -0,0 +1,64 @@
+#import <UIKit/UIKit.h>
+#import <QuartzCore/QuartzCore.h>
+#import <React/RCTView.h>
+
+#import "REATransitionAnimation.h"
+#import "REATransitionValues.h"
+
+// TODO: fix below implementation
+#define IS_LAYOUT_ONLY(view) ([view isKindOfClass:[RCTView class]] && view.backgroundColor == nil)
+
+typedef NS_ENUM(NSInteger, REATransitionType) {
+  REATransitionTypeNone = 0,
+  REATransitionTypeGroup,
+  REATransitionTypeIn,
+  REATransitionTypeOut,
+  REATransitionTypeChange
+};
+
+typedef NS_ENUM(NSInteger, REATransitionAnimationType) {
+  REATransitionAnimationTypeNone = 0,
+  REATransitionAnimationTypeFade,
+  REATransitionAnimationTypeScale,
+  REATransitionAnimationTypeSlideTop,
+  REATransitionAnimationTypeSlideBottom,
+  REATransitionAnimationTypeSlideRight,
+  REATransitionAnimationTypeSlideLeft,
+};
+
+typedef NS_ENUM(NSInteger, REATransitionInterpolationType) {
+  REATransitionInterpolationLinear = 0,
+  REATransitionInterpolationEaseIn,
+  REATransitionInterpolationEaseOut,
+  REATransitionInterpolationEaseInOut,
+};
+
+typedef NS_ENUM(NSInteger, REATransitionPropagationType) {
+  REATransitionPropagationNone = 0,
+  REATransitionPropagationTop,
+  REATransitionPropagationBottom,
+  REATransitionPropagationLeft,
+  REATransitionPropagationRight,
+};
+
+@interface REATransition : NSObject
+@property (nonatomic, weak) REATransition *parent;
+@property (nonatomic) CFTimeInterval duration;
+@property (nonatomic) CFTimeInterval delay;
+@property (nonatomic) REATransitionInterpolationType interpolation;
+@property (nonatomic) REATransitionPropagationType propagation;
+- (instancetype)initWithConfig:(NSDictionary *)config;
+- (CAMediaTimingFunction *)mediaTiming;
+- (void)startCaptureInRoot:(UIView *)root;
+- (void)playInRoot:(UIView *)root;
+- (REATransitionValues *)findStartValuesForKey:(NSNumber *)key;
+- (REATransitionValues *)findEndValuesForKey:(NSNumber *)key;
+- (REATransitionAnimation *)animationForTransitioning:(REATransitionValues*)startValues
+                                               endValues:(REATransitionValues*)endValues
+                                                 forRoot:(UIView *)root;
+- (NSArray<REATransitionAnimation*> *)animationsForTransitioning:(NSMutableDictionary<NSNumber*, REATransitionValues*> *)startValues
+                                                          endValues:(NSMutableDictionary<NSNumber*, REATransitionValues*> *)endValues
+                                                            forRoot:(UIView *)root;
+
++ (REATransition *)inflate:(NSDictionary *)config;
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransition.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransition.m
new file mode 100644
index 0000000..b4fcc68
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransition.m
@@ -0,0 +1,208 @@
+#import <UIKit/UIKit.h>
+#import <QuartzCore/QuartzCore.h>
+#import <React/RCTConvert.h>
+#import <React/RCTViewManager.h>
+
+#import "REATransition.h"
+#import "REATransitionValues.h"
+#import "RCTConvert+REATransition.h"
+
+#define DEFAULT_PROPAGATION_SPEED 3
+
+@interface REATransitionGroup : REATransition
+@property (nonatomic) BOOL sequence;
+@property (nonatomic) NSArray *transitions;
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAVisibilityTransition : REATransition
+@property (nonatomic) REATransitionAnimationType animationType;
+- (REATransitionAnimation *)appearView:(UIView*)view inParent:(UIView*)parent;
+- (REATransitionAnimation *)disappearView:(UIView*)view fromParent:(UIView*)parent;
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAInTransition : REAVisibilityTransition
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAOutTransition : REAVisibilityTransition
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@interface REAChangeTransition : REATransition
+- (instancetype)initWithConfig:(NSDictionary *)config;
+@end
+
+@implementation REATransition {
+  __weak UIView *_root;
+  NSMutableDictionary<NSNumber*, REATransitionValues*> *_startValues;
+  NSMutableDictionary<NSNumber*, REATransitionValues*> *_endValues;
+}
+
++ (REATransition *)inflate:(NSDictionary *)config
+{
+  REATransitionType type = [RCTConvert REATransitionType:config[@"type"]];
+  switch (type) {
+    case REATransitionTypeGroup:
+      return [[REATransitionGroup alloc] initWithConfig:config];
+    case REATransitionTypeIn:
+      return [[REAInTransition alloc] initWithConfig:config];
+    case REATransitionTypeOut:
+      return [[REAOutTransition alloc] initWithConfig:config];
+    case REATransitionTypeChange:
+      return [[REAChangeTransition alloc] initWithConfig:config];
+    case REATransitionTypeNone:
+    default:
+      RCTLogError(@"Invalid transitioning type %@", config[@"type"]);
+  }
+  return nil;
+}
+
+- (instancetype)initWithConfig:(NSDictionary *)config
+{
+  if (self = [super init]) {
+    _duration = [RCTConvert double:config[@"durationMs"]] / 1000.0;
+    _delay = [RCTConvert double:config[@"delayMs"]] / 1000.0;
+    _interpolation = [RCTConvert REATransitionInterpolationType:config[@"interpolation"]];
+    _propagation = [RCTConvert REATransitionPropagationType:config[@"propagation"]];
+  }
+  return self;
+}
+
+- (void)captureRecursiveIn:(UIView *)view to:(NSMutableDictionary<NSNumber*, REATransitionValues*> *)map forRoot:(UIView *)root
+{
+  NSNumber *tag = view.reactTag;
+  if (tag != nil) {
+    map[tag] = [[REATransitionValues alloc] initWithView:view forRoot:root];
+    for (UIView *subview in view.reactSubviews) {
+      [self captureRecursiveIn:subview to:map forRoot:root];
+    }
+  }
+}
+
+- (void)startCaptureInRoot:(UIView *)root
+{
+  _startValues = [NSMutableDictionary new];
+  [self captureRecursiveIn:root to:_startValues forRoot:root];
+}
+
+- (void)playInRoot:(UIView *)root
+{
+  _endValues = [NSMutableDictionary new];
+  [self captureRecursiveIn:root to:_endValues forRoot:root];
+  NSArray *animations = [self animationsForTransitioning:_startValues
+                                               endValues:_endValues
+                                                 forRoot:root];
+  for (REATransitionAnimation *animation in animations) {
+    [animation play];
+  }
+  _startValues = nil;
+  _endValues = nil;
+}
+
+- (REATransitionValues *)findStartValuesForKey:(NSNumber *)key
+{
+  if (_parent != nil) {
+    return [_parent findStartValuesForKey:key];
+  }
+  return _startValues[key];
+}
+
+- (REATransitionValues *)findEndValuesForKey:(NSNumber *)key
+{
+  if (_parent != nil) {
+    return [_parent findEndValuesForKey:key];
+  }
+  return _endValues[key];
+}
+
+- (CFTimeInterval)propagationDelayForTransitioning:(REATransitionValues *)startValues
+                                         endValues:(REATransitionValues *)endValues
+                                           forRoot:(UIView *)root
+{
+  if (self.propagation == REATransitionPropagationNone) {
+    return 0.;
+  }
+
+  REATransitionValues *values = endValues;
+  if (values == nil) {
+    values = startValues;
+  }
+
+  double fraction = 0.;
+  switch (self.propagation) {
+    case REATransitionPropagationLeft:
+      fraction = values.centerRelativeToRoot.x / root.layer.bounds.size.width;
+      break;
+    case REATransitionPropagationRight:
+      fraction = 1. - values.centerRelativeToRoot.x / root.layer.bounds.size.width;
+      break;
+    case REATransitionPropagationTop:
+      fraction = values.centerRelativeToRoot.y / root.layer.bounds.size.height;
+      break;
+    case REATransitionPropagationBottom:
+      fraction = 1. - values.centerRelativeToRoot.y / root.layer.bounds.size.height;
+      break;
+  }
+
+  return _duration * MIN(MAX(0., fraction), 1.) / DEFAULT_PROPAGATION_SPEED;
+}
+
+- (CAMediaTimingFunction *)mediaTiming
+{
+  switch (self.interpolation) {
+    case REATransitionInterpolationLinear:
+      return [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];
+    case REATransitionInterpolationEaseIn:
+      return [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];
+    case REATransitionInterpolationEaseOut:
+      return [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
+    case REATransitionInterpolationEaseInOut:
+      return [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
+  }
+}
+
+- (REATransitionAnimation *)animationForTransitioning:(REATransitionValues *)startValues
+                                               endValues:(REATransitionValues *)endValues
+                                                 forRoot:(UIView *)root
+{
+  return nil;
+}
+
+- (NSArray<REATransitionAnimation*> *)animationsForTransitioning:(NSMutableDictionary<NSNumber *,REATransitionValues *> *)startValues
+                                                          endValues:(NSMutableDictionary<NSNumber *,REATransitionValues *> *)endValues
+                                                            forRoot:(UIView *)root
+{
+  NSMutableArray *animations = [NSMutableArray new];
+  [startValues enumerateKeysAndObjectsUsingBlock:^(NSNumber *key, REATransitionValues *startValue, BOOL *stop) {
+    REATransitionValues *endValue = endValues[key];
+    REATransitionAnimation *animation = [self animationForTransitioning:startValue endValues:endValue forRoot:root];
+    if (animation != nil) {
+      animation.animation.timingFunction = self.mediaTiming;
+      animation.animation.duration = self.duration;
+      [animation delayBy:self.delay];
+      CFTimeInterval propagationDelay = [self propagationDelayForTransitioning:startValue endValues:endValue forRoot:root];
+      [animation delayBy:propagationDelay];
+      //      animation.animation.duration -= propagationDelay;
+      [animations addObject:animation];
+    }
+  }];
+  [endValues enumerateKeysAndObjectsUsingBlock:^(NSNumber *key, REATransitionValues *endValue, BOOL *stop) {
+    if (startValues[key] == nil) {
+      REATransitionAnimation *animation = [self animationForTransitioning:nil endValues:endValue forRoot:root];
+      if (animation != nil) {
+        animation.animation.timingFunction = self.mediaTiming;
+        animation.animation.duration = self.duration;
+        [animation delayBy:self.delay];
+        CFTimeInterval propagationDelay = [self propagationDelayForTransitioning:nil endValues:endValue forRoot:root];
+        [animation delayBy:propagationDelay];
+        //        animation.animation.duration -= propagationDelay;
+        [animations addObject:animation];
+      }
+    }
+  }];
+  return animations;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionAnimation.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionAnimation.h
new file mode 100644
index 0000000..b9efb93
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionAnimation.h
@@ -0,0 +1,17 @@
+#import <Foundation/Foundation.h>
+
+@interface REATransitionAnimation : NSObject
+
+@property (nonatomic) CAAnimation *animation;
+@property (nonatomic) CALayer *layer;
+@property (nonatomic) NSString *keyPath;
+
++ (REATransitionAnimation *)transitionWithAnimation:(CAAnimation *)animation
+                                              layer:(CALayer *)layer
+                                         andKeyPath:(NSString*)keyPath;
+- (void)play;
+- (void)delayBy:(CFTimeInterval)delay;
+- (CFTimeInterval)finishTime;
+- (CFTimeInterval)duration;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionAnimation.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionAnimation.m
new file mode 100644
index 0000000..153d11b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionAnimation.m
@@ -0,0 +1,81 @@
+#import <UIKit/UIKit.h>
+
+#import "REATransitionAnimation.h"
+
+
+#define DEFAULT_DURATION 0.25
+
+#if TARGET_IPHONE_SIMULATOR
+// Based on https://stackoverflow.com/a/13307674
+float UIAnimationDragCoefficient(void);
+#endif
+
+CGFloat SimAnimationDragCoefficient()
+{
+#if TARGET_IPHONE_SIMULATOR
+  if (NSClassFromString(@"XCTest") != nil) {
+    // UIAnimationDragCoefficient is 10.0 in tests for some reason, but
+    // we need it to be 1.0.
+    return 1.0;
+  } else {
+    return (CGFloat)UIAnimationDragCoefficient();
+  }
+#else
+  return 1.0;
+#endif
+}
+
+@implementation REATransitionAnimation {
+  NSTimeInterval _delay;
+}
+
++ (REATransitionAnimation *)transitionWithAnimation:(CAAnimation *)animation
+                                              layer:(CALayer *)layer
+                                         andKeyPath:(NSString*)keyPath;
+{
+  REATransitionAnimation *anim = [REATransitionAnimation new];
+  anim.animation = animation;
+  anim.layer = layer;
+  anim.keyPath = keyPath;
+  return anim;
+}
+
+- (void)play
+{
+  /*
+  CACurrentMediaTime introduces some kind of delay  even if _delay is set to 0
+  it calls mach_absolute_time() which is based on the last time the device booted
+  which might cause the delay
+  */
+  if (_delay > 0){
+    _animation.beginTime = CACurrentMediaTime() + _delay * SimAnimationDragCoefficient();
+  }
+  _animation.duration = self.duration * SimAnimationDragCoefficient();
+  [_layer addAnimation:_animation forKey:_keyPath];
+}
+
+- (void)delayBy:(CFTimeInterval)delay
+{
+  if (delay <= 0) {
+    return;
+  }
+  _delay += delay;
+}
+
+- (CFTimeInterval)duration
+{
+  if (_animation.duration == 0) {
+    return DEFAULT_DURATION;
+  }
+  return _animation.duration;
+}
+
+- (CFTimeInterval)finishTime
+{
+  if (_animation.beginTime == 0) {
+    return CACurrentMediaTime() + self.duration + _delay;
+  }
+  return _animation.beginTime + self.duration + _delay;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionManager.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionManager.h
new file mode 100644
index 0000000..d3a3844
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionManager.h
@@ -0,0 +1,9 @@
+#import <Foundation/Foundation.h>
+#import <React/RCTUIManager.h>
+
+@interface REATransitionManager : NSObject
+
+- (instancetype)initWithUIManager:(RCTUIManager *)uiManager;
+- (void)animateNextTransitionInRoot:(nonnull NSNumber *)reactTag withConfig:(NSDictionary *)config;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionManager.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionManager.m
new file mode 100644
index 0000000..fb1d44c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionManager.m
@@ -0,0 +1,62 @@
+#import "REATransitionManager.h"
+
+#import <React/RCTUIManager.h>
+#import <React/RCTUIManagerObserverCoordinator.h>
+
+#import "REATransition.h"
+
+@interface REATransitionManager () <RCTUIManagerObserver>
+@end
+
+@implementation REATransitionManager {
+  REATransition *_pendingTransition;
+  UIView *_pendingTransitionRoot;
+  RCTUIManager *_uiManager;
+}
+
+- (instancetype)initWithUIManager:(id)uiManager
+{
+  if (self = [super init]) {
+    _uiManager = uiManager;
+  }
+  return self;
+}
+
+- (void)beginTransition:(REATransition *)transition forView:(UIView *)view
+{
+  RCTAssertMainQueue();
+  if (_pendingTransition != nil) {
+    return;
+  }
+  _pendingTransition = transition;
+  _pendingTransitionRoot = view;
+  [transition startCaptureInRoot:view];
+}
+
+- (void)uiManagerWillPerformMounting:(RCTUIManager *)manager
+{
+  [manager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {
+    [_pendingTransition playInRoot:_pendingTransitionRoot];
+    _pendingTransitionRoot = nil;
+    _pendingTransition = nil;
+  }];
+}
+
+- (void)animateNextTransitionInRoot:(NSNumber *)reactTag withConfig:(NSDictionary *)config
+{
+  [_uiManager.observerCoordinator addObserver:self];
+  [_uiManager prependUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {
+    UIView *view = viewRegistry[reactTag];
+    NSArray *transitionConfigs = [RCTConvert NSArray:config[@"transitions"]];
+    for (id transitionConfig in transitionConfigs) {
+      REATransition *transition = [REATransition inflate:transitionConfig];
+      [self beginTransition:transition forView:view];
+    }
+  }];
+  __weak id weakSelf = self;
+  [_uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {
+    [uiManager.observerCoordinator removeObserver:weakSelf];
+  }];
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionValues.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionValues.h
new file mode 100644
index 0000000..a1f739d
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionValues.h
@@ -0,0 +1,15 @@
+#import <UIKit/UIKit.h>
+
+@interface REATransitionValues : NSObject
+
+@property (nonatomic) CGPoint center;
+@property (nonatomic) CGRect bounds;
+@property (nonatomic) CGPoint centerRelativeToRoot;
+@property (nonatomic, retain) UIView *view;
+@property (nonatomic, retain) UIView *parent;
+@property (nonatomic, retain) UIView *reactParent;
+@property (nonatomic) CGPoint centerInReactParent;
+
+- (instancetype)initWithView:(UIView *)view forRoot:(UIView *)root;
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionValues.m b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionValues.m
new file mode 100644
index 0000000..18b704e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/Transitioning/REATransitionValues.m
@@ -0,0 +1,26 @@
+#import <React/RCTView.h>
+#import <React/RCTViewManager.h>
+
+#import "REATransition.h"
+#import "REATransitionValues.h"
+
+@implementation REATransitionValues
+
+- (instancetype)initWithView:(UIView *)view forRoot:(UIView *)root
+{
+  if (self = [super init]) {
+    _view = view;
+    _parent = view.superview;
+    _reactParent = view.reactSuperview;
+    while (_reactParent != nil && _reactParent != root && IS_LAYOUT_ONLY(_reactParent)) {
+      _reactParent = _reactParent.reactSuperview;
+    }
+    _center = view.center;
+    _bounds = view.bounds;
+    _centerRelativeToRoot = [_parent convertPoint:_center toView:root];
+    _centerInReactParent = [_parent convertPoint:_center toView:_reactParent];
+  }
+  return self;
+}
+
+@end
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeMethods.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeMethods.h
new file mode 100644
index 0000000..a29f25c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeMethods.h
@@ -0,0 +1,11 @@
+#import <Foundation/Foundation.h>
+#import <vector>
+#import <string>
+#import <React/RCTUIManager.h>
+
+namespace reanimated {
+
+std::vector<std::pair<std::string,double>> measure(int viewTag, RCTUIManager *uiManager);
+void scrollTo(int scrollViewTag, RCTUIManager *uiManager, double x, double y, bool animated);
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeMethods.mm b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeMethods.mm
new file mode 100644
index 0000000..a640c5f
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeMethods.mm
@@ -0,0 +1,50 @@
+#import "NativeMethods.h"
+#import <React/RCTScrollView.h>
+
+
+namespace reanimated {
+
+std::vector<std::pair<std::string,double>> measure(int viewTag, RCTUIManager *uiManager) {
+  UIView *view = [uiManager viewForReactTag:@(viewTag)];
+ 
+  UIView *rootView = view;
+  
+  if (view == nil) {
+    return std::vector<std::pair<std::string, double>>(0, std::make_pair("x", -1234567.0));
+  }
+  
+  while (rootView.superview && ![rootView isReactRootView]) {
+    rootView = rootView.superview;
+  }
+  
+  if (rootView == nil || (![rootView isReactRootView])) {
+    return std::vector<std::pair<std::string, double>>(0, std::make_pair("x", -1234567.0));
+  }
+
+  CGRect frame = view.frame;
+  CGRect globalBounds = [view convertRect:view.bounds toView:rootView];
+
+  std::vector<std::pair<std::string, double>> result;
+  result.push_back({"x", frame.origin.x});
+  result.push_back({"y", frame.origin.y});
+  
+  result.push_back({"width", globalBounds.size.width});
+  result.push_back({"height", globalBounds.size.height});
+  
+  result.push_back({"pageX", globalBounds.origin.x});
+  result.push_back({"pageY", globalBounds.origin.y});
+  return result;
+}
+
+
+NSString *eventDispatcherKey = @"eventDispatcher";
+void scrollTo(int scrollViewTag, RCTUIManager *uiManager, double x, double y, bool animated) {
+  UIView *view = [uiManager viewForReactTag:@(scrollViewTag)];
+  RCTScrollView *scrollView = (RCTScrollView *) view;
+  RCTEventDispatcher* oldEventDispatcher = [scrollView valueForKey:eventDispatcherKey];
+  [scrollView setValue:nil forKey:eventDispatcherKey];
+  [scrollView scrollToOffset:(CGPoint){(CGFloat)x, (CGFloat)y} animated:animated];
+  [scrollView setValue:oldEventDispatcher forKey:eventDispatcherKey];
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeProxy.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeProxy.h
new file mode 100644
index 0000000..bfa2513
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeProxy.h
@@ -0,0 +1,13 @@
+#import <React/RCTEventDispatcher.h>
+
+#if __cplusplus
+
+#import <RNReanimated/NativeReanimatedModule.h>
+
+namespace reanimated {
+ 
+std::shared_ptr<reanimated::NativeReanimatedModule> createReanimatedModule(std::shared_ptr<facebook::react::CallInvoker> jsInvoker);
+
+}
+
+#endif
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeProxy.mm b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeProxy.mm
new file mode 100644
index 0000000..bcd62c9
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/NativeProxy.mm
@@ -0,0 +1,143 @@
+#import "NativeProxy.h"
+#import "REAIOSScheduler.h"
+#import "REAIOSErrorHandler.h"
+#import "RuntimeDecorator.h"
+#import "REAModule.h"
+#import "REANodesManager.h"
+#import "NativeMethods.h"
+#import <jsi/JSCRuntime.h>
+#import <folly/json.h>
+#import <React/RCTFollyConvert.h>
+#import <React/RCTUIManager.h>
+
+namespace reanimated {
+
+using namespace facebook;
+using namespace react;
+
+
+// COPIED FROM RCTTurboModule.mm
+static id convertJSIValueToObjCObject(jsi::Runtime &runtime, const jsi::Value &value);
+
+static NSString *convertJSIStringToNSString(jsi::Runtime &runtime, const jsi::String &value)
+{
+  return [NSString stringWithUTF8String:value.utf8(runtime).c_str()];
+}
+
+static NSDictionary *convertJSIObjectToNSDictionary(jsi::Runtime &runtime, const jsi::Object &value)
+{
+  jsi::Array propertyNames = value.getPropertyNames(runtime);
+  size_t size = propertyNames.size(runtime);
+  NSMutableDictionary *result = [NSMutableDictionary new];
+  for (size_t i = 0; i < size; i++) {
+    jsi::String name = propertyNames.getValueAtIndex(runtime, i).getString(runtime);
+    NSString *k = convertJSIStringToNSString(runtime, name);
+    id v = convertJSIValueToObjCObject(runtime, value.getProperty(runtime, name));
+    if (v) {
+      result[k] = v;
+    }
+  }
+  return [result copy];
+}
+
+static NSArray *
+convertJSIArrayToNSArray(jsi::Runtime &runtime, const jsi::Array &value)
+{
+  size_t size = value.size(runtime);
+  NSMutableArray *result = [NSMutableArray new];
+  for (size_t i = 0; i < size; i++) {
+    // Insert kCFNull when it's `undefined` value to preserve the indices.
+    [result
+        addObject:convertJSIValueToObjCObject(runtime, value.getValueAtIndex(runtime, i)) ?: (id)kCFNull];
+  }
+  return [result copy];
+}
+
+static id convertJSIValueToObjCObject(jsi::Runtime &runtime, const jsi::Value &value)
+{
+  if (value.isUndefined() || value.isNull()) {
+    return nil;
+  }
+  if (value.isBool()) {
+    return @(value.getBool());
+  }
+  if (value.isNumber()) {
+    return @(value.getNumber());
+  }
+  if (value.isString()) {
+    return convertJSIStringToNSString(runtime, value.getString(runtime));
+  }
+  if (value.isObject()) {
+    jsi::Object o = value.getObject(runtime);
+    if (o.isArray(runtime)) {
+      return convertJSIArrayToNSArray(runtime, o.getArray(runtime));
+    }
+    return convertJSIObjectToNSDictionary(runtime, o);
+  }
+
+  throw std::runtime_error("Unsupported jsi::jsi::Value kind");
+}
+
+std::shared_ptr<NativeReanimatedModule> createReanimatedModule(std::shared_ptr<CallInvoker> jsInvoker) {
+  RCTBridge *bridge = _bridge_reanimated;
+  REAModule *reanimatedModule = [bridge moduleForClass:[REAModule class]];
+
+  auto propUpdater = [reanimatedModule](jsi::Runtime &rt, int viewTag, const jsi::Object &props) -> void {
+    NSDictionary *propsDict = convertJSIObjectToNSDictionary(rt, props);
+    [reanimatedModule.nodesManager updateProps:propsDict ofViewWithTag:[NSNumber numberWithInt:viewTag] viewName:@"RCTView"];
+  };
+
+  auto requestRender = [reanimatedModule](std::function<void(double)> onRender) {
+    [reanimatedModule.nodesManager postOnAnimation:^(CADisplayLink *displayLink) {
+      onRender(displayLink.timestamp * 1000.0);
+    }];
+  };
+  
+  RCTUIManager *uiManager = reanimatedModule.nodesManager.uiManager;
+  auto measuringFunction = [uiManager](int viewTag) -> std::vector<std::pair<std::string, double>> {
+    return measure(viewTag, uiManager);
+  };
+  
+  auto scrollToFunction = [uiManager](int viewTag, double x, double y, bool animated) {
+    scrollTo(viewTag, uiManager, x, y, animated);
+  };
+
+  auto propObtainer = [reanimatedModule](jsi::Runtime &rt, const int viewTag, const jsi::String &propName) -> jsi::Value {
+    NSString* propNameConverted = [NSString stringWithFormat:@"%s",propName.utf8(rt).c_str()];
+      std::string resultStr = std::string([[reanimatedModule.nodesManager obtainProp:[NSNumber numberWithInt:viewTag] propName:propNameConverted] UTF8String]);
+      jsi::Value val = jsi::String::createFromUtf8(rt, resultStr);
+      return val;
+  };
+
+  std::shared_ptr<Scheduler> scheduler(new REAIOSScheduler(jsInvoker));
+  std::unique_ptr<jsi::Runtime> animatedRuntime = facebook::jsc::makeJSCRuntime();
+  std::shared_ptr<ErrorHandler> errorHandler = std::make_shared<REAIOSErrorHandler>(scheduler);
+
+  PlatformDepMethodsHolder platformDepMethodsHolder = {
+    requestRender,
+    propUpdater,
+    scrollToFunction,
+    measuringFunction
+  };
+  
+  std::shared_ptr<NativeReanimatedModule> module(new NativeReanimatedModule(jsInvoker,
+                                                                            scheduler,
+                                                                            std::move(animatedRuntime),
+                                                                            errorHandler,
+                                                                            propObtainer,
+                                                                            platformDepMethodsHolder
+                                                                            ));
+
+  [reanimatedModule.nodesManager registerEventHandler:^(NSString *eventName, id<RCTEvent> event) {
+    std::string eventNameString([eventName UTF8String]);
+    std::string eventAsString = folly::toJson(convertIdToFollyDynamic([event arguments][2]));
+
+    eventAsString = "{ NativeMap:"  + eventAsString + "}";
+    module->onEvent(eventNameString, eventAsString);
+  }];
+
+  return module;
+}
+
+}
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSErrorHandler.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSErrorHandler.h
new file mode 100644
index 0000000..4bc65ca
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSErrorHandler.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "ErrorHandler.h"
+#include "Scheduler.h"
+
+namespace reanimated {
+
+class REAIOSErrorHandler : public ErrorHandler {
+    std::shared_ptr<Scheduler> scheduler;
+    void raiseSpec() override;
+    std::shared_ptr<ErrorWrapper> error;
+    public:
+      REAIOSErrorHandler(std::shared_ptr<Scheduler> scheduler);
+      std::shared_ptr<Scheduler> getScheduler() override;
+      std::shared_ptr<ErrorWrapper> getError() override;
+      void setError(std::string message) override;
+      virtual ~REAIOSErrorHandler() {}
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSErrorHandler.mm b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSErrorHandler.mm
new file mode 100644
index 0000000..4d78de6
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSErrorHandler.mm
@@ -0,0 +1,36 @@
+#include "REAIOSErrorHandler.h"
+#import <Foundation/Foundation.h>
+#import <React/RCTLog.h>
+
+
+namespace reanimated {
+
+REAIOSErrorHandler::REAIOSErrorHandler(std::shared_ptr<Scheduler> scheduler) {
+    this->scheduler = scheduler;
+    error = std::make_shared<ErrorWrapper>();
+}
+
+void REAIOSErrorHandler::raiseSpec() {
+    if (error->handled) {
+        return;
+    }
+    RCTLogError(@(error->message.c_str()));
+    this->error->handled = true;
+}
+
+std::shared_ptr<Scheduler> REAIOSErrorHandler::getScheduler() {
+    return this->scheduler;
+}
+
+std::shared_ptr<ErrorWrapper> REAIOSErrorHandler::getError() {
+    return this->error;
+}
+
+void REAIOSErrorHandler::setError(std::string message) {
+  if (error->handled) {
+    error->message = message;
+    error->handled = false;
+  }
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSLogger.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSLogger.h
new file mode 100644
index 0000000..02a6521
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSLogger.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "LoggerInterface.h"
+#include <stdio.h>
+
+namespace reanimated {
+
+class REAIOSLogger : public LoggerInterface {
+  public:
+    void log(const char* str) override;
+    void log(double d) override;
+    void log(int i) override;
+    void log(bool b) override;
+    virtual ~REAIOSLogger() {}
+};
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSLogger.mm b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSLogger.mm
new file mode 100644
index 0000000..237a91a
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSLogger.mm
@@ -0,0 +1,26 @@
+#include "REAIOSLogger.h"
+#include "Logger.h"
+#import <Foundation/Foundation.h>
+
+namespace reanimated {
+
+std::unique_ptr<LoggerInterface> Logger::instance = std::unique_ptr<REAIOSLogger>(new REAIOSLogger());
+
+void REAIOSLogger::log(const char* str) {
+  NSLog(@"%@", [NSString stringWithCString:str encoding:[NSString defaultCStringEncoding]]);
+}
+
+void REAIOSLogger::log(double d) {
+  NSLog(@"%lf", d);
+}
+
+void REAIOSLogger::log(int i) {
+   NSLog(@"%i", i);
+}
+
+void REAIOSLogger::log(bool b) {
+  const char* str = (b)? "true" : "false";
+  NSLog(@"%@", [NSString stringWithCString:str encoding:[NSString defaultCStringEncoding]]);
+}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSScheduler.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSScheduler.h
new file mode 100644
index 0000000..d1c00e0
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSScheduler.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <stdio.h>
+#include "Scheduler.h"
+#import <ReactCommon/CallInvoker.h>
+#import <React/RCTUIManager.h>
+
+namespace reanimated
+{
+
+using namespace facebook;
+using namespace react;
+
+class REAIOSScheduler : public Scheduler {
+  public:
+  REAIOSScheduler(std::shared_ptr<CallInvoker> jsInvoker);
+  void scheduleOnUI(std::function<void()> job) override;
+  virtual ~REAIOSScheduler();
+};
+
+} // namespace reanimated
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSScheduler.mm b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSScheduler.mm
new file mode 100644
index 0000000..4cdfc93
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REAIOSScheduler.mm
@@ -0,0 +1,21 @@
+#include "REAIOSScheduler.h"
+
+namespace reanimated {
+
+using namespace facebook;
+using namespace react;
+
+REAIOSScheduler::REAIOSScheduler(std::shared_ptr<CallInvoker> jsInvoker) {
+  this->jsCallInvoker_ = jsInvoker;
+}
+
+void REAIOSScheduler::scheduleOnUI(std::function<void()> job) {
+  Scheduler::scheduleOnUI(job);
+  dispatch_async(dispatch_get_main_queue(), ^{
+    triggerUI();
+  });
+}
+
+REAIOSScheduler::~REAIOSScheduler(){}
+
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REATurboModuleProvider.h b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REATurboModuleProvider.h
new file mode 100644
index 0000000..77f0404
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REATurboModuleProvider.h
@@ -0,0 +1,30 @@
+
+#import <Foundation/Foundation.h>
+#import <ReactCommon/RCTTurboModule.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+namespace facebook {
+namespace react {
+
+/**
+ * Provide the TurboModule class for the given name.
+ */
+Class REATurboModuleClassProvider(const char *name);
+
+/**
+ * Provide a pure C++ instance of a TurboModule, specific to this app.
+ */
+std::shared_ptr<TurboModule> REATurboModuleProvider(const std::string &name, std::shared_ptr<CallInvoker> jsInvoker);
+
+/**
+ * Provide an instance of a ObjCTurboModule, given the ObjC instance, specific to this app.
+ */
+std::shared_ptr<TurboModule> REATurboModuleProvider(const std::string &name,
+                                                         id<RCTTurboModule> instance,
+                                                         std::shared_ptr<CallInvoker> jsInvoker);
+
+} // namespace react
+} // namespace facebook
+
+NS_ASSUME_NONNULL_END
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REATurboModuleProvider.mm b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REATurboModuleProvider.mm
new file mode 100644
index 0000000..e168b88
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/ios/native/REATurboModuleProvider.mm
@@ -0,0 +1,32 @@
+
+#import "REATurboModuleProvider.h"
+#import "NativeProxy.h"
+#import <React/CoreModulesPlugins.h>
+#import <NativeReanimatedModule.h>
+#import <jsi/JSCRuntime.h>
+
+// NOTE: This entire file should be codegen'ed.
+
+namespace facebook {
+namespace react {
+
+Class REATurboModuleClassProvider(const char *name) {
+  return RCTCoreModulesClassProvider(name);
+}
+
+std::shared_ptr<TurboModule> REATurboModuleProvider(const std::string &name, std::shared_ptr<CallInvoker> jsInvoker) {
+  if (name == "NativeReanimated") {
+    return reanimated::createReanimatedModule(jsInvoker);
+  }
+
+  return nullptr;
+}
+
+std::shared_ptr<TurboModule> REATurboModuleProvider(const std::string &name,
+                                                         id<RCTTurboModule> instance,
+                                                         std::shared_ptr<CallInvoker> jsInvoker) {
+  return nullptr;
+}
+
+} // namespace react
+} // namespace facebook
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/mock.js b/node_modules/react-native-reanimated/react-native-reanimated/mock.js
new file mode 100644
index 0000000..bd922eb
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/mock.js
@@ -0,0 +1,237 @@
+/**
+ * Mock implementation for test runners.
+ *
+ * Example:
+ *
+ * ```js
+ * jest.mock('react-native-reanimated', () => require('react-native-reanimated/mock'));
+ * ```
+ */
+
+const React = require('react');
+const { View, Text, Image, Animated, Platform } = require('react-native');
+
+function NOOP() {}
+
+function simulateCallbackFactory(...params) {
+  return (callback) => {
+    callback &&
+      setTimeout(() => {
+        callback(...params);
+      }, 0);
+  };
+}
+
+class Code extends React.Component {
+  render() {
+    return null;
+  }
+}
+
+const getValue = (node) => {
+  if (typeof node === 'number') {
+    return node;
+  }
+  return (node && node[' __value']) || 0;
+};
+
+class AnimatedValue {
+  constructor(val) {
+    this[' __value'] = val;
+  }
+
+  setValue(val) {
+    this[' __value'] = val;
+  }
+
+  interpolate() {
+    return this;
+  }
+}
+
+function createMockComponent(name) {
+  return class extends React.Component {
+    static displayName = name;
+
+    render() {
+      return this.props.children;
+    }
+  };
+}
+
+function createTransitioningComponent(Component) {
+  return class extends React.Component {
+    static displayName = `Transitioning.${
+      Component.displayName || Component.name || 'Component'
+    }`;
+
+    setNativeProps() {}
+
+    animateNextTransition() {}
+
+    render() {
+      return <Component {...this.props} />;
+    }
+  };
+}
+
+const Reanimated = {
+  SpringUtils: {
+    makeDefaultConfig: NOOP,
+    makeConfigFromBouncinessAndSpeed: NOOP,
+    makeConfigFromOrigamiTensionAndFriction: NOOP,
+  },
+
+  View,
+  Text,
+  Image,
+  ScrollView: Animated.ScrollView,
+  Code,
+
+  Clock: NOOP,
+  Node: NOOP,
+  Value: AnimatedValue,
+  
+  EasingNode: {
+    linear: NOOP,
+    ease: NOOP,
+    quad: NOOP,
+    cubic: NOOP,
+    poly: () => NOOP,
+    sin: NOOP,
+    circle: NOOP,
+    exp: NOOP,
+    elastic: () => NOOP,
+    back: () => NOOP,
+    bounce: () => NOOP,
+    bezier: () => NOOP,
+    in: () => NOOP,
+    out: () => NOOP,
+    inOut: () => NOOP,
+  },
+
+  Extrapolate: {
+    EXTEND: 'extend',
+    CLAMP: 'clamp',
+    IDENTITY: 'identity',
+  },
+
+  add: (...vals) =>
+    new AnimatedValue(vals.map((v) => getValue(v)).reduce((acc, v) => acc + v)),
+  sub: (...vals) =>
+    new AnimatedValue(vals.map((v) => getValue(v)).reduce((acc, v) => acc - v)),
+  divide: (...vals) =>
+    new AnimatedValue(vals.map((v) => getValue(v)).reduce((acc, v) => acc / v)),
+  multiply: (...vals) =>
+    new AnimatedValue(vals.map((v) => getValue(v)).reduce((acc, v) => acc * v)),
+  pow: (...vals) =>
+    new AnimatedValue(
+      vals.map((v) => getValue(v)).reduce((acc, v) => acc ** v)
+    ),
+  modulo: (a, b) => new AnimatedValue(getValue(a) % getValue(b)),
+  sqrt: (a) => new AnimatedValue(Math.sqrt(getValue(a))),
+  log: (a) => new AnimatedValue(Math.log(getValue(a))),
+  sin: (a) => new AnimatedValue(Math.sin(getValue(a))),
+  cos: (a) => new AnimatedValue(Math.cos(getValue(a))),
+  tan: (a) => new AnimatedValue(Math.tan(getValue(a))),
+  acos: (a) => new AnimatedValue(Math.acos(getValue(a))),
+  asin: (a) => new AnimatedValue(Math.asin(getValue(a))),
+  atan: (a) => new AnimatedValue(Math.atan(getValue(a))),
+  exp: (a) => new AnimatedValue(Math.exp(getValue(a))),
+  round: (a) => new AnimatedValue(Math.round(getValue(a))),
+  floor: (a) => new AnimatedValue(Math.floor(getValue(a))),
+  ceil: (a) => new AnimatedValue(Math.ceil(getValue(a))),
+  lessThan: (a, b) => new AnimatedValue(getValue(a) < getValue(b)),
+  eq: (a, b) => new AnimatedValue(getValue(a) === getValue(b)),
+  greaterThan: (a, b) => new AnimatedValue(getValue(a) > getValue(b)),
+  lessOrEq: (a, b) => new AnimatedValue(getValue(a) <= getValue(b)),
+  greaterOrEq: (a, b) => new AnimatedValue(getValue(a) >= getValue(b)),
+  neq: (a, b) => new AnimatedValue(getValue(a) !== getValue(b)),
+  and: (a, b) => new AnimatedValue(getValue(a) && getValue(b)),
+  or: (a, b) => new AnimatedValue(getValue(a) || getValue(b)),
+  defined: (a) =>
+    new AnimatedValue(getValue(a) !== null && getValue(a) !== undefined),
+  not: (a) => new AnimatedValue(!getValue(a)),
+  set: (a, b) => {
+    a.setValue(getValue(b));
+    return a;
+  },
+  concat: (a, b) => `${a}${b}`,
+  cond: (a, b, c) => {
+    if (getValue(a)) {
+      return b;
+    } else {
+      return c;
+    }
+  },
+  block: (a) => a[a.length - 1],
+  call: (a, b) => b(a.map(getValue)),
+  debug: NOOP,
+  onChange: NOOP,
+  startClock: NOOP,
+  stopClock: NOOP,
+  clockRunning: NOOP,
+  event: NOOP,
+  abs: (a) => Math.abs(getValue(a)),
+  acc: NOOP,
+  color: (r, g, b, a = 1) => {
+    const color =
+      16777216 * Math.round(getValue(a) * 255) +
+      65536 * getValue(r) +
+      256 * getValue(g) +
+      getValue(b);
+    if (Platform.OS === 'android') {
+      // on Android color is represented as signed 32 bit int
+      if (color < (1 << 31) >>> 0) {
+        return new AnimatedValue(color);
+      }
+      return new AnimatedValue(color - 2 ** 32);
+    }
+    return new AnimatedValue(color);
+  },
+  diff: NOOP,
+  diffClamp: NOOP,
+  interpolate: NOOP,
+  max: (a, b) => Math.max(getValue(a), getValue(b)),
+  min: (a, b) => Math.min(getValue(a), getValue(b)),
+
+  decay: () => ({
+    start: simulateCallbackFactory({ finished: true }),
+    stop: simulateCallbackFactory({ finished: true }),
+  }),
+  timing: () => ({
+    start: simulateCallbackFactory({ finished: true }),
+    stop: simulateCallbackFactory({ finished: true }),
+  }),
+  spring: () => ({
+    start: simulateCallbackFactory({ finished: true }),
+    stop: simulateCallbackFactory({ finished: true }),
+  }),
+
+  proc: (cb) => cb,
+
+  useCode: NOOP,
+  createAnimatedComponent: (Component) => Component,
+};
+
+module.exports = {
+  __esModule: true,
+
+  ...Reanimated,
+
+  default: Reanimated,
+
+  Transitioning: {
+    View: createTransitioningComponent(View),
+  },
+
+  Transition: {
+    Sequence: createMockComponent('Transition.Sequence'),
+    Together: createMockComponent('Transition.Together'),
+    In: createMockComponent('Transition.In'),
+    Out: createMockComponent('Transition.Out'),
+    Change: createMockComponent('Transition.Change'),
+  },
+
+  createTransitioningComponent,
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/plugin.js b/node_modules/react-native-reanimated/react-native-reanimated/plugin.js
new file mode 100644
index 0000000..0ac2c44
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/plugin.js
@@ -0,0 +1,536 @@
+'use strict';
+
+const generate = require('@babel/generator').default;
+const hash = require('string-hash-64');
+const { visitors } = require('@babel/traverse');
+const traverse = require('@babel/traverse').default;
+const parse = require('@babel/parser').parse;
+
+/**
+ * holds a map of hooks names as keys and array of argument indexes which are worklets(starting from 0)
+ */
+const functionHooks = new Map([
+  ['useAnimatedStyle', [0]],
+  ['useAnimatedProps', [0]],
+  ['useDerivedValue', [0]],
+  ['useAnimatedScrollHandler', [0]],
+  ['useAnimatedReaction', [0, 1]],
+]);
+
+const objectHooks = new Set([
+  'useAnimatedGestureHandler',
+  'useAnimatedScrollHandler',
+]);
+
+const globals = new Set([
+  'this',
+  'Date',
+  'Array',
+  'ArrayBuffer',
+  'Date',
+  'HermesInternal',
+  'JSON',
+  'Math',
+  'Number',
+  'Object',
+  'String',
+  'undefined',
+  'null',
+  'UIManager',
+  'requestAnimationFrame',
+  '_WORKLET',
+  'arguments',
+  'Map',
+  'Set',
+  '_log',
+  '_updateProps',
+  'RegExp',
+  'Error',
+  'global',
+  '_measure',
+  '_scrollTo',
+]);
+
+// leaving way to avoid deep capturing by adding 'stopCapturing' to the blacklist
+const blacklistedFunctions = new Set([
+  'stopCapturing',
+  'toString',
+  'map',
+  'filter',
+  'forEach',
+  'valueOf',
+  'toPrecision',
+  'toExponential',
+  'constructor',
+  'toFixed',
+  'toLocaleString',
+  'toSource',
+  'charAt',
+  'charCodeAt',
+  'concat',
+  'indexOf',
+  'lastIndexOf',
+  'localeCompare',
+  'length',
+  'match',
+  'replace',
+  'search',
+  'slice',
+  'split',
+  'substr',
+  'substring',
+  'toLocaleLowerCase',
+  'toLocaleUpperCase',
+  'toLowerCase',
+  'toUpperCase',
+  'every',
+  'join',
+  'pop',
+  'push',
+  'reduce',
+  'reduceRight',
+  'reverse',
+  'shift',
+  'slice',
+  'some',
+  'sort',
+  'splice',
+  'unshift',
+  'hasOwnProperty',
+  'isPrototypeOf',
+  'propertyIsEnumerable',
+  'bind',
+  'apply',
+  'call',
+]);
+
+class ClosureGenerator {
+  trie = [{}, false];
+
+  mergeAns(oldAns, newAns) {
+    const [purePath, node] = oldAns;
+    const [purePathUp, nodeUp] = newAns;
+    if (purePathUp.length !== 0) {
+      return [purePath.concat(purePathUp), nodeUp];
+    } else {
+      return [purePath, node];
+    }
+  }
+
+  findPrefixRec(path) {
+    const notFound = [[], null];
+    if (!path || path.node.type !== 'MemberExpression') {
+      return notFound;
+    }
+    const memberExpressionNode = path.node;
+    if (memberExpressionNode.property.type !== 'Identifier') {
+      return notFound;
+    }
+    if (
+      memberExpressionNode.computed ||
+      memberExpressionNode.property.name === 'value' ||
+      blacklistedFunctions.has(memberExpressionNode.property.name)
+    ) {
+      // a.b[w] -> a.b.w in babel nodes
+      // a.v.value
+      // sth.map(() => )
+      return notFound;
+    }
+    if (
+      path.parent &&
+      path.parent.type === 'AssignmentExpression' &&
+      path.parent.left === path.node
+    ) {
+      /// captured.newProp = 5;
+      return notFound;
+    }
+    const purePath = [memberExpressionNode.property.name];
+    const node = memberExpressionNode;
+    const upAns = this.findPrefixRec(path.parentPath);
+    return this.mergeAns([purePath, node], upAns);
+  }
+
+  findPrefix(base, babelPath) {
+    const purePath = [base];
+    const node = babelPath.node;
+    const upAns = this.findPrefixRec(babelPath.parentPath);
+    return this.mergeAns([purePath, node], upAns);
+  }
+
+  addPath(base, babelPath) {
+    const [purePath, node] = this.findPrefix(base, babelPath);
+    let parent = this.trie;
+    let index = -1;
+    for (const current of purePath) {
+      index++;
+      if (parent[1]) {
+        continue;
+      }
+      if (!parent[0][current]) {
+        parent[0][current] = [{}, false];
+      }
+      if (index === purePath.length - 1) {
+        parent[0][current] = [node, true];
+      }
+      parent = parent[0][current];
+    }
+  }
+
+  generateNodeForBase(t, current, parent) {
+    const currentNode = parent[0][current];
+    if (currentNode[1]) {
+      return currentNode[0];
+    }
+    return t.objectExpression(
+      Object.keys(currentNode[0]).map((propertyName) =>
+        t.objectProperty(
+          t.identifier(propertyName),
+          this.generateNodeForBase(t, propertyName, currentNode),
+          false,
+          true
+        )
+      )
+    );
+  }
+
+  generate(t, variables, names) {
+    const arrayOfKeys = [...names];
+    return t.objectExpression(
+      variables.map((variable, index) =>
+        t.objectProperty(
+          t.identifier(variable.name),
+          this.generateNodeForBase(t, arrayOfKeys[index], this.trie),
+          false,
+          true
+        )
+      )
+    );
+  }
+}
+
+function buildWorkletString(t, fun, closureVariables, name) {
+  fun.traverse({
+    enter(path) {
+      t.removeComments(path.node);
+    },
+  });
+
+  let workletFunction;
+  if (closureVariables.length > 0) {
+    workletFunction = t.functionExpression(
+      t.identifier(name),
+      fun.node.params,
+      t.blockStatement([
+        t.variableDeclaration('const', [
+          t.variableDeclarator(
+            t.objectPattern(
+              closureVariables.map((variable) =>
+                t.objectProperty(
+                  t.identifier(variable.name),
+                  t.identifier(variable.name),
+                  false,
+                  true
+                )
+              )
+            ),
+            t.memberExpression(t.identifier('jsThis'), t.identifier('_closure'))
+          ),
+        ]),
+        fun.get('body').node,
+      ])
+    );
+  } else {
+    workletFunction = t.functionExpression(
+      t.identifier(name),
+      fun.node.params,
+      fun.get('body').node
+    );
+  }
+
+  return generate(workletFunction, { compact: true }).code;
+}
+
+function processWorkletFunction(t, fun) {
+  if (!t.isFunctionParent(fun)) {
+    return;
+  }
+
+  let functionName = '_f';
+
+  if (fun.node.id) {
+    functionName = fun.node.id.name;
+  }
+
+  const closure = new Map();
+  const outputs = new Set();
+  const closureGenerator = new ClosureGenerator();
+
+  // We use copy because some of the plugins don't update bindings and
+  // some even break them
+  const astWorkletCopy = parse('\n(' + fun.toString() + '\n)');
+
+  traverse(astWorkletCopy, {
+    ReferencedIdentifier(path) {
+      const name = path.node.name;
+      if (globals.has(name) || (fun.node.id && fun.node.id.name === name)) {
+        return;
+      }
+
+      const parentNode = path.parent;
+
+      if (
+        parentNode.type === 'MemberExpression' &&
+        (parentNode.property === path.node && !parentNode.computed)
+      ) {
+        return;
+      }
+
+      if (
+        parentNode.type === 'ObjectProperty' &&
+        path.parentPath.parent.type === 'ObjectExpression' &&
+        path.node !== parentNode.value
+      ) {
+        return;
+      }
+
+      let currentScope = path.scope;
+
+      while (currentScope != null) {
+        if (currentScope.bindings[name] != null) {
+          return;
+        }
+        currentScope = currentScope.parent;
+      }
+      closure.set(name, path.node);
+      closureGenerator.addPath(name, path);
+    },
+    AssignmentExpression(path) {
+      // test for <somethin>.value = <something> expressions
+      const left = path.node.left;
+      if (
+        t.isMemberExpression(left) &&
+        t.isIdentifier(left.object) &&
+        t.isIdentifier(left.property, { name: 'value' })
+      ) {
+        outputs.add(left.object.name);
+      }
+    },
+  });
+
+  fun.traverse({
+    DirectiveLiteral(path) {
+      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {
+        path.parentPath.remove();
+      }
+    },
+  });
+  const variables = Array.from(closure.values());
+
+  const privateFunctionId = t.identifier('_f');
+
+  // if we don't clone other modules won't process parts of newFun defined below
+  // this is weird but couldn't find a better way to force transform helper to
+  // process the function
+  const clone = t.cloneNode(fun.node);
+  const funExpression = t.functionExpression(null, clone.params, clone.body);
+
+  const funString = buildWorkletString(t, fun, variables, functionName);
+  const workletHash = hash(funString);
+
+  const newFun = t.functionExpression(
+    fun.id,
+    [],
+    t.blockStatement([
+      t.variableDeclaration('const', [
+        t.variableDeclarator(privateFunctionId, funExpression),
+      ]),
+      t.expressionStatement(
+        t.assignmentExpression(
+          '=',
+          t.memberExpression(
+            privateFunctionId,
+            t.identifier('_closure'),
+            false
+          ),
+          closureGenerator.generate(t, variables, closure.keys())
+        )
+      ),
+      t.expressionStatement(
+        t.assignmentExpression(
+          '=',
+          t.memberExpression(
+            privateFunctionId,
+            t.identifier('asString'),
+            false
+          ),
+          t.stringLiteral(funString)
+        )
+      ),
+      t.expressionStatement(
+        t.assignmentExpression(
+          '=',
+          t.memberExpression(
+            privateFunctionId,
+            t.identifier('__workletHash'),
+            false
+          ),
+          t.numericLiteral(workletHash)
+        )
+      ),
+      t.expressionStatement(
+        t.callExpression(
+          t.memberExpression(
+            t.identifier('global'),
+            t.identifier('__reanimatedWorkletInit'),
+            false
+          ),
+          [privateFunctionId]
+        )
+      ),
+      t.returnStatement(privateFunctionId),
+    ])
+  );
+
+  const replacement = t.callExpression(newFun, []);
+  // we check if function needs to be assigned to variable declaration.
+  // This is needed if function definition directly in a scope. Some other ways
+  // where function definition can be used is for example with variable declaration:
+  // const ggg = function foo() { }
+  // ^ in such a case we don't need to definte variable for the function
+  const needDeclaration =
+    t.isScopable(fun.parent) || t.isExportNamedDeclaration(fun.parent);
+  fun.replaceWith(
+    fun.node.id && needDeclaration
+      ? t.variableDeclaration('const', [
+          t.variableDeclarator(fun.node.id, replacement),
+        ])
+      : replacement
+  );
+}
+
+function processIfWorkletNode(t, path) {
+  const fun = path;
+
+  fun.traverse({
+    DirectiveLiteral(path) {
+      const value = path.node.value;
+      if (value === 'worklet' && path.getFunctionParent() === fun) {
+        // make sure "worklet" is listed among directives for the fun
+        // this is necessary as because of some bug, babel will attempt to
+        // process replaced function if it is nested inside another function
+        const directives = fun.node.body.directives;
+        if (
+          directives &&
+          directives.length > 0 &&
+          directives.some(
+            (directive) =>
+              t.isDirectiveLiteral(directive.value) &&
+              directive.value.value === 'worklet'
+          )
+        ) {
+          processWorkletFunction(t, fun);
+        }
+      }
+    },
+  });
+}
+
+function processWorklets(t, path, processor) {
+  const name = path.node.callee.name;
+  if (
+    objectHooks.has(name) &&
+    path.get('arguments.0').type === 'ObjectExpression'
+  ) {
+    const objectPath = path.get('arguments.0.properties.0');
+    if (!objectPath) {
+      // edge case empty object
+      return;
+    }
+    for (let i = 0; i < objectPath.container.length; i++) {
+      processor(t, objectPath.getSibling(i).get('value'));
+    }
+  } else {
+    const indexes = functionHooks.get(name);
+    if (Array.isArray(indexes)) {
+      indexes.forEach((index) => {
+        processor(t, path.get(`arguments.${index}`));
+      });
+    }
+  }
+}
+
+const PLUGIN_BLACKLIST_NAMES = ['@babel/plugin-transform-object-assign'];
+
+const PLUGIN_BLACKLIST = PLUGIN_BLACKLIST_NAMES.map((pluginName) => {
+  try {
+    const blacklistedPluginObject = require(pluginName);
+    // All Babel polyfills use the declare method that's why we can create them like that.
+    // https://github.com/babel/babel/blob/main/packages/babel-helper-plugin-utils/src/index.js#L1
+    const blacklistedPlugin = blacklistedPluginObject.default({
+      assertVersion: (x) => true,
+    });
+
+    visitors.explode(blacklistedPlugin.visitor);
+    return blacklistedPlugin;
+  } catch (e) {
+    console.warn(`Plugin ${pluginName} couldn't be removed!`);
+  }
+});
+
+// plugin objects are created by babel internals and they don't carry any identifier
+function removePluginsFromBlacklist(plugins) {
+  PLUGIN_BLACKLIST.forEach((blacklistedPlugin) => {
+    if (!blacklistedPlugin) {
+      return;
+    }
+
+    const toRemove = [];
+    for (let i = 0; i < plugins.length; i++) {
+      if (
+        JSON.stringify(Object.keys(plugins[i].visitor)) !==
+        JSON.stringify(Object.keys(blacklistedPlugin.visitor))
+      ) {
+        continue;
+      }
+      let areEqual = true;
+      for (const key of Object.keys(blacklistedPlugin.visitor)) {
+        if (
+          blacklistedPlugin.visitor[key].toString() !==
+          plugins[i].visitor[key].toString()
+        ) {
+          areEqual = false;
+          break;
+        }
+      }
+
+      if (areEqual) {
+        toRemove.push(i);
+      }
+    }
+
+    toRemove.forEach((x) => plugins.splice(x, 1));
+  });
+}
+
+module.exports = function({ types: t }) {
+  return {
+    visitor: {
+      CallExpression: {
+        exit(path) {
+          processWorklets(t, path, processWorkletFunction);
+        },
+      },
+      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': {
+        exit(path) {
+          processIfWorkletNode(t, path);
+        },
+      },
+    },
+    // In this way we can modify babel options
+    // https://github.com/babel/babel/blob/eea156b2cb8deecfcf82d52aa1b71ba4995c7d68/packages/babel-core/src/transformation/normalize-opts.js#L64
+    manipulateOptions(opts, parserOpts) {
+      const plugins = opts.plugins;
+      removePluginsFromBlacklist(plugins);
+    },
+  };
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/react-native-reanimated.d.ts b/node_modules/react-native-reanimated/react-native-reanimated/react-native-reanimated.d.ts
new file mode 100644
index 0000000..3eb8300
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/react-native-reanimated.d.ts
@@ -0,0 +1,722 @@
+// Project: https://github.com/software-mansion/react-native-reanimated
+// TypeScript Version: 2.8
+
+declare module 'react-native-reanimated' {
+  import { ComponentClass, ReactNode, Component, RefObject } from 'react';
+  import {
+    ViewProps,
+    TextProps,
+    ImageProps,
+    ScrollViewProps,
+    StyleProp,
+    ViewStyle,
+    TextStyle,
+    ImageStyle,
+    TransformsStyle,
+    View as ReactNativeView,
+    Text as ReactNativeText,
+    Image as ReactNativeImage,
+    ScrollView as ReactNativeScrollView,
+    NativeScrollEvent,
+    NativeSyntheticEvent,
+  } from 'react-native';
+  import {
+    GestureHandlerGestureEvent,
+    PanGestureHandlerGestureEvent,
+  } from 'react-native-gesture-handler';
+  namespace Animated {
+    type Nullable<T> = T | null | undefined;
+
+    class AnimatedNode<T> {
+      constructor(
+        nodeConfig: object,
+        inputNodes?: ReadonlyArray<AnimatedNode<any>>
+      );
+      isNativelyInitialized(): boolean;
+      /**
+       * ' __value' is not available at runtime on AnimatedNode<T>. It is
+       * necessary to have some discriminating property on a type to know that
+       * an AnimatedNode<number> and AnimatedNode<string> are not compatible types.
+       */
+      ' __value': T;
+    }
+
+    class AnimatedClock extends AnimatedNode<number> {
+      constructor();
+    }
+
+    export enum Extrapolate {
+      EXTEND = 'extend',
+      CLAMP = 'clamp',
+      IDENTITY = 'identity',
+    }
+
+    interface InterpolationConfig {
+      inputRange: ReadonlyArray<Adaptable<number>>;
+      outputRange: ReadonlyArray<Adaptable<number>>;
+      extrapolate?: Extrapolate;
+      extrapolateLeft?: Extrapolate;
+      extrapolateRight?: Extrapolate;
+    }
+    type Value = string | number | boolean;
+    class AnimatedValue<T extends Value> extends AnimatedNode<T> {
+      constructor(value?: T);
+
+      setValue(value: Adaptable<T>): void;
+
+      interpolate(config: InterpolationConfig): AnimatedNode<number>;
+    }
+
+    type RawSharedValue = number | string | boolean | object;
+    type SharedValueType = RawSharedValue | RawSharedValue[];
+    export type SharedValue<T extends SharedValueType> = {
+      value: T;
+    };
+
+    export type Mapping = { [key: string]: Mapping } | Adaptable<any>;
+    export type Adaptable<T> =
+      | T
+      | AnimatedNode<T>
+      | ReadonlyArray<T | AnimatedNode<T> | ReadonlyArray<T | AnimatedNode<T>>>;
+    type BinaryOperator<T = number> = (
+      left: Adaptable<number>,
+      right: Adaptable<number>
+    ) => AnimatedNode<T>;
+    type UnaryOperator = (value: Adaptable<number>) => AnimatedNode<number>;
+    type MultiOperator<T = number> = (
+      a: Adaptable<number>,
+      b: Adaptable<number>,
+      ...others: Adaptable<number>[]
+    ) => AnimatedNode<T>;
+
+    export interface AnimationState {
+      finished: AnimatedValue<number>;
+      position: AnimatedValue<number>;
+      time: AnimatedValue<number>;
+    }
+
+    export interface PhysicsAnimationState extends AnimationState {
+      velocity: AnimatedValue<number>;
+    }
+
+    export type DecayState = PhysicsAnimationState;
+
+    export interface DecayConfig {
+      deceleration: Adaptable<number>;
+    }
+    export interface WithDecayConfig {
+      deceleration?: number;
+      velocity?: number;
+      clamp?: [number, number];
+    }
+    export interface BackwardCompatibleWrapper {
+      start: (callback?: (data: { finished: boolean }) => any) => void;
+      stop: () => void;
+    }
+
+    export interface TimingState extends AnimationState {
+      frameTime: AnimatedValue<number>;
+    }
+    export type EasingNodeFunction = (
+      value: Adaptable<number>
+    ) => AnimatedNode<number>;
+    export type EasingFunction = (value: number) => number;
+    export interface TimingConfig {
+      toValue: Adaptable<number>;
+      duration: Adaptable<number>;
+      easing: EasingNodeFunction;
+    }
+
+    export type SpringState = PhysicsAnimationState;
+
+    export interface SpringConfig {
+      damping: Adaptable<number>;
+      mass: Adaptable<number>;
+      stiffness: Adaptable<number>;
+      overshootClamping: Adaptable<number> | boolean;
+      restSpeedThreshold: Adaptable<number>;
+      restDisplacementThreshold: Adaptable<number>;
+      toValue: Adaptable<number>;
+    }
+
+    export interface WithSpringConfig {
+      damping?: number;
+      mass?: number;
+      stiffness?: number;
+      overshootClamping?: boolean;
+      restSpeedThreshold?: number;
+      restDisplacementThreshold?: number;
+      velocity?: number;
+    }
+
+    interface SpringConfigWithOrigamiTensionAndFriction {
+      tension: Adaptable<number>;
+      mass: Adaptable<number>;
+      friction: Adaptable<number>;
+      overshootClamping: Adaptable<number> | boolean;
+      restSpeedThreshold: Adaptable<number>;
+      restDisplacementThreshold: Adaptable<number>;
+      toValue: Adaptable<number>;
+    }
+
+    interface SpringConfigWithBouncinessAndSpeed {
+      bounciness: Adaptable<number>;
+      mass: Adaptable<number>;
+      speed: Adaptable<number>;
+      overshootClamping: Adaptable<number> | boolean;
+      restSpeedThreshold: Adaptable<number>;
+      restDisplacementThreshold: Adaptable<number>;
+      toValue: Adaptable<number>;
+    }
+
+    type SpringUtils = {
+      makeDefaultConfig: () => SpringConfig;
+      makeConfigFromBouncinessAndSpeed: (
+        prevConfig: SpringConfigWithBouncinessAndSpeed
+      ) => SpringConfig;
+      makeConfigFromOrigamiTensionAndFriction: (
+        prevConfig: SpringConfigWithOrigamiTensionAndFriction
+      ) => SpringConfig;
+    };
+
+    export const SpringUtils: SpringUtils;
+
+    export type TransformStyleTypes = TransformsStyle['transform'] extends (
+      | readonly (infer T)[]
+      | undefined)
+      ? T
+      : never;
+    export type AdaptTransforms<T> = {
+      [P in keyof T]: Adaptable<T[P] extends string ? number | string : T[P]>
+    };
+    export type AnimatedTransform = (AdaptTransforms<TransformStyleTypes>)[];
+
+    export type AnimateStyle<S extends object> = {
+      [K in keyof S]: K extends 'transform'
+        ? AnimatedTransform
+        : (S[K] extends ReadonlyArray<any>
+            ? ReadonlyArray<AnimateStyle<S[K][0]>>
+            : S[K] extends object
+            ? AnimateStyle<S[K]>
+            : // allow `number` where `string` normally is to support colors
+            S[K] extends (string | undefined)
+            ? S[K] | number
+            :
+                | S[K]
+                | AnimatedNode<
+                    // allow `number` where `string` normally is to support colors
+                    S[K] extends (string | undefined) ? S[K] | number : S[K]
+                  >);
+    };
+
+    export type AnimateProps<
+      S extends object,
+      P extends {
+        style?: StyleProp<S>;
+      }
+    > = {
+      [K in keyof P]: K extends 'style'
+        ? StyleProp<AnimateStyle<S>>
+        : P[K] | AnimatedNode<P[K]>;
+    };
+
+    type CodeProps = {
+      exec?: AnimatedNode<number>;
+      children?: () => AnimatedNode<number>;
+      dependencies?: Array<any>;
+    };
+
+    // components
+    export class View extends Component<AnimateProps<ViewStyle, ViewProps>> {
+      getNode(): ReactNativeView;
+    }
+    export class Text extends Component<AnimateProps<TextStyle, TextProps>> {
+      getNode(): ReactNativeText;
+    }
+    export class Image extends Component<AnimateProps<ImageStyle, ImageProps>> {
+      getNode(): ReactNativeImage;
+    }
+    export class ScrollView extends Component<
+      AnimateProps<ViewStyle, ScrollViewProps>
+    > {
+      getNode(): ReactNativeScrollView;
+    }
+    export class Code extends Component<CodeProps> {}
+    export function createAnimatedComponent(component: any): any;
+
+    // classes
+    export {
+      AnimatedClock as Clock,
+      AnimatedNode as Node,
+      AnimatedValue as Value,
+    };
+
+    // base operations
+    export const add: MultiOperator;
+    export const sub: MultiOperator;
+    export const multiply: MultiOperator;
+    export const divide: MultiOperator;
+    export const pow: MultiOperator;
+    export const modulo: MultiOperator;
+    export const sqrt: UnaryOperator;
+    export const log: UnaryOperator;
+    export const sin: UnaryOperator;
+    export const cos: UnaryOperator;
+    export const tan: UnaryOperator;
+    export const acos: UnaryOperator;
+    export const asin: UnaryOperator;
+    export const atan: UnaryOperator;
+    export const exp: UnaryOperator;
+    export const round: UnaryOperator;
+    export const floor: UnaryOperator;
+    export const ceil: UnaryOperator;
+    export const lessThan: BinaryOperator<0 | 1>;
+    export const eq: BinaryOperator<0 | 1>;
+    export const greaterThan: BinaryOperator<0 | 1>;
+    export const lessOrEq: BinaryOperator<0 | 1>;
+    export const greaterOrEq: BinaryOperator<0 | 1>;
+    export const neq: BinaryOperator<0 | 1>;
+    export const and: MultiOperator<0 | 1>;
+    export const or: MultiOperator<0 | 1>;
+    export function proc<T extends (Adaptable<Value> | undefined)[]>(
+      func: (...args: T) => AnimatedNode<number>
+    ): typeof func;
+    export function defined(value: Adaptable<any>): AnimatedNode<0 | 1>;
+    export function not(value: Adaptable<any>): AnimatedNode<0 | 1>;
+    export function set<T extends Value>(
+      valueToBeUpdated: AnimatedValue<T>,
+      sourceNode: Adaptable<T>
+    ): AnimatedNode<T>;
+    export function concat(
+      ...args: Array<Adaptable<string> | Adaptable<number>>
+    ): AnimatedNode<string>;
+    export function cond<T1 extends Value = number, T2 extends Value = number>(
+      conditionNode: Adaptable<number>,
+      ifNode: Adaptable<T1>,
+      elseNode?: Adaptable<T2>
+    ): AnimatedNode<T1 | T2>;
+    export function block<T1 extends Value = number, T2 extends Value = any>(
+      items: ReadonlyArray<Adaptable<T2>>
+    ): AnimatedNode<T1>;
+    export function call<T>(
+      args: ReadonlyArray<T | AnimatedNode<T>>,
+      callback: (args: ReadonlyArray<T>) => void
+    ): AnimatedNode<0>;
+    export function debug<T>(
+      message: string,
+      value: AnimatedNode<T>
+    ): AnimatedNode<T>;
+    export function onChange(
+      value: Adaptable<number>,
+      action: Adaptable<number>
+    ): AnimatedNode<number>;
+    export function startClock(clock: AnimatedClock): AnimatedNode<0>;
+    export function stopClock(clock: AnimatedClock): AnimatedNode<0>;
+    export function clockRunning(clock: AnimatedClock): AnimatedNode<0 | 1>;
+    // the return type for `event` is a lie, but it's the same lie that
+    // react-native makes within Animated
+    type EventArgFunc<T> = (arg: T) => AnimatedNode<number>;
+    type EventMapping<T> = T extends object
+      ? { [K in keyof T]?: EventMapping<T[K]> | EventArgFunc<T[K]> }
+      : Adaptable<T> | EventArgFunc<T>;
+    type EventMappingArray<T> = T extends Array<any>
+      ? { [I in keyof T]: EventMapping<T[I]> }
+      : [EventMapping<T>];
+    export function event<T>(
+      argMapping: T extends never
+        ? ReadonlyArray<Mapping>
+        : Readonly<EventMappingArray<T>>,
+      config?: {}
+    ): (...args: any[]) => void;
+
+    // derived operations
+    export function abs(value: Adaptable<number>): AnimatedNode<number>;
+    export function acc(value: Adaptable<number>): AnimatedNode<number>;
+    export function color(
+      r: Adaptable<number>,
+      g: Adaptable<number>,
+      b: Adaptable<number>,
+      a?: Adaptable<number>
+    ): AnimatedNode<number>;
+    export function diff(value: Adaptable<number>): AnimatedNode<number>;
+    export function diffClamp(
+      value: Adaptable<number>,
+      minVal: Adaptable<number>,
+      maxVal: Adaptable<number>
+    ): AnimatedNode<number>;
+    export function interpolateNode(
+      value: Adaptable<number>,
+      config: InterpolationConfig
+    ): AnimatedNode<number>;
+    export function interpolateColors(
+      animationValue: Adaptable<number>,
+      {
+        inputRange,
+        outputColorRange,
+      }: {
+        inputRange: ReadonlyArray<Adaptable<number>>;
+        outputColorRange: (string | number)[];
+      }
+    ): AnimatedNode<number>;
+    export const max: BinaryOperator;
+    export const min: BinaryOperator;
+
+    // reanimated2 derived operations
+    export function interpolate(
+      x: number,
+      input: Array<number>,
+      output: Array<number>,
+      type?: Extrapolate
+    ): number;
+
+    // animations
+    export function decay(
+      clock: AnimatedClock,
+      state: DecayState,
+      config: DecayConfig
+    ): AnimatedNode<number>;
+    export function timing(
+      clock: AnimatedClock,
+      state: TimingState,
+      config: TimingConfig
+    ): AnimatedNode<number>;
+    export function spring(
+      clock: AnimatedClock,
+      state: SpringState,
+      config: SpringConfig
+    ): AnimatedNode<number>;
+    // backward compatible API
+    export function spring(
+      node: AnimatedNode<number>,
+      config: SpringConfig
+    ): BackwardCompatibleWrapper;
+    export function timing(
+      node: AnimatedNode<number>,
+      config: TimingConfig
+    ): BackwardCompatibleWrapper;
+    export function decay(
+      node: AnimatedNode<number>,
+      config: DecayConfig
+    ): BackwardCompatibleWrapper;
+
+    // reanimated2 animations
+    export interface WithTimingConfig {
+      duration?: number;
+      easing?: EasingFunction;
+    }
+    export function withTiming(
+      toValue: number,
+      userConfig?: WithTimingConfig,
+      callback?: (isFinished: boolean) => void
+    ): number;
+    export function withSpring(
+      toValue: number,
+      userConfig?: WithSpringConfig,
+      callback?: (isFinished: boolean) => void
+    ): number;
+    export function withDecay(
+      userConfig: WithDecayConfig,
+      callback?: (isFinished: boolean) => void
+    ): number;
+    export function cancelAnimation<T extends SharedValue<SharedValueType>>(
+      sharedValue: T
+    ): void;
+    export function delay(delayMS: number, delayedAnimation: number): number;
+    export function repeat(
+      animation: number,
+      numberOfReps?: number,
+      reverse?: boolean
+    ): number;
+    export function sequence(...animations: [number, ...number[]]): number;
+
+    // hooks
+    export function useCode(
+      exec: () =>
+        | Nullable<AnimatedNode<number>[] | AnimatedNode<number>>
+        | boolean,
+      deps: Array<any>
+    ): void;
+    export function useValue<T extends Value>(
+      initialValue: T
+    ): AnimatedValue<T>;
+
+    // reanimated2 functions
+    export function runOnUI<A extends any[], R>(
+      fn: (...args: A) => R
+    ): (...args: Parameters<typeof fn>) => void;
+    export function processColor(color: number | string): number;
+
+    type DependencyList = ReadonlyArray<any>;
+
+    // reanimated2 hooks
+    export function useSharedValue<T>(
+      initialValue: T
+    ): T extends SharedValueType ? SharedValue<T> : never;
+
+    export function useDerivedValue<T extends SharedValueType>(
+      processor: () => T,
+      deps?: DependencyList
+    ): SharedValue<T>;
+
+    export function useAnimatedStyle<
+      T extends StyleProp<AnimateStyle<ViewStyle | ImageStyle | TextStyle>>
+    >(updater: () => T, deps?: DependencyList): T;
+    export function useAnimatedProps<T extends {}>(
+      updater: () => T,
+      deps?: DependencyList
+    ): T;
+    export function useAnimatedGestureHandler<
+      T extends GestureHandlerGestureEvent = PanGestureHandlerGestureEvent,
+      TContext extends Context = {}
+    >(
+      handlers: GestureHandlers<T['nativeEvent'], TContext>,
+      deps?: DependencyList
+    ): OnGestureEvent<T>;
+    export function useAnimatedScrollHandler<TContext extends Context = {}>(
+      handler: ScrollHandler<TContext>,
+      deps?: DependencyList
+    ): OnScroll;
+    export function useAnimatedScrollHandler<TContext extends Context = {}>(
+      handlers: ScrollHandlers<TContext>,
+      deps?: DependencyList
+    ): OnScroll;
+
+    export function useAnimatedRef<T extends Component>(): RefObject<T>;
+    export function measure<T extends Component>(
+      ref: RefObject<T>
+    ): {
+      width: number;
+      height: number;
+      x: number;
+      y: number;
+      pageX: number;
+      pageY: number;
+    };
+
+    export function scrollTo(
+      ref: RefObject<ReactNativeScrollView | ScrollView>,
+      x: number,
+      y: number,
+      animated: boolean
+    ): void;
+
+    // gesture-handler
+    type OnGestureEvent<T extends GestureHandlerGestureEvent> = (
+      event: T
+    ) => void;
+
+    type Context = Record<string, unknown>;
+
+    type Handler<T, TContext extends Context> = (
+      event: T,
+      context: TContext
+    ) => void;
+
+    export interface GestureHandlers<T, TContext extends Context> {
+      onStart?: Handler<T, TContext>;
+      onActive?: Handler<T, TContext>;
+      onEnd?: Handler<T, TContext>;
+      onFail?: Handler<T, TContext>;
+      onCancel?: Handler<T, TContext>;
+      onFinish?: (
+        event: T,
+        context: TContext,
+        isCanceledOrFailed: boolean
+      ) => void;
+    }
+
+    // scroll view
+    type OnScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
+
+    type ScrollHandler<TContext extends Context> = (
+      event: NativeScrollEvent,
+      context: TContext
+    ) => void;
+
+    export interface ScrollHandlers<TContext extends Context> {
+      onScroll?: ScrollHandler<TContext>;
+      onBeginDrag?: ScrollHandler<TContext>;
+      onEndDrag?: ScrollHandler<TContext>;
+      onMomentumBegin?: ScrollHandler<TContext>;
+      onMomentumEnd?: ScrollHandler<TContext>;
+    }
+
+    // configuration
+    export function addWhitelistedNativeProps(props: {
+      [key: string]: true;
+    }): void;
+    export function addWhitelistedUIProps(props: { [key: string]: true }): void;
+  }
+
+  export default Animated;
+
+  interface EasingNodeStatic {
+    linear: Animated.EasingNodeFunction;
+    ease: Animated.EasingNodeFunction;
+    quad: Animated.EasingNodeFunction;
+    cubic: Animated.EasingNodeFunction;
+    poly(n: Animated.Adaptable<number>): Animated.EasingNodeFunction;
+    sin: Animated.EasingNodeFunction;
+    circle: Animated.EasingNodeFunction;
+    exp: Animated.EasingNodeFunction;
+    elastic(
+      bounciness?: Animated.Adaptable<number>
+    ): Animated.EasingNodeFunction;
+    back(s?: Animated.Adaptable<number>): Animated.EasingNodeFunction;
+    bounce: Animated.EasingNodeFunction;
+    bezier(
+      x1: number,
+      y1: number,
+      x2: number,
+      y2: number
+    ): Animated.EasingNodeFunction;
+    in(easing: Animated.EasingNodeFunction): Animated.EasingNodeFunction;
+    out(easing: Animated.EasingNodeFunction): Animated.EasingNodeFunction;
+    inOut(easing: Animated.EasingNodeFunction): Animated.EasingNodeFunction;
+  }
+
+  export const EasingNode: EasingNodeStatic;
+
+  interface EasingStatic {
+    linear: Animated.EasingFunction;
+    ease: Animated.EasingFunction;
+    quad: Animated.EasingFunction;
+    cubic: Animated.EasingFunction;
+    poly(n: number): Animated.EasingFunction;
+    sin: Animated.EasingFunction;
+    circle: Animated.EasingFunction;
+    exp: Animated.EasingFunction;
+    elastic(bounciness?: number): Animated.EasingFunction;
+    back(s?: number): Animated.EasingFunction;
+    bounce: Animated.EasingFunction;
+    bezier(
+      x1: number,
+      y1: number,
+      x2: number,
+      y2: number
+    ): Animated.EasingFunction;
+    in(easing: Animated.EasingFunction): Animated.EasingFunction;
+    out(easing: Animated.EasingFunction): Animated.EasingFunction;
+    inOut(easing: Animated.EasingFunction): Animated.EasingFunction;
+  }
+
+  export const Easing: EasingStatic;
+
+  export interface TransitioningViewProps extends ViewProps {
+    transition: ReactNode;
+  }
+
+  export class TransitioningView extends Component<TransitioningViewProps> {
+    animateNextTransition(): void;
+  }
+
+  export class Transitioning extends Component {
+    static View: typeof TransitioningView;
+  }
+
+  export interface TransitionProps {
+    delayMs?: number;
+    durationMs?: number;
+    interpolation?: 'linear' | 'easeIn' | 'easeOut' | 'easeInOut';
+    propagation?: 'top' | 'bottom' | 'left' | 'right';
+  }
+
+  export interface TransitionInOutProps extends TransitionProps {
+    type?:
+      | 'fade'
+      | 'scale'
+      | 'slide-top'
+      | 'slide-bottom'
+      | 'slide-right'
+      | 'slide-left';
+  }
+
+  export class Transition extends Component {
+    static In: ComponentClass<TransitionInOutProps>;
+    static Out: ComponentClass<TransitionInOutProps>;
+    static Change: ComponentClass<TransitionProps>;
+    static Together: ComponentClass<{}>;
+    static Sequence: ComponentClass<{}>;
+  }
+
+  export class Clock extends Animated.Clock {}
+  export class Value<
+    T extends string | number | boolean
+  > extends Animated.Value<T> {}
+  export class Node<T> extends Animated.Node<T> {}
+  export const add: typeof Animated.add;
+  export const sub: typeof Animated.sub;
+  export const multiply: typeof Animated.multiply;
+  export const divide: typeof Animated.divide;
+  export const pow: typeof Animated.pow;
+  export const modulo: typeof Animated.modulo;
+  export const sqrt: typeof Animated.sqrt;
+  export const log: typeof Animated.log;
+  export const sin: typeof Animated.sin;
+  export const cos: typeof Animated.cos;
+  export const exp: typeof Animated.exp;
+  export const round: typeof Animated.round;
+  export const lessThan: typeof Animated.lessThan;
+  export const eq: typeof Animated.eq;
+  export const greaterThan: typeof Animated.greaterThan;
+  export const lessOrEq: typeof Animated.lessOrEq;
+  export const greaterOrEq: typeof Animated.greaterOrEq;
+  export const neq: typeof Animated.neq;
+  export const and: typeof Animated.and;
+  export const or: typeof Animated.or;
+  export const defined: typeof Animated.defined;
+  export const not: typeof Animated.not;
+  export const tan: typeof Animated.tan;
+  export const acos: typeof Animated.acos;
+  export const asin: typeof Animated.asin;
+  export const atan: typeof Animated.atan;
+  export const proc: typeof Animated.proc;
+  export const block: typeof Animated.block;
+  export const concat: typeof Animated.concat;
+  export const event: typeof Animated.event;
+  export const call: typeof Animated.call;
+  export const debug: typeof Animated.debug;
+  export const clockRunning: typeof Animated.clockRunning;
+  export const stopClock: typeof Animated.stopClock;
+  export const startClock: typeof Animated.startClock;
+  export const set: typeof Animated.set;
+  export const cond: typeof Animated.cond;
+  export const abs: typeof Animated.abs;
+  export const acc: typeof Animated.acc;
+  export const color: typeof Animated.color;
+  export const interpolateColors: typeof Animated.interpolateColors;
+  export const diff: typeof Animated.diff;
+  export const diffClamp: typeof Animated.diffClamp;
+  export const interpolateNode: typeof Animated.interpolateNode;
+  export const Extrapolate: typeof Animated.Extrapolate;
+  export const max: typeof Animated.max;
+  export const min: typeof Animated.min;
+  export const onChange: typeof Animated.onChange;
+  export const floor: typeof Animated.floor;
+  export const ceil: typeof Animated.ceil;
+  export const useCode: typeof Animated.useCode;
+  export const decay: typeof Animated.decay;
+  export const timing: typeof Animated.timing;
+  export const spring: typeof Animated.spring;
+  export const SpringUtils: typeof Animated.SpringUtils;
+  export const runOnUI: typeof Animated.runOnUI;
+  export const processColor: typeof Animated.processColor;
+  export const useValue: typeof Animated.useValue;
+  export const useSharedValue: typeof Animated.useSharedValue;
+  export const useAnimatedStyle: typeof Animated.useAnimatedStyle;
+  export const useAnimatedProps: typeof Animated.useAnimatedProps;
+  export const useDerivedValue: typeof Animated.useDerivedValue;
+  export const useAnimatedGestureHandler: typeof Animated.useAnimatedGestureHandler;
+  export const useAnimatedScrollHandler: typeof Animated.useAnimatedScrollHandler;
+  export const useAnimatedRef: typeof Animated.useAnimatedRef;
+  export const measure: typeof Animated.measure;
+  export const scrollTo: typeof Animated.scrollTo;
+  export const withTiming: typeof Animated.withTiming;
+  export const withSpring: typeof Animated.withSpring;
+  export const withDecay: typeof Animated.withDecay;
+  export const cancelAnimation: typeof Animated.cancelAnimation;
+  export const delay: typeof Animated.delay;
+  export const repeat: typeof Animated.repeat;
+  export const sequence: typeof Animated.sequence;
+  export const interpolate: typeof Animated.interpolate;
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/Animated.js b/node_modules/react-native-reanimated/react-native-reanimated/src/Animated.js
new file mode 100644
index 0000000..d7813c3
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/Animated.js
@@ -0,0 +1,99 @@
+import { Image, ScrollView, Text, View } from 'react-native';
+import EasingNode from './Easing';
+import AnimatedClock from './core/AnimatedClock';
+import AnimatedValue from './core/AnimatedValue';
+import AnimatedNode from './core/AnimatedNode';
+import AnimatedCode from './core/AnimatedCode';
+import * as base from './base';
+import * as derived from './derived';
+import createAnimatedComponent from './createAnimatedComponent';
+import decay from './animations/decay';
+import timing from './animations/timing';
+import spring from './animations/spring';
+import Animation from './animations/Animation';
+import {
+  addWhitelistedNativeProps,
+  addWhitelistedUIProps,
+} from './ConfigHelper';
+import backwardCompatibleAnimWrapper from './animations/backwardCompatibleAnimWrapper';
+import {
+  Transition,
+  Transitioning,
+  createTransitioningComponent,
+} from './Transitioning';
+import SpringUtils from './animations/SpringUtils';
+import useValue from './useValue';
+import * as reanimated2 from './reanimated2';
+
+const decayWrapper = backwardCompatibleAnimWrapper(
+  decay,
+  Animation.decayDefaultState
+);
+const timingWrapper = backwardCompatibleAnimWrapper(
+  timing,
+  Animation.timingDefaultState
+);
+const springWrapper = backwardCompatibleAnimWrapper(
+  spring,
+  Animation.springDefaultState
+);
+const Animated = {
+  // components
+  View: createAnimatedComponent(View),
+  Text: createAnimatedComponent(Text),
+  Image: createAnimatedComponent(Image),
+  ScrollView: createAnimatedComponent(ScrollView),
+  Code: AnimatedCode,
+  createAnimatedComponent,
+
+  // classes
+  Clock: AnimatedClock,
+  Value: AnimatedValue,
+  Node: AnimatedNode,
+
+  // operations
+  ...base,
+  ...derived,
+
+  // animations
+  decay: decayWrapper,
+  timing: timingWrapper,
+  spring: springWrapper,
+  SpringUtils,
+
+  // configuration
+  addWhitelistedNativeProps,
+  addWhitelistedUIProps,
+
+  // hooks
+  useValue,
+
+  // reanimated2
+  ...reanimated2,
+};
+
+export default Animated;
+
+// operations
+export * from './base';
+export * from './derived';
+
+export * from './reanimated2';
+
+export {
+  EasingNode as Easing,
+  Transitioning,
+  Transition,
+  createTransitioningComponent,
+  // classes
+  AnimatedClock as Clock,
+  AnimatedValue as Value,
+  AnimatedNode as Node,
+  // animations
+  decayWrapper as decay,
+  timingWrapper as timing,
+  springWrapper as spring,
+  SpringUtils,
+  // hooks
+  useValue,
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/Animated.test.js b/node_modules/react-native-reanimated/react-native-reanimated/src/Animated.test.js
new file mode 100644
index 0000000..fde5228
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/Animated.test.js
@@ -0,0 +1,207 @@
+import Animated, { Easing } from './Animated';
+import ReanimatedModule from './ReanimatedModule';
+import React from 'react';
+
+import renderer from 'react-test-renderer';
+
+jest.mock('./ReanimatedEventEmitter');
+jest.mock('./ReanimatedModule');
+jest.mock('./reanimated2/NativeReanimated.js');
+jest.mock('./derived/evaluateOnce');
+jest.mock('./core/AnimatedProps');
+
+const { Value, timing, spring, decay } = Animated;
+describe('Reanimated backward compatible API', () => {
+  beforeEach(() => {
+    let numberOfNodes = 0;
+    ReanimatedModule.createNode = () => numberOfNodes++;
+    ReanimatedModule.dropNode = () => numberOfNodes--;
+    ReanimatedModule.getNumberOfNodes = () => numberOfNodes;
+  });
+
+  const checkIfNodesGetDetachedCorrectly = animation => {
+    class TestComponent extends React.Component {
+      constructor(props) {
+        super(props);
+        this.transX = new Value(0);
+        this.anim = animation.node(this.transX, animation.config);
+      }
+
+      start(method) {
+        this.anim.start(method);
+      }
+
+      stop(res) {
+        this.anim.__stopImmediately_testOnly(res);
+      }
+
+      render() {
+        return (
+          <Animated.View style={{ transform: [{ translateX: this.transX }] }} />
+        );
+      }
+    }
+    const ref = React.createRef();
+    let result;
+    const resMethod = ({ finished }) => (result = finished);
+    const initial = ReanimatedModule.getNumberOfNodes();
+    const wrapper = renderer.create(<TestComponent ref={ref} />);
+    const before = ReanimatedModule.getNumberOfNodes();
+    ref.current.start(resMethod);
+    const during = ReanimatedModule.getNumberOfNodes();
+    ref.current.stop(true);
+    const after = ReanimatedModule.getNumberOfNodes();
+    wrapper.unmount();
+    const final = ReanimatedModule.getNumberOfNodes();
+
+    return (
+      result &&
+      initial === final &&
+      after === before &&
+      during > after &&
+      initial === 0 &&
+      before === 4
+    );
+  };
+
+  it('fails if timing does not attach nodes correctly', () => {
+    expect(
+      checkIfNodesGetDetachedCorrectly({
+        node: timing,
+        name: 'timing',
+        config: {
+          duration: 5000,
+          toValue: 120,
+          easing: Easing.inOut(Easing.ease),
+        },
+      })
+    ).toBeTruthy();
+  });
+
+  it('fails if decay does not attach nodes correctly', () => {
+    expect(
+      checkIfNodesGetDetachedCorrectly({
+        node: decay,
+        name: 'decay',
+        config: {
+          deceleration: 0.997,
+        },
+      })
+    ).toBeTruthy();
+  });
+
+  it('fails if spring does not attach nodes correctly', () => {
+    expect(
+      checkIfNodesGetDetachedCorrectly({
+        node: spring,
+        name: 'spring',
+        config: {
+          toValue: 0,
+          damping: 7,
+          mass: 1,
+          stiffness: 121.6,
+          overshootClamping: false,
+          restSpeedThreshold: 0.001,
+          restDisplacementThreshold: 0.001,
+        },
+      })
+    ).toBeTruthy();
+  });
+
+  it('fails if animation related nodes are still attached after detaching of value with two animations triggered', () => {
+    const { timing, Value } = Animated;
+    class TestComponent extends React.Component {
+      constructor(props) {
+        super(props);
+        this.transX = new Value(0);
+        const config = {
+          duration: 5000,
+          toValue: -120,
+          easing: Easing.inOut(Easing.ease),
+        };
+        this.anim = timing(this.transX, config);
+        this.anim2 = timing(this.transX, config);
+      }
+
+      start1(method) {
+        this.anim.start(method);
+      }
+
+      start2(method) {
+        this.anim2.start(method);
+      }
+
+      render() {
+        return (
+          <Animated.View style={{ transform: [{ translateX: this.transX }] }} />
+        );
+      }
+    }
+    const ref = React.createRef();
+    const wrapper = renderer.create(<TestComponent ref={ref} />);
+    let result = true;
+    const resMethod = ({ finished }) => (result = finished);
+    ref.current.start1(resMethod);
+    ref.current.start2(resMethod);
+    expect(result).toBeFalsy();
+    result = true;
+    const numberOfNodesBeforeUnmounting = ReanimatedModule.getNumberOfNodes();
+    wrapper.unmount();
+    expect(result).toBeFalsy();
+    const numberOfNodesAfterUnmounting = ReanimatedModule.getNumberOfNodes();
+    const pass =
+      numberOfNodesAfterUnmounting === 0 && numberOfNodesBeforeUnmounting > 0;
+    expect(pass).toBeTruthy();
+  });
+
+  it('fails if animation related nodes are detached if there are two children and only one detach', () => {
+    const { timing, Value } = Animated;
+    const transX = new Value(0);
+    const wrapper1 = renderer.create(
+      <Animated.View
+        style={{
+          transform: [{ translateX: transX }],
+        }}
+      />
+    );
+    const wrapper2 = renderer.create(
+      <Animated.View
+        style={{
+          transform: [{ translateX: transX }],
+        }}
+      />
+    );
+    const config = {
+      duration: 5000,
+      toValue: -120,
+      easing: Easing.inOut(Easing.ease),
+    };
+    const anim = timing(transX, config);
+    anim.start();
+    const numberOfNodesBeforeDetach = ReanimatedModule.getNumberOfNodes();
+    wrapper1.unmount();
+    const numberOfNodesAfterDetach = ReanimatedModule.getNumberOfNodes();
+    const result =
+      // 3 means AnimatedProps, AnimatedStyle and AnimatedTransform
+      // which are nodes not related to animation and has to be detached
+      numberOfNodesBeforeDetach - 3 === numberOfNodesAfterDetach &&
+      numberOfNodesAfterDetach > 3;
+    expect(result).toBeTruthy();
+    wrapper2.unmount();
+    expect(ReanimatedModule.getNumberOfNodes() === 0).toBeTruthy();
+  });
+
+  it('fails if animation attaches some node without view related', () => {
+    const { timing, Value } = Animated;
+    const transX = new Value(0);
+
+    const config = {
+      duration: 5000,
+      toValue: -120,
+      easing: Easing.inOut(Easing.ease),
+    };
+    const anim = timing(transX, config);
+    anim.start();
+    expect(ReanimatedModule.getNumberOfNodes()).toBe(0);
+  });
+});
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/ConfigHelper.js b/node_modules/react-native-reanimated/react-native-reanimated/src/ConfigHelper.js
new file mode 100644
index 0000000..5e1770a
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/ConfigHelper.js
@@ -0,0 +1,126 @@
+import ReanimatedModule from './ReanimatedModule';
+
+/**
+ * Styles allowed to be direcly updated in UI thread
+ */
+let UI_THREAD_PROPS_WHITELIST = {
+  opacity: true,
+  transform: true,
+  /* colors */
+  backgroundColor: true,
+  borderRightColor: true,
+  borderBottomColor: true,
+  borderColor: true,
+  borderEndColor: true,
+  borderLeftColor: true,
+  borderStartColor: true,
+  borderTopColor: true,
+  /* ios styles */
+  shadowOpacity: true,
+  shadowRadius: true,
+  /* legacy android transform properties */
+  scaleX: true,
+  scaleY: true,
+  translateX: true,
+  translateY: true,
+};
+
+/**
+ * Whitelist of view props that can be updated in native thread via UIManagerModule
+ */
+let NATIVE_THREAD_PROPS_WHITELIST = {
+  borderBottomWidth: true,
+  borderEndWidth: true,
+  borderLeftWidth: true,
+  borderRightWidth: true,
+  borderStartWidth: true,
+  borderTopWidth: true,
+  borderWidth: true,
+  bottom: true,
+  flex: true,
+  flexGrow: true,
+  flexShrink: true,
+  height: true,
+  left: true,
+  margin: true,
+  marginBottom: true,
+  marginEnd: true,
+  marginHorizontal: true,
+  marginLeft: true,
+  marginRight: true,
+  marginStart: true,
+  marginTop: true,
+  marginVertical: true,
+  maxHeight: true,
+  maxWidth: true,
+  minHeight: true,
+  minWidth: true,
+  padding: true,
+  paddingBottom: true,
+  paddingEnd: true,
+  paddingHorizontal: true,
+  paddingLeft: true,
+  paddingRight: true,
+  paddingStart: true,
+  paddingTop: true,
+  paddingVertical: true,
+  right: true,
+  start: true,
+  top: true,
+  width: true,
+  zIndex: true,
+  borderBottomEndRadius: true,
+  borderBottomLeftRadius: true,
+  borderBottomRightRadius: true,
+  borderBottomStartRadius: true,
+  borderRadius: true,
+  borderTopEndRadius: true,
+  borderTopLeftRadius: true,
+  borderTopRightRadius: true,
+  borderTopStartRadius: true,
+  opacity: true,
+  elevation: true,
+  fontSize: true,
+  lineHeight: true,
+  textShadowRadius: true,
+  letterSpacing: true,
+  /* strings */
+  display: true,
+  backfaceVisibility: true,
+  overflow: true,
+  resizeMode: true,
+  fontStyle: true,
+  fontWeight: true,
+  textAlign: true,
+  textDecorationLine: true,
+  fontFamily: true,
+  textAlignVertical: true,
+  fontVariant: true,
+  textDecorationStyle: true,
+  textTransform: true,
+  writingDirection: true,
+  /* text color */
+  color: true,
+};
+
+function configureProps() {
+  ReanimatedModule.configureProps(
+    Object.keys(NATIVE_THREAD_PROPS_WHITELIST),
+    Object.keys(UI_THREAD_PROPS_WHITELIST)
+  );
+}
+
+export function addWhitelistedNativeProps(props) {
+  NATIVE_THREAD_PROPS_WHITELIST = {
+    ...NATIVE_THREAD_PROPS_WHITELIST,
+    ...props,
+  };
+  configureProps();
+}
+
+export function addWhitelistedUIProps(props) {
+  UI_THREAD_PROPS_WHITELIST = { ...UI_THREAD_PROPS_WHITELIST, ...props };
+  configureProps();
+}
+
+configureProps();
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/Easing.js b/node_modules/react-native-reanimated/react-native-reanimated/src/Easing.js
new file mode 100644
index 0000000..cd08e06
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/Easing.js
@@ -0,0 +1,231 @@
+import {
+  cond,
+  lessThan,
+  multiply,
+  pow,
+  cos,
+  sqrt,
+  sub,
+  add,
+  divide,
+} from './base';
+import AnimatedBezier from './core/AnimatedBezier';
+
+/**
+ * The `Easing` module implements common easing functions. This module is used
+ * by [Animate.timing()](docs/animate.html#timing) to convey physically
+ * believable motion in animations.
+ *
+ * You can find a visualization of some common easing functions at
+ * http://easings.net/
+ *
+ * ### Predefined animations
+ *
+ * The `Easing` module provides several predefined animations through the
+ * following methods:
+ *
+ * - [`back`](docs/easing.html#back) provides a simple animation where the
+ *   object goes slightly back before moving forward
+ * - [`bounce`](docs/easing.html#bounce) provides a bouncing animation
+ * - [`ease`](docs/easing.html#ease) provides a simple inertial animation
+ * - [`elastic`](docs/easing.html#elastic) provides a simple spring interaction
+ *
+ * ### Standard functions
+ *
+ * Three standard easing functions are provided:
+ *
+ * - [`linear`](docs/easing.html#linear)
+ * - [`quad`](docs/easing.html#quad)
+ * - [`cubic`](docs/easing.html#cubic)
+ *
+ * The [`poly`](docs/easing.html#poly) function can be used to implement
+ * quartic, quintic, and other higher power functions.
+ *
+ * ### Additional functions
+ *
+ * Additional mathematical functions are provided by the following methods:
+ *
+ * - [`bezier`](docs/easing.html#bezier) provides a cubic bezier curve
+ * - [`circle`](docs/easing.html#circle) provides a circular function
+ * - [`sin`](docs/easing.html#sin) provides a sinusoidal function
+ * - [`exp`](docs/easing.html#exp) provides an exponential function
+ *
+ * The following helpers are used to modify other easing functions.
+ *
+ * - [`in`](docs/easing.html#in) runs an easing function forwards
+ * - [`inOut`](docs/easing.html#inout) makes any easing function symmetrical
+ * - [`out`](docs/easing.html#out) runs an easing function backwards
+ */
+export default class Easing {
+  /**
+   * A linear function, `f(t) = t`. Position correlates to elapsed time one to
+   * one.
+   *
+   * http://cubic-bezier.com/#0,0,1,1
+   */
+  static linear(t) {
+    return t;
+  }
+
+  /**
+   * A simple inertial interaction, similar to an object slowly accelerating to
+   * speed.
+   *
+   * http://cubic-bezier.com/#.42,0,1,1
+   */
+  static ease(t) {
+    return new AnimatedBezier(t, 0.42, 0, 1, 1);
+  }
+
+  /**
+   * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
+   * time.
+   *
+   * http://easings.net/#easeInQuad
+   */
+  static quad(t) {
+    return multiply(t, t);
+  }
+
+  /**
+   * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
+   * time.
+   *
+   * http://easings.net/#easeInCubic
+   */
+  static cubic(t) {
+    return multiply(t, t, t);
+  }
+
+  /**
+   * A power function. Position is equal to the Nth power of elapsed time.
+   *
+   * n = 4: http://easings.net/#easeInQuart
+   * n = 5: http://easings.net/#easeInQuint
+   */
+  static poly(n) {
+    return t => pow(t, n);
+  }
+
+  /**
+   * A sinusoidal function.
+   *
+   * http://easings.net/#easeInSine
+   */
+  static sin(t) {
+    return sub(1, cos(multiply(t, Math.PI, 0.5)));
+  }
+
+  /**
+   * A circular function.
+   *
+   * http://easings.net/#easeInCirc
+   */
+  static circle(t) {
+    return sub(1, sqrt(sub(1, multiply(t, t))));
+  }
+
+  /**
+   * An exponential function.
+   *
+   * http://easings.net/#easeInExpo
+   */
+  static exp(t) {
+    return pow(2, multiply(10, sub(t, 1)));
+  }
+
+  /**
+   * A simple elastic interaction, similar to a spring oscillating back and
+   * forth.
+   *
+   * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
+   * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
+   * times.
+   *
+   * http://easings.net/#easeInElastic
+   */
+  static elastic(bounciness = 1) {
+    const p = bounciness * Math.PI;
+    return t =>
+      sub(
+        1,
+        multiply(pow(cos(multiply(t, Math.PI, 0.5)), 3), cos(multiply(t, p)))
+      );
+  }
+
+  /**
+   * Use with `Animated.parallel()` to create a simple effect where the object
+   * animates back slightly as the animation starts.
+   *
+   * Wolfram Plot:
+   *
+   * - http://tiny.cc/back_default (s = 1.70158, default)
+   */
+  static back(s) {
+    if (s === undefined) {
+      s = 1.70158;
+    }
+    return t => multiply(t, t, sub(multiply(add(s, 1), t), s));
+  }
+
+  /**
+   * Provides a simple bouncing effect.
+   *
+   * http://easings.net/#easeInBounce
+   */
+  static bounce(t) {
+    const sq = v => multiply(7.5625, v, v);
+    return cond(
+      lessThan(t, 1 / 2.75),
+      sq(t),
+      cond(
+        lessThan(t, 2 / 2.75),
+        add(0.75, sq(sub(t, 1.5 / 2.75))),
+        cond(
+          lessThan(t, 2.5 / 2.76),
+          add(0.9375, sq(sub(t, 2.25 / 2.75))),
+          add(0.984375, sq(sub(t, 2.625 / 2.75)))
+        )
+      )
+    );
+  }
+
+  /**
+   * Provides a cubic bezier curve, equivalent to CSS Transitions'
+   * `transition-timing-function`.
+   *
+   * A useful tool to visualize cubic bezier curves can be found at
+   * http://cubic-bezier.com/
+   */
+  static bezier(x1, y1, x2, y2) {
+    return t => new AnimatedBezier(t, x1, y1, x2, y2);
+  }
+
+  /**
+   * Runs an easing function forwards.
+   */
+  static in(easing) {
+    return easing;
+  }
+
+  /**
+   * Runs an easing function backwards.
+   */
+  static out(easing) {
+    return t => sub(1, easing(sub(1, t)));
+  }
+
+  /**
+   * Makes any easing function symmetrical. The easing function will run
+   * forwards for half of the duration, then backwards for the rest of the
+   * duration.
+   */
+  static inOut(easing) {
+    return t =>
+      cond(
+        lessThan(t, 0.5),
+        divide(easing(multiply(t, 2)), 2),
+        sub(1, divide(easing(multiply(sub(1, t), 2)), 2))
+      );
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedEventEmitter.js b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedEventEmitter.js
new file mode 100644
index 0000000..9c22579
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedEventEmitter.js
@@ -0,0 +1,4 @@
+import ReanimatedModule from './ReanimatedModule';
+import { NativeEventEmitter } from 'react-native';
+
+export default new NativeEventEmitter(ReanimatedModule);
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.js b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.js
new file mode 100644
index 0000000..79b3340
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.js
@@ -0,0 +1,3 @@
+import ReanimatedModuleCompat from './ReanimatedModuleCompat';
+
+export default ReanimatedModuleCompat;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.macos.js b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.macos.js
new file mode 100644
index 0000000..79b3340
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.macos.js
@@ -0,0 +1,3 @@
+import ReanimatedModuleCompat from './ReanimatedModuleCompat';
+
+export default ReanimatedModuleCompat;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.native.js b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.native.js
new file mode 100644
index 0000000..c4e2b6b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.native.js
@@ -0,0 +1,5 @@
+import { NativeModules } from 'react-native';
+
+const { ReanimatedModule } = NativeModules;
+
+export default ReanimatedModule;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.windows.js b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.windows.js
new file mode 100644
index 0000000..79b3340
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModule.windows.js
@@ -0,0 +1,3 @@
+import ReanimatedModuleCompat from './ReanimatedModuleCompat';
+
+export default ReanimatedModuleCompat;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModuleCompat.js b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModuleCompat.js
new file mode 100644
index 0000000..4fa302f
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/ReanimatedModuleCompat.js
@@ -0,0 +1,26 @@
+export default {
+  async disconnectNodeFromView() {
+    // noop
+  },
+  async attachEvent(viewTag, eventName, nodeID) {
+    // noop
+  },
+  async detachEvent(viewTag, eventName, nodeID) {
+    // noop
+  },
+  async createNode(nodeID, config) {
+    // noop
+  },
+  async dropNode(nodeID) {
+    // noop
+  },
+  async configureProps() {
+    // noop
+  },
+  async disconnectNodes() {
+    // noop
+  },
+  async animateNextTransition() {
+    console.warn('Reanimated: animateNextTransition is unimplemented on current platform');
+  },
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/SpringConfig.js b/node_modules/react-native-reanimated/react-native-reanimated/src/SpringConfig.js
new file mode 100644
index 0000000..04d931b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/SpringConfig.js
@@ -0,0 +1,79 @@
+function stiffnessFromOrigamiValue(oValue) {
+  return (oValue - 30) * 3.62 + 194;
+}
+
+function dampingFromOrigamiValue(oValue) {
+  return (oValue - 8) * 3 + 25;
+}
+
+function fromOrigamiTensionAndFriction(tension, friction) {
+  return {
+    stiffness: stiffnessFromOrigamiValue(tension),
+    damping: dampingFromOrigamiValue(friction),
+  };
+}
+
+function fromBouncinessAndSpeed(bounciness, speed) {
+  function normalize(value, startValue, endValue) {
+    return (value - startValue) / (endValue - startValue);
+  }
+
+  function projectNormal(n, start, end) {
+    return start + n * (end - start);
+  }
+
+  function linearInterpolation(t, start, end) {
+    return t * end + (1 - t) * start;
+  }
+
+  function quadraticOutInterpolation(t, start, end) {
+    return linearInterpolation(2 * t - t * t, start, end);
+  }
+
+  function b3Friction1(x) {
+    return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
+  }
+
+  function b3Friction2(x) {
+    return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
+  }
+
+  function b3Friction3(x) {
+    return (
+      0.00000045 * Math.pow(x, 3) -
+      0.000332 * Math.pow(x, 2) +
+      0.1078 * x +
+      5.84
+    );
+  }
+
+  function b3Nobounce(tension) {
+    if (tension <= 18) {
+      return b3Friction1(tension);
+    } else if (tension > 18 && tension <= 44) {
+      return b3Friction2(tension);
+    } else {
+      return b3Friction3(tension);
+    }
+  }
+
+  var b = normalize(bounciness / 1.7, 0, 20);
+  b = projectNormal(b, 0, 0.8);
+  var s = normalize(speed / 1.7, 0, 20);
+  var bouncyTension = projectNormal(s, 0.5, 200);
+  var bouncyFriction = quadraticOutInterpolation(
+    b,
+    b3Nobounce(bouncyTension),
+    0.01
+  );
+
+  return {
+    stiffness: stiffnessFromOrigamiValue(bouncyTension),
+    damping: dampingFromOrigamiValue(bouncyFriction),
+  };
+}
+
+module.exports = {
+  fromOrigamiTensionAndFriction,
+  fromBouncinessAndSpeed,
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/Transitioning.js b/node_modules/react-native-reanimated/react-native-reanimated/src/Transitioning.js
new file mode 100644
index 0000000..2d32c1b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/Transitioning.js
@@ -0,0 +1,158 @@
+import React from 'react';
+import { View, findNodeHandle } from 'react-native';
+import ReanimatedModule from './ReanimatedModule';
+
+const TransitioningContext = React.createContext();
+
+function configFromProps(type, props) {
+  const config = { type };
+  if ('durationMs' in props) {
+    config.durationMs = props.durationMs;
+  }
+  if ('interpolation' in props) {
+    config.interpolation = props.interpolation;
+  }
+  if ('type' in props) {
+    config.animation = props.type;
+  }
+  if ('delayMs' in props) {
+    config.delayMs = props.delayMs;
+  }
+  if ('propagation' in props) {
+    config.propagation = props.propagation;
+  }
+  return config;
+}
+
+/**
+ * The below wrapper is used to support legacy context API with Context.Consumer
+ * render prop. We need it as we want to access `context` from within
+ * `componentDidMount` callback. If we decided to drop support for older
+ * react native we could rewrite it using hooks or `static contextType` API.
+ */
+function wrapTransitioningContext(Comp) {
+  return props => {
+    return (
+      <TransitioningContext.Consumer>
+        {context => <Comp context={context} {...props} />}
+      </TransitioningContext.Consumer>
+    );
+  };
+}
+
+class In extends React.Component {
+  componentDidMount() {
+    this.props.context.push(configFromProps('in', this.props));
+  }
+
+  render() {
+    return this.props.children || null;
+  }
+}
+
+class Change extends React.Component {
+  componentDidMount() {
+    this.props.context.push(configFromProps('change', this.props));
+  }
+
+  render() {
+    return this.props.children || null;
+  }
+}
+
+class Out extends React.Component {
+  componentDidMount() {
+    this.props.context.push(configFromProps('out', this.props));
+  }
+
+  render() {
+    return this.props.children || null;
+  }
+}
+
+class Together extends React.Component {
+  transitions = [];
+  componentDidMount() {
+    const config = configFromProps('group', this.props);
+    config.transitions = this.transitions;
+    this.props.context.push(config);
+  }
+
+  render() {
+    return (
+      <TransitioningContext.Provider value={this.transitions}>
+        {this.props.children}
+      </TransitioningContext.Provider>
+    );
+  }
+}
+
+class Sequence extends React.Component {
+  transitions = [];
+  componentDidMount() {
+    const config = configFromProps('group', this.props);
+    config.sequence = true;
+    config.transitions = this.transitions;
+    this.props.context.push(config);
+  }
+
+  render() {
+    return (
+      <TransitioningContext.Provider value={this.transitions}>
+        {this.props.children}
+      </TransitioningContext.Provider>
+    );
+  }
+}
+
+function createTransitioningComponent(Component) {
+  class Wrapped extends React.Component {
+    propTypes = Component.propTypes;
+    transitions = [];
+    viewRef = React.createRef();
+
+    componentDidMount() {
+      if (this.props.animateMount) {
+        this.animateNextTransition();
+      }
+    }
+
+    setNativeProps(props) {
+      this.viewRef.current.setNativeProps(props);
+    }
+
+    animateNextTransition() {
+      const viewTag = findNodeHandle(this.viewRef.current);
+      ReanimatedModule.animateNextTransition(viewTag, {
+        transitions: this.transitions,
+      });
+    }
+
+    render() {
+      const { transition, ...rest } = this.props;
+      return (
+        <React.Fragment>
+          <TransitioningContext.Provider value={this.transitions}>
+            {transition}
+          </TransitioningContext.Provider>
+          <Component {...rest} ref={this.viewRef} collapsable={false} />
+        </React.Fragment>
+      );
+    }
+  }
+  return Wrapped;
+}
+
+const Transitioning = {
+  View: createTransitioningComponent(View),
+};
+
+const Transition = {
+  Sequence: wrapTransitioningContext(Sequence),
+  Together: wrapTransitioningContext(Together),
+  In: wrapTransitioningContext(In),
+  Out: wrapTransitioningContext(Out),
+  Change: wrapTransitioningContext(Change),
+};
+
+export { Transitioning, Transition, createTransitioningComponent };
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/__mocks__/ReanimatedEventEmitter.js b/node_modules/react-native-reanimated/react-native-reanimated/src/__mocks__/ReanimatedEventEmitter.js
new file mode 100644
index 0000000..ecd631d
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/__mocks__/ReanimatedEventEmitter.js
@@ -0,0 +1,4 @@
+export default {
+  addListener: () => {},
+  removeAllListeners: () => {},
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/__mocks__/ReanimatedModule.native.js b/node_modules/react-native-reanimated/react-native-reanimated/src/__mocks__/ReanimatedModule.native.js
new file mode 100644
index 0000000..f097293
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/__mocks__/ReanimatedModule.native.js
@@ -0,0 +1,7 @@
+export default {
+  configureProps: () => {},
+  connectNodes: () => {},
+  getValue: () => 0,
+  disconnectNodes: () => {},
+  createNode: () => {},
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/animations/Animation.js b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/Animation.js
new file mode 100644
index 0000000..4aebf5a
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/Animation.js
@@ -0,0 +1,32 @@
+import AnimatedValue from '../core/InternalAnimatedValue';
+
+class Animation {
+  static springDefaultState() {
+    return {
+      position: new AnimatedValue(0),
+      finished: new AnimatedValue(0),
+      velocity: new AnimatedValue(0),
+      time: new AnimatedValue(0),
+    };
+  }
+
+  static decayDefaultState() {
+    return {
+      position: new AnimatedValue(0),
+      finished: new AnimatedValue(0),
+      velocity: new AnimatedValue(0),
+      time: new AnimatedValue(0),
+    };
+  }
+
+  static timingDefaultState() {
+    return {
+      position: new AnimatedValue(0),
+      finished: new AnimatedValue(0),
+      time: new AnimatedValue(0),
+      frameTime: new AnimatedValue(0),
+    };
+  }
+}
+
+export default Animation;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/animations/SpringUtils.js b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/SpringUtils.js
new file mode 100644
index 0000000..3f86c3a
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/SpringUtils.js
@@ -0,0 +1,199 @@
+import {
+  cond,
+  sub,
+  divide,
+  multiply,
+  add,
+  pow,
+  lessOrEq,
+  and,
+  greaterThan,
+} from './../base';
+import AnimatedValue from './../core/InternalAnimatedValue';
+
+function stiffnessFromOrigamiValue(oValue) {
+  return (oValue - 30) * 3.62 + 194;
+}
+
+function dampingFromOrigamiValue(oValue) {
+  return (oValue - 8) * 3 + 25;
+}
+
+function stiffnessFromOrigamiNode(oValue) {
+  return add(multiply(sub(oValue, 30), 3.62), 194);
+}
+
+function dampingFromOrigamiNode(oValue) {
+  return add(multiply(sub(oValue, 8), 3), 25);
+}
+
+function makeConfigFromOrigamiTensionAndFriction(prevConfig) {
+  const { tension, friction, ...rest } = prevConfig;
+  return {
+    ...rest,
+    stiffness:
+      typeof tension === 'number'
+        ? stiffnessFromOrigamiValue(tension)
+        : stiffnessFromOrigamiNode(tension),
+    damping:
+      typeof friction === 'number'
+        ? dampingFromOrigamiValue(friction)
+        : dampingFromOrigamiNode(friction),
+  };
+}
+
+function makeConfigFromBouncinessAndSpeed(prevConfig) {
+  const { bounciness, speed, ...rest } = prevConfig;
+  if (typeof bounciness === 'number' && typeof speed === 'number') {
+    return fromBouncinessAndSpeedNumbers(bounciness, speed, rest);
+  }
+  return fromBouncinessAndSpeedNodes(bounciness, speed, rest);
+}
+
+function fromBouncinessAndSpeedNodes(bounciness, speed, rest) {
+  function normalize(value, startValue, endValue) {
+    return divide(sub(value, startValue), sub(endValue, startValue));
+  }
+
+  function projectNormal(n, start, end) {
+    return add(start, multiply(n, sub(end, start)));
+  }
+
+  function linearInterpolation(t, start, end) {
+    return add(multiply(t, end), multiply(sub(1, t), start));
+  }
+
+  function quadraticOutInterpolation(t, start, end) {
+    return linearInterpolation(sub(multiply(2, t), multiply(t, t)), start, end);
+  }
+
+  function b3Friction1(x) {
+    return add(
+      sub(multiply(0.0007, pow(x, 3)), multiply(0.031, pow(x, 2))),
+      multiply(0.64, x),
+      1.28
+    );
+  }
+
+  function b3Friction2(x) {
+    return add(
+      sub(multiply(0.000044, pow(x, 3)), multiply(0.006, pow(x, 2))),
+      multiply(0.36, x),
+      2
+    );
+  }
+
+  function b3Friction3(x) {
+    return add(
+      sub(multiply(0.00000045, pow(x, 3)), multiply(0.000332, pow(x, 2))),
+      multiply(0.1078, x),
+      5.84
+    );
+  }
+
+  function b3Nobounce(tension) {
+    return cond(
+      lessOrEq(tension, 18),
+      b3Friction1(tension),
+      cond(
+        and(greaterThan(tension, 18), lessOrEq(tension, 44)),
+        b3Friction2(tension),
+        b3Friction3(tension)
+      )
+    );
+  }
+
+  let b = normalize(divide(bounciness, 1.7), 0, 20);
+  b = projectNormal(b, 0, 0.8);
+  const s = normalize(divide(speed, 1.7), 0, 20);
+  const bouncyTension = projectNormal(s, 0.5, 200);
+  const bouncyFriction = quadraticOutInterpolation(
+    b,
+    b3Nobounce(bouncyTension),
+    0.01
+  );
+  return {
+    ...rest,
+    stiffness: stiffnessFromOrigamiNode(bouncyTension),
+    damping: dampingFromOrigamiNode(bouncyFriction),
+  };
+}
+
+function fromBouncinessAndSpeedNumbers(bounciness, speed, rest) {
+  function normalize(value, startValue, endValue) {
+    return (value - startValue) / (endValue - startValue);
+  }
+
+  function projectNormal(n, start, end) {
+    return start + n * (end - start);
+  }
+
+  function linearInterpolation(t, start, end) {
+    return t * end + (1 - t) * start;
+  }
+
+  function quadraticOutInterpolation(t, start, end) {
+    return linearInterpolation(2 * t - t * t, start, end);
+  }
+
+  function b3Friction1(x) {
+    return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
+  }
+
+  function b3Friction2(x) {
+    return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
+  }
+
+  function b3Friction3(x) {
+    return (
+      0.00000045 * Math.pow(x, 3) -
+      0.000332 * Math.pow(x, 2) +
+      0.1078 * x +
+      5.84
+    );
+  }
+
+  function b3Nobounce(tension) {
+    if (tension <= 18) {
+      return b3Friction1(tension);
+    } else if (tension > 18 && tension <= 44) {
+      return b3Friction2(tension);
+    } else {
+      return b3Friction3(tension);
+    }
+  }
+
+  let b = normalize(bounciness / 1.7, 0, 20);
+  b = projectNormal(b, 0, 0.8);
+  const s = normalize(speed / 1.7, 0, 20);
+  const bouncyTension = projectNormal(s, 0.5, 200);
+  const bouncyFriction = quadraticOutInterpolation(
+    b,
+    b3Nobounce(bouncyTension),
+    0.01
+  );
+
+  return {
+    ...rest,
+    stiffness: stiffnessFromOrigamiValue(bouncyTension),
+    damping: dampingFromOrigamiValue(bouncyFriction),
+  };
+}
+
+function makeDefaultConfig() {
+  return {
+    stiffness: new AnimatedValue(100),
+    mass: new AnimatedValue(1),
+    damping: new AnimatedValue(10),
+    overshootClamping: false,
+    restSpeedThreshold: 0.001,
+    restDisplacementThreshold: 0.001,
+    toValue: new AnimatedValue(0),
+  };
+}
+
+export default {
+  makeDefaultConfig,
+  makeConfigFromBouncinessAndSpeed,
+  makeConfigFromOrigamiTensionAndFriction,
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/animations/backwardCompatibleAnimWrapper.js b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/backwardCompatibleAnimWrapper.js
new file mode 100644
index 0000000..f783ff3
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/backwardCompatibleAnimWrapper.js
@@ -0,0 +1,117 @@
+import {
+  always,
+  block,
+  call,
+  clockRunning,
+  cond,
+  set,
+  startClock,
+  stopClock,
+} from '../base';
+import Clock from '../core/AnimatedClock';
+import { evaluateOnce } from '../derived/evaluateOnce';
+
+function createOldAnimationObject(node, animationStateDefaults, value, config) {
+  const newClock = new Clock();
+  const currentState = animationStateDefaults();
+  let alwaysNode;
+  let isStarted = false;
+  let isDone = false;
+  let wasStopped = false;
+  let animationCallback;
+  const animation = {
+    start: currentAnimationCallback => {
+      animationCallback = currentAnimationCallback;
+      if (isStarted) {
+        animationCallback && animationCallback({ finished: false });
+        return;
+      }
+      if (isDone) {
+        console.warn('Animation has been finished before');
+        // inconsistent with React Native
+        return;
+      }
+
+      if (!value.isNativelyInitialized()) {
+        return;
+      }
+
+      isStarted = true;
+      evaluateOnce(
+        set(currentState.position, value),
+        currentState.position,
+        () => {
+          alwaysNode = always(
+            set(
+              value,
+              block([
+                cond(clockRunning(newClock), 0, startClock(newClock)),
+                node(newClock, currentState, config),
+                cond(currentState.finished, [
+                  call([], () => {
+                    isStarted = false;
+                    if (!wasStopped) {
+                      isDone = true;
+                    }
+                    value.__detachAnimation(animation);
+                    isDone = true;
+                    if (!wasStopped) {
+                      wasStopped = false;
+                    }
+                  }),
+                  stopClock(newClock),
+                ]),
+                currentState.position,
+              ])
+            )
+          );
+          value.__attachAnimation(animation);
+          alwaysNode.__addChild(value);
+        }
+      );
+    },
+    __detach: () => {
+      animationCallback && animationCallback({ finished: isDone });
+      animationCallback = null;
+      value.__initialized && alwaysNode.__removeChild(value);
+    },
+    stop: () => {
+      if (isDone) {
+        console.warn(
+          'Calling stop has no effect as the animation has already completed'
+        );
+        return;
+      }
+      if (!isStarted) {
+        console.warn(
+          "Calling stop has no effect as the animation hasn't been started"
+        );
+        return;
+      }
+      wasStopped = true;
+      evaluateOnce(set(currentState.finished, 1), currentState.finished);
+    },
+    __stopImmediately_testOnly: result => {
+      animation.stop();
+      isDone = result;
+      value.__detachAnimation(animation);
+    },
+  };
+  return animation;
+}
+
+/**
+ * Depending on the arguments list we either return animation node or return an
+ * animation object that is compatible with the original Animated API
+ */
+export default function backwardsCompatibleAnimWrapper(
+  node,
+  animationStateDefaults
+) {
+  return (clock, state, config) => {
+    if (config !== undefined) {
+      return node(clock, state, config);
+    }
+    return createOldAnimationObject(node, animationStateDefaults, clock, state);
+  };
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/animations/decay.js b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/decay.js
new file mode 100644
index 0000000..c46823e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/decay.js
@@ -0,0 +1,52 @@
+import {
+  cond,
+  sub,
+  pow,
+  divide,
+  multiply,
+  add,
+  block,
+  set,
+  lessThan,
+  proc,
+  abs,
+} from '../base';
+
+const VELOCITY_EPS = 5;
+
+function decay(clock, state, config) {
+  const lastTime = cond(state.time, state.time, clock);
+  const deltaTime = sub(clock, lastTime);
+
+  // v0 = v / 1000
+  // v = v0 * powf(deceleration, dt);
+  // v = v * 1000;
+
+  // x0 = x;
+  // x = x0 + v0 * deceleration * (1 - powf(deceleration, dt)) / (1 - deceleration)
+  const kv = pow(config.deceleration, deltaTime);
+  const kx = divide(
+    multiply(config.deceleration, sub(1, kv)),
+    sub(1, config.deceleration)
+  );
+  const v0 = divide(state.velocity, 1000);
+  const v = multiply(v0, kv, 1000);
+  const x = add(state.position, multiply(v0, kx));
+  return block([
+    set(state.position, x),
+    set(state.velocity, v),
+    set(state.time, clock),
+    cond(lessThan(abs(v), VELOCITY_EPS), set(state.finished, 1)),
+  ]);
+}
+
+const procDecay = proc(
+  (clock, time, velocity, position, finished, deceleration) =>
+    decay(clock, { time, velocity, position, finished }, { deceleration })
+);
+
+export default (
+  clock,
+  { time, velocity, position, finished },
+  { deceleration }
+) => procDecay(clock, time, velocity, position, finished, deceleration);
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/animations/spring.js b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/spring.js
new file mode 100644
index 0000000..f4e92f7
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/spring.js
@@ -0,0 +1,205 @@
+import {
+  cond,
+  sub,
+  divide,
+  multiply,
+  sqrt,
+  add,
+  block,
+  set,
+  exp,
+  sin,
+  cos,
+  eq,
+  or,
+  neq,
+  and,
+  lessThan,
+  greaterThan,
+  proc,
+  min,
+  abs,
+} from '../base';
+import AnimatedValue from '../core/InternalAnimatedValue';
+
+const MAX_STEPS_MS = 64;
+
+function spring(clock, state, config) {
+  const lastTime = cond(state.time, state.time, clock);
+
+  const deltaTime = min(sub(clock, lastTime), MAX_STEPS_MS);
+
+  const c = config.damping;
+  const m = config.mass;
+  const k = config.stiffness;
+
+  const v0 = multiply(-1, state.velocity);
+  const x0 = sub(config.toValue, state.position);
+
+  const zeta = divide(c, multiply(2, sqrt(multiply(k, m)))); // damping ratio
+  const omega0 = sqrt(divide(k, m)); // undamped angular frequency of the oscillator (rad/ms)
+  const omega1 = multiply(omega0, sqrt(sub(1, multiply(zeta, zeta)))); // exponential decay
+
+  const t = divide(deltaTime, 1000); // in seconds
+
+  const sin1 = sin(multiply(omega1, t));
+  const cos1 = cos(multiply(omega1, t));
+
+  // under damped
+  const underDampedEnvelope = exp(multiply(-1, zeta, omega0, t));
+  const underDampedFrag1 = multiply(
+    underDampedEnvelope,
+    add(
+      multiply(sin1, divide(add(v0, multiply(zeta, omega0, x0)), omega1)),
+      multiply(x0, cos1)
+    )
+  );
+  const underDampedPosition = sub(config.toValue, underDampedFrag1);
+  // This looks crazy -- it's actually just the derivative of the oscillation function
+  const underDampedVelocity = sub(
+    multiply(zeta, omega0, underDampedFrag1),
+    multiply(
+      underDampedEnvelope,
+      sub(
+        multiply(cos1, add(v0, multiply(zeta, omega0, x0))),
+        multiply(omega1, x0, sin1)
+      )
+    )
+  );
+
+  // critically damped
+  const criticallyDampedEnvelope = exp(multiply(-1, omega0, t));
+  const criticallyDampedPosition = sub(
+    config.toValue,
+    multiply(
+      criticallyDampedEnvelope,
+      add(x0, multiply(add(v0, multiply(omega0, x0)), t))
+    )
+  );
+  const criticallyDampedVelocity = multiply(
+    criticallyDampedEnvelope,
+    add(
+      multiply(v0, sub(multiply(t, omega0), 1)),
+      multiply(t, x0, omega0, omega0)
+    )
+  );
+
+  // conditions for stopping the spring animations
+  const prevPosition = state.prevPosition
+    ? state.prevPosition
+    : new AnimatedValue(0);
+
+  const isOvershooting = cond(
+    and(config.overshootClamping, neq(config.stiffness, 0)),
+    cond(
+      lessThan(prevPosition, config.toValue),
+      greaterThan(state.position, config.toValue),
+      lessThan(state.position, config.toValue)
+    )
+  );
+  const isVelocity = lessThan(abs(state.velocity), config.restSpeedThreshold);
+  const isDisplacement = or(
+    eq(config.stiffness, 0),
+    lessThan(
+      abs(sub(config.toValue, state.position)),
+      config.restDisplacementThreshold
+    )
+  );
+
+  return block([
+    set(prevPosition, state.position),
+    cond(
+      lessThan(zeta, 1),
+      [
+        set(state.position, underDampedPosition),
+        set(state.velocity, underDampedVelocity),
+      ],
+      [
+        set(state.position, criticallyDampedPosition),
+        set(state.velocity, criticallyDampedVelocity),
+      ]
+    ),
+    set(state.time, clock),
+    cond(or(isOvershooting, and(isVelocity, isDisplacement)), [
+      cond(neq(config.stiffness, 0), [
+        set(state.velocity, 0),
+        set(state.position, config.toValue),
+      ]),
+      set(state.finished, 1),
+    ]),
+  ]);
+}
+
+const procSpring = proc(
+  (
+    finished,
+    velocity,
+    position,
+    time,
+    prevPosition,
+    toValue,
+    damping,
+    mass,
+    stiffness,
+    overshootClamping,
+    restSpeedThreshold,
+    restDisplacementThreshold,
+    clock
+  ) =>
+    spring(
+      clock,
+      {
+        finished,
+        velocity,
+        position,
+        time,
+        // @ts-ignore
+        prevPosition,
+      },
+      {
+        toValue,
+        damping,
+        mass,
+        stiffness,
+        overshootClamping,
+        restDisplacementThreshold,
+        restSpeedThreshold,
+      }
+    )
+);
+
+export default (
+  clock,
+  {
+    finished,
+    velocity,
+    position,
+    time,
+    // @ts-ignore
+    prevPosition,
+  },
+  {
+    toValue,
+    damping,
+    mass,
+    stiffness,
+    overshootClamping,
+    restDisplacementThreshold,
+    restSpeedThreshold,
+  }
+) =>
+  procSpring(
+    finished,
+    velocity,
+    position,
+    time,
+    prevPosition,
+    toValue,
+    damping,
+    mass,
+    stiffness,
+    overshootClamping,
+    restSpeedThreshold,
+    restDisplacementThreshold,
+    clock
+  );
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/animations/timing.js b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/timing.js
new file mode 100644
index 0000000..4118604
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/animations/timing.js
@@ -0,0 +1,74 @@
+import {
+  cond,
+  sub,
+  divide,
+  multiply,
+  add,
+  block,
+  set,
+  greaterOrEq,
+  proc,
+} from '../base';
+
+const internalTiming = proc(function(
+  clock,
+  time,
+  frameTime,
+  position,
+  finished,
+  toValue,
+  duration,
+  nextProgress,
+  progress,
+  newFrameTime
+) {
+  const state = {
+    time,
+    finished,
+    frameTime,
+    position,
+  };
+
+  const config = {
+    duration,
+    toValue,
+  };
+
+  const distanceLeft = sub(config.toValue, state.position);
+  const fullDistance = divide(distanceLeft, sub(1, progress));
+  const startPosition = sub(config.toValue, fullDistance);
+  const nextPosition = add(startPosition, multiply(fullDistance, nextProgress));
+
+  return block([
+    cond(
+      greaterOrEq(newFrameTime, config.duration),
+      [set(state.position, config.toValue), set(state.finished, 1)],
+      set(state.position, nextPosition)
+    ),
+    set(state.frameTime, newFrameTime),
+    set(state.time, clock),
+  ]);
+});
+
+export default function(clock, state, config) {
+  if (config.duration === 0) {
+    // when duration is zero we end the timing immediately
+    return block([set(state.position, config.toValue), set(state.finished, 1)]);
+  }
+  const lastTime = cond(state.time, state.time, clock);
+  const newFrameTime = add(state.frameTime, sub(clock, lastTime));
+  const nextProgress = config.easing(divide(newFrameTime, config.duration));
+  const progress = config.easing(divide(state.frameTime, config.duration));
+  return internalTiming(
+    clock,
+    state.time,
+    state.frameTime,
+    state.position,
+    state.finished,
+    config.toValue,
+    config.duration,
+    nextProgress,
+    progress,
+    newFrameTime
+  );
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/base.js b/node_modules/react-native-reanimated/react-native-reanimated/src/base.js
new file mode 100644
index 0000000..87acf4e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/base.js
@@ -0,0 +1,17 @@
+export { createAnimatedCond as cond } from './core/AnimatedCond';
+export { createAnimatedSet as set } from './core/AnimatedSet';
+export {
+  createAnimatedStartClock as startClock,
+} from './core/AnimatedStartClock';
+export { createAnimatedStopClock as stopClock } from './core/AnimatedStopClock';
+export {
+  createAnimatedClockTest as clockRunning,
+} from './core/AnimatedClockTest';
+export { createAnimatedDebug as debug } from './core/AnimatedDebug';
+export { createAnimatedCall as call } from './core/AnimatedCall';
+export { createAnimatedEvent as event } from './core/AnimatedEvent';
+export { createAnimatedAlways as always } from './core/AnimatedAlways';
+export { createAnimatedConcat as concat } from './core/AnimatedConcat';
+export { createAnimatedBlock as block, adapt } from './core/AnimatedBlock';
+export { createAnimatedFunction as proc } from './core/AnimatedFunction';
+export * from './operators';
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedAlways.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedAlways.js
new file mode 100644
index 0000000..1195da5
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedAlways.js
@@ -0,0 +1,33 @@
+import AnimatedNode from './AnimatedNode';
+import invariant from 'fbjs/lib/invariant';
+import { val } from '../val';
+
+class AnimatedAlways extends AnimatedNode {
+  _what;
+
+  constructor(what) {
+    invariant(
+      what instanceof AnimatedNode,
+      `Reanimated: Animated.always node argument should be of type AnimatedNode but got ${what}`
+    );
+    super({ type: 'always', what }, [what]);
+    this._what = what;
+  }
+
+  toString() {
+    return `AnimatedAlways, id: ${this.__nodeID}`;
+  }
+
+  update() {
+    this.__getValue();
+  }
+
+  __onEvaluate() {
+    val(this._what);
+    return 0;
+  }
+}
+
+export function createAnimatedAlways(item) {
+  return new AnimatedAlways(item);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedBezier.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedBezier.js
new file mode 100644
index 0000000..bcddf9c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedBezier.js
@@ -0,0 +1,152 @@
+import { val } from '../val';
+import AnimatedNode from './AnimatedNode';
+import invariant from 'fbjs/lib/invariant';
+
+// These values are established by empiricism with tests (tradeoff: performance VS precision)
+var NEWTON_ITERATIONS = 4;
+var NEWTON_MIN_SLOPE = 0.001;
+var SUBDIVISION_PRECISION = 0.0000001;
+var SUBDIVISION_MAX_ITERATIONS = 10;
+
+var kSplineTableSize = 11;
+var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
+
+var float32ArraySupported = typeof Float32Array === 'function';
+
+function A(aA1, aA2) {
+  return 1.0 - 3.0 * aA2 + 3.0 * aA1;
+}
+function B(aA1, aA2) {
+  return 3.0 * aA2 - 6.0 * aA1;
+}
+function C(aA1) {
+  return 3.0 * aA1;
+}
+
+// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
+function calcBezier(aT, aA1, aA2) {
+  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
+}
+
+// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
+function getSlope(aT, aA1, aA2) {
+  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
+}
+
+function binarySubdivide(aX, aA, aB, mX1, mX2) {
+  var currentX = 0;
+  var currentT = 0;
+  var i = 0;
+  do {
+    currentT = aA + (aB - aA) / 2.0;
+    currentX = calcBezier(currentT, mX1, mX2) - aX;
+    if (currentX > 0.0) {
+      aB = currentT;
+    } else {
+      aA = currentT;
+    }
+  } while (
+    Math.abs(currentX) > SUBDIVISION_PRECISION &&
+    ++i < SUBDIVISION_MAX_ITERATIONS
+  );
+  return currentT;
+}
+
+function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
+  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
+    var currentSlope = getSlope(aGuessT, mX1, mX2);
+    if (currentSlope === 0.0) {
+      return aGuessT;
+    }
+    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
+    aGuessT -= currentX / currentSlope;
+  }
+  return aGuessT;
+}
+
+function bezier(mX1, mY1, mX2, mY2) {
+  // Precompute samples table
+  var sampleValues = float32ArraySupported
+    ? new Float32Array(kSplineTableSize)
+    : new Array(kSplineTableSize);
+  if (mX1 !== mY1 || mX2 !== mY2) {
+    for (var i = 0; i < kSplineTableSize; ++i) {
+      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
+    }
+  }
+
+  function getTForX(aX) {
+    var intervalStart = 0.0;
+    var currentSample = 1;
+    var lastSample = kSplineTableSize - 1;
+
+    for (
+      ;
+      currentSample !== lastSample && sampleValues[currentSample] <= aX;
+      ++currentSample
+    ) {
+      intervalStart += kSampleStepSize;
+    }
+    --currentSample;
+
+    // Interpolate to provide an initial guess for t
+    var dist =
+      (aX - sampleValues[currentSample]) /
+      (sampleValues[currentSample + 1] - sampleValues[currentSample]);
+    var guessForT = intervalStart + dist * kSampleStepSize;
+
+    var initialSlope = getSlope(guessForT, mX1, mX2);
+    if (initialSlope >= NEWTON_MIN_SLOPE) {
+      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
+    } else if (initialSlope === 0.0) {
+      return guessForT;
+    } else {
+      return binarySubdivide(
+        aX,
+        intervalStart,
+        intervalStart + kSampleStepSize,
+        mX1,
+        mX2
+      );
+    }
+  }
+
+  return function BezierEasing(x) {
+    if (mX1 === mY1 && mX2 === mY2) {
+      return x; // linear
+    }
+    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
+    if (x === 0) {
+      return 0;
+    }
+    if (x === 1) {
+      return 1;
+    }
+    return calcBezier(getTForX(x), mY1, mY2);
+  };
+}
+
+export default class AnimatedBezier extends AnimatedNode {
+  _value;
+  _bezier;
+
+  constructor(value, mX1, mY1, mX2, mY2) {
+    invariant(
+      value instanceof AnimatedNode,
+      `Reanimated: Bezier node argument should be of type AnimatedNode but got ${value}`
+    );
+    super({ type: 'bezier', mX1, mY1, mX2, mY2, input: value }, [
+      value,
+    ]);
+    this._value = value;
+    this._bezier = bezier(mX1, mY1, mX2, mY2);
+  }
+
+  toString() {
+    return `AnimatedBezier, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    return this._bezier(val(this._value));
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedBlock.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedBlock.js
new file mode 100644
index 0000000..bb5e192
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedBlock.js
@@ -0,0 +1,52 @@
+import invariant from 'fbjs/lib/invariant';
+import { val } from '../val';
+import AnimatedNode from './AnimatedNode';
+import InternalAnimatedValue from './InternalAnimatedValue';
+
+class AnimatedBlock extends AnimatedNode {
+  _array;
+
+  constructor(array) {
+    invariant(
+      array.every(el => el instanceof AnimatedNode),
+      `Reanimated: Animated.block node argument should be an array with elements of type AnimatedNode. One or more of them are not AnimatedNodes`
+    );
+    super({ type: 'block', block: array }, array);
+    this._array = array;
+  }
+
+  toString() {
+    return `AnimatedBlock, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    let result;
+    this._array.forEach(node => {
+      result = val(node);
+    });
+    return result;
+  }
+}
+
+export function createAnimatedBlock(items) {
+  return adapt(items);
+}
+
+function nodify(v) {
+  if (typeof v === 'object' && v?.__isProxy) {
+    if (!v.__val) {
+      v.__val = new InternalAnimatedValue(0);
+    }
+    return v.__val;
+  }
+  // TODO: cache some typical static values (e.g. 0, 1, -1)
+  return v instanceof AnimatedNode
+    ? v
+    : InternalAnimatedValue.valueForConstant(v);
+}
+
+export function adapt(v) {
+  return Array.isArray(v)
+    ? new AnimatedBlock(v.map(node => adapt(node)))
+    : nodify(v);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCall.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCall.js
new file mode 100644
index 0000000..f1fbdac
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCall.js
@@ -0,0 +1,55 @@
+import invariant from 'fbjs/lib/invariant';
+import ReanimatedEventEmitter from '../ReanimatedEventEmitter';
+import { val } from '../val';
+import AnimatedNode from './AnimatedNode';
+
+const NODE_MAPPING = new Map();
+
+function listener(data) {
+  const node = NODE_MAPPING.get(data.id);
+  node && node._callback(data.args);
+}
+
+class AnimatedCall extends AnimatedNode {
+  _callback;
+  _args;
+
+  constructor(args, jsFunction) {
+    invariant(
+      args.every(el => el instanceof AnimatedNode),
+      `Reanimated: Animated.call node args should be an array with elements of type AnimatedNode. One or more of them are not AnimatedNodes`
+    );
+    super({ type: 'call', input: args }, args);
+    this._callback = jsFunction;
+    this._args = args;
+  }
+
+  toString() {
+    return `AnimatedCall, id: ${this.__nodeID}`;
+  }
+
+  __attach() {
+    super.__attach();
+    NODE_MAPPING.set(this.__nodeID, this);
+    if (NODE_MAPPING.size === 1) {
+      ReanimatedEventEmitter.addListener('onReanimatedCall', listener);
+    }
+  }
+
+  __detach() {
+    NODE_MAPPING.delete(this.__nodeID);
+    if (NODE_MAPPING.size === 0) {
+      ReanimatedEventEmitter.removeAllListeners('onReanimatedCall');
+    }
+    super.__detach();
+  }
+
+  __onEvaluate() {
+    this._callback(this._args.map(val));
+    return 0;
+  }
+}
+
+export function createAnimatedCall(args, func) {
+  return new AnimatedCall(args, func);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCallFunc.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCallFunc.js
new file mode 100644
index 0000000..f00858c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCallFunc.js
@@ -0,0 +1,68 @@
+import AnimatedNode, { getCallID, setCallID } from './AnimatedNode';
+import { adapt } from './AnimatedBlock';
+import { val } from '../val';
+import invariant from 'fbjs/lib/invariant';
+
+class AnimatedCallFunc extends AnimatedNode {
+  _previousCallID;
+  _what;
+  _args;
+  _params;
+  constructor(what, args, params) {
+    invariant(
+      what instanceof AnimatedNode,
+      `Reanimated: AnimatedCallFunc 'what' argument should be of type AnimatedNode but got ${what}`
+    );
+    invariant(
+      args.every(el => el instanceof AnimatedNode),
+      `Reanimated: every AnimatedCallFunc 'args' argument should be of type AnimatedNode but got ${args}`
+    );
+    invariant(
+      params.every(el => el instanceof AnimatedNode),
+      `Reanimated: every AnimatedCallFunc 'params' argument should be of type AnimatedNode but got ${params}`
+    );
+    super(
+      {
+        type: 'callfunc',
+        what,
+        args,
+        params,
+      },
+      [...args]
+    );
+    this._what = what;
+    this._args = args;
+    this._params = params;
+  }
+
+  toString() {
+    return `AnimatedCallFunc, id: ${this.__nodeID}`;
+  }
+
+  beginContext() {
+    this._previousCallID = getCallID();
+    setCallID(getCallID() + '/' + this.__nodeID);
+
+    this._params.forEach((param, index) => {
+      param.beginContext(this._args[index], this._previousCallID);
+    });
+  }
+
+  endContext() {
+    this._params.forEach((param, index) => {
+      param.endContext();
+    });
+    setCallID(this._previousCallID);
+  }
+
+  __onEvaluate() {
+    this.beginContext();
+    const value = val(this._what);
+    this.endContext();
+    return value;
+  }
+}
+
+export function createAnimatedCallFunc(proc, args, params) {
+  return new AnimatedCallFunc(proc, args.map(p => adapt(p)), params);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedClock.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedClock.js
new file mode 100644
index 0000000..947f545
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedClock.js
@@ -0,0 +1,91 @@
+import InternalAnimatedValue from './InternalAnimatedValue';
+import AnimatedNode from './AnimatedNode';
+import { val } from '../val';
+
+class AnimatedMainClock extends InternalAnimatedValue {
+  _frameCallback;
+
+  constructor() {
+    super({ type: 'MAIN_CLOCK' });
+  }
+
+  __onEvaluate() {
+    return +new Date();
+  }
+
+  _runFrame = () => {
+    this._updateValue(0);
+    if (this.__children.length > 0) {
+      this._frameCallback = requestAnimationFrame(this._runFrame);
+    }
+  };
+
+  __attach() {
+    super.__attach();
+    if (!this._frameCallback) {
+      this._frameCallback = requestAnimationFrame(this._runFrame);
+    }
+  }
+
+  __detach() {
+    if (this._frameCallback) {
+      cancelAnimationFrame(this._frameCallback);
+      this._frameCallback = null;
+    }
+    super.__detach();
+  }
+}
+
+const mainClock = new AnimatedMainClock();
+
+export default class AnimatedClock extends AnimatedNode {
+  _started;
+  _attached;
+
+  constructor() {
+    super({ type: 'clock' });
+  }
+
+  toString() {
+    return `AnimatedClock, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    return val(mainClock);
+  }
+
+  __attach() {
+    super.__attach();
+    if (this._started && !this._attached) {
+      mainClock.__addChild(this);
+    }
+    this._attached = true;
+  }
+
+  __detach() {
+    if (this._started && this._attached) {
+      mainClock.__removeChild(this);
+    }
+    this._attached = false;
+    super.__detach();
+  }
+
+  start() {
+    if (!this._started && this._attached) {
+      mainClock.__addChild(this);
+    }
+    this._started = true;
+  }
+
+  stop() {
+    if (this._started && this._attached) {
+      mainClock.__removeChild(this);
+    }
+    this._started = false;
+  }
+
+  isStarted() {
+    return this._started;
+  }
+}
+
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedClockTest.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedClockTest.js
new file mode 100644
index 0000000..c279ccf
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedClockTest.js
@@ -0,0 +1,22 @@
+import AnimatedNode from './AnimatedNode';
+
+class AnimatedClockTest extends AnimatedNode {
+  _clockNode;
+
+  constructor(clockNode) {
+    super({ type: 'clockTest', clock: clockNode });
+    this._clockNode = clockNode;
+  }
+
+  toString() {
+    return `AnimatedClockTest, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    return this._clockNode.isStarted() ? 1 : 0;
+  }
+}
+
+export function createAnimatedClockTest(clock) {
+  return new AnimatedClockTest(clock);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCode.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCode.js
new file mode 100644
index 0000000..b72b6dc
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCode.js
@@ -0,0 +1,32 @@
+import useCode from '../derived/useCode';
+import AnimatedNode from './AnimatedNode';
+
+function assertNodesNotNull(code, children, exec) {
+  if (!code) {
+    const error = !children
+      ? `Got "${typeof children}" type passed to children`
+      : `Got "${typeof exec}" type passed to exec`;
+
+    throw new Error(
+      `<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. ${error}`
+    );
+  }
+}
+
+function Code({ exec, children, dependencies = [] }) {
+  const nodes = children || exec;
+
+  let code = null;
+  if (nodes instanceof AnimatedNode) {
+    code = () => nodes;
+  } else if (typeof nodes === 'function') {
+    code = nodes;
+  }
+
+  assertNodesNotNull(code, children, exec);
+
+  useCode(code, dependencies);
+  return null;
+}
+
+export default Code;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedConcat.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedConcat.js
new file mode 100644
index 0000000..d1da11b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedConcat.js
@@ -0,0 +1,32 @@
+import invariant from 'fbjs/lib/invariant';
+import { adapt } from '../core/AnimatedBlock';
+import AnimatedNode from './AnimatedNode';
+import { val } from '../val';
+
+class AnimatedConcat extends AnimatedNode {
+  constructor(input) {
+    invariant(
+      input.every(
+        el =>
+          el instanceof AnimatedNode ||
+          typeof el === 'number' ||
+          typeof el === 'string'
+      ),
+      `Reanimated: Animated.concat node arguments should be of type AnimatedNode or String or Number. One or more of them are not of that type. Node: ${input}`
+    );
+    super({ type: 'concat', input }, input);
+    this._input = input;
+  }
+
+  __onEvaluate() {
+    return this._input.reduce((prev, current) => prev + val(current), '');
+  }
+
+  toString() {
+    return `AnimatedConcat, id: ${this.__nodeID}`;
+  }
+}
+
+export function createAnimatedConcat(...args) {
+  return new AnimatedConcat(args.map(adapt));
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCond.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCond.js
new file mode 100644
index 0000000..9d882e0
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedCond.js
@@ -0,0 +1,57 @@
+import invariant from 'fbjs/lib/invariant';
+import { adapt } from '../core/AnimatedBlock';
+import { val } from '../val';
+import AnimatedNode from './AnimatedNode';
+
+class AnimatedCond extends AnimatedNode {
+  _condition;
+  _ifBlock;
+  _elseBlock;
+
+  constructor(condition, ifBlock, elseBlock) {
+    invariant(
+      condition instanceof AnimatedNode,
+      `Reanimated: Animated.cond node first argument should be of type AnimatedNode but got ${condition}`
+    );
+    invariant(
+      ifBlock instanceof AnimatedNode,
+      `Reanimated: Animated.cond node second argument should be of type AnimatedNode but got ${ifBlock}`
+    );
+    invariant(
+      elseBlock instanceof AnimatedNode || elseBlock === undefined,
+      `Reanimated: Animated.cond node third argument should be of type AnimatedNode or should be undefined but got ${elseBlock}`
+    );
+    super(
+      {
+        type: 'cond',
+        cond: condition,
+        ifBlock,
+        elseBlock,
+      },
+      [condition, ifBlock, elseBlock]
+    );
+    this._condition = condition;
+    this._ifBlock = ifBlock;
+    this._elseBlock = elseBlock;
+  }
+
+  toString() {
+    return `AnimatedCond, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    if (val(this._condition)) {
+      return val(this._ifBlock);
+    } else {
+      return this._elseBlock !== undefined ? val(this._elseBlock) : undefined;
+    }
+  }
+}
+
+export function createAnimatedCond(cond, ifBlock, elseBlock) {
+  return new AnimatedCond(
+    adapt(cond),
+    adapt(ifBlock),
+    elseBlock === undefined ? undefined : adapt(elseBlock)
+  );
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedDebug.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedDebug.js
new file mode 100644
index 0000000..2dfff07
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedDebug.js
@@ -0,0 +1,58 @@
+import invariant from 'fbjs/lib/invariant';
+import { val } from '../val';
+import { adapt, createAnimatedBlock as block } from './AnimatedBlock';
+import { createAnimatedCall as call } from './AnimatedCall';
+import AnimatedNode from './AnimatedNode';
+
+class AnimatedDebug extends AnimatedNode {
+  _message;
+  _value;
+
+  constructor(message, value) {
+    invariant(
+      typeof message === 'string',
+      `Reanimated: Animated.debug node first argument should be of type string but got ${message}`
+    );
+    invariant(
+      value instanceof AnimatedNode,
+      `Reanimated: Animated.debug node second argument should be of type AnimatedNode but got ${value}`
+    );
+    super({ type: 'debug', message, value }, [value]);
+    this._message = message;
+    this._value = value;
+  }
+
+  toString() {
+    return `AnimatedDebug, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    const value = val(this._value);
+    console.log(this._message, value);
+    return value;
+  }
+}
+
+export function createAnimatedDebug(message, value) {
+  if (__DEV__) {
+    const runningInRemoteDebugger = typeof atob !== 'undefined';
+    // hack to detect if app is running in remote debugger
+    // https://stackoverflow.com/questions/39022216
+
+    const runningInExpoShell =
+      global.Expo && global.Expo.Constants.appOwnership !== 'standalone';
+
+    if (runningInRemoteDebugger || runningInExpoShell) {
+      // When running in expo or remote debugger we use JS console.log to output variables
+      // otherwise we output to the native console using native debug node
+      return block([
+        call([value], ([a]) => console.log(`${message} ${a}`)),
+        value,
+      ]);
+    } else {
+      return new AnimatedDebug(message, adapt(value));
+    }
+  }
+  // Debugging is disabled in PROD
+  return value;
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedEvent.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedEvent.js
new file mode 100644
index 0000000..024f1cd
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedEvent.js
@@ -0,0 +1,122 @@
+import { Platform, findNodeHandle } from 'react-native';
+import ReanimatedModule from '../ReanimatedModule';
+
+import AnimatedNode from './AnimatedNode';
+import InternalAnimatedValue from './AnimatedValue';
+import { createAnimatedAlways } from './AnimatedAlways';
+
+import invariant from 'fbjs/lib/invariant';
+import createEventObjectProxyPolyfill from './createEventObjectProxyPolyfill';
+
+function sanitizeArgMapping(argMapping) {
+  // Find animated values in `argMapping` and create an array representing their
+  // key path inside the `nativeEvent` object. Ex.: ['contentOffset', 'x'].
+  const eventMappings = [];
+  const alwaysNodes = [];
+
+  const getNode = node => {
+    if (Platform.OS === 'web' || Platform.OS === 'windows' || Platform.OS === 'macos') {
+      return node;
+    }
+    return node.__nodeID;
+  };
+
+  const traverse = (value, path) => {
+    if (value instanceof InternalAnimatedValue) {
+      eventMappings.push(path.concat(getNode(value)));
+    } else if (typeof value === 'object' && value.__val) {
+      eventMappings.push(path.concat(getNode(value.__val)));
+    } else if (typeof value === 'function') {
+      const node = new InternalAnimatedValue(0);
+      alwaysNodes.push(createAnimatedAlways(value(node)));
+      eventMappings.push(path.concat(getNode(node)));
+    } else if (typeof value === 'object') {
+      for (const key in value) {
+        traverse(value[key], path.concat(key));
+      }
+    }
+  };
+
+  invariant(
+    argMapping[0] && argMapping[0].nativeEvent,
+    'Native driven events only support animated values contained inside `nativeEvent`.'
+  );
+
+  // Assume that the event containing `nativeEvent` is always the first argument.
+  const ev = argMapping[0].nativeEvent;
+  if (typeof ev === 'object') {
+    traverse(ev, []);
+  } else if (typeof ev === 'function') {
+    const proxyHandler = {
+      get: function(target, name) {
+        if (name === '__isProxy') {
+          return true;
+        }
+        if (!target[name] && name !== '__val') {
+          target[name] = new Proxy({}, proxyHandler);
+        }
+        return target[name];
+      },
+      set: function(target, prop, value) {
+        if (prop === '__val') {
+          target[prop] = value;
+          return true;
+        }
+        return false;
+      },
+    };
+
+    const proxy =
+      typeof Proxy === 'function'
+        ? new Proxy({}, proxyHandler)
+        : createEventObjectProxyPolyfill();
+    alwaysNodes.push(createAnimatedAlways(ev(proxy)));
+    traverse(proxy, []);
+  }
+
+  return { eventMappings, alwaysNodes };
+}
+
+export default class AnimatedEvent extends AnimatedNode {
+  constructor(argMapping, config = {}) {
+    const { eventMappings, alwaysNodes } = sanitizeArgMapping(argMapping);
+    super({ type: 'event', argMapping: eventMappings });
+    this._alwaysNodes = alwaysNodes;
+  }
+
+  toString() {
+    return `AnimatedEvent, id: ${this.__nodeID}`;
+  }
+
+  // The below field is a temporary workaround to make AnimatedEvent object be recognized
+  // as Animated.event event callback and therefore filtered out from being send over the
+  // bridge which was causing the object to be frozen in JS.
+  __isNative = true;
+
+  attachEvent(viewRef, eventName) {
+    for (let i = 0; i < this._alwaysNodes.length; i++) {
+      this._alwaysNodes[i].__attach();
+    }
+    this.__attach();
+    const viewTag = findNodeHandle(viewRef);
+    ReanimatedModule.attachEvent(viewTag, eventName, this.__nodeID);
+  }
+
+  __onEvaluate() {
+    return 0;
+  }
+
+  detachEvent(viewRef, eventName) {
+    for (let i = 0; i < this._alwaysNodes.length; i++) {
+      this._alwaysNodes[i].isNativelyInitialized() &&
+        this._alwaysNodes[i].__detach();
+    }
+    const viewTag = findNodeHandle(viewRef);
+    ReanimatedModule.detachEvent(viewTag, eventName, this.__nodeID);
+    this.__detach();
+  }
+}
+
+export function createAnimatedEvent(argMapping, config) {
+  return new AnimatedEvent(argMapping, config);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedFunction.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedFunction.js
new file mode 100644
index 0000000..6eed423
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedFunction.js
@@ -0,0 +1,55 @@
+import AnimatedNode from './AnimatedNode';
+import { createAnimatedCallFunc } from './AnimatedCallFunc';
+import { createAnimatedParam } from './AnimatedParam';
+import { val } from '../val';
+import invariant from 'fbjs/lib/invariant';
+
+class AnimatedFunction extends AnimatedNode {
+  _what;
+
+  constructor(what, ...params) {
+    invariant(
+      what instanceof AnimatedNode,
+      `Reanimated: AnimatedCallFunc 'what' argument should be of type AnimatedNode but got ${what}`
+    );
+    super(
+      {
+        type: 'func',
+        what,
+      },
+      [what, ...params]
+    );
+    this._what = what;
+    this.__attach();
+  }
+
+  __onEvaluate() {
+    return val(this._what);
+  }
+
+  toString() {
+    return `AnimatedFunction, id: ${this.__nodeID}`;
+  }
+}
+
+export function createAnimatedFunction(cb) {
+  const params = new Array(cb.length);
+  for (let i = 0; i < params.length; i++) {
+    params[i] = createAnimatedParam();
+  }
+  // eslint-disable-next-line standard/no-callback-literal
+  const what = cb(...params);
+  const func = new AnimatedFunction(what, ...params);
+  return (...args) => {
+    if (args.length !== params.length) {
+      throw new Error(
+        'Parameter mismatch when calling reanimated function. Expected ' +
+          params.length +
+          ' parameters, got ' +
+          args.length +
+          '.'
+      );
+    }
+    return createAnimatedCallFunc(func, args, params);
+  };
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedNode.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedNode.js
new file mode 100644
index 0000000..567d713
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedNode.js
@@ -0,0 +1,214 @@
+import ReanimatedModule from '../ReanimatedModule';
+import { Platform } from 'react-native';
+
+const UPDATED_NODES = [];
+
+let loopID = 1;
+let propUpdatesEnqueued = null;
+let nodeCount = 0;
+let callID = "";
+
+export function getCallID() {
+  return callID;
+}
+
+export function setCallID(nextCallID) {
+  callID = nextCallID;
+}
+
+function sanitizeConfig(config) {
+  if (Platform.OS === 'web' || Platform.OS === 'windows' || Platform.OS === 'macos' || ['undefined', 'string', 'function', 'boolean', 'number'].includes(typeof config)) {
+    return config;
+  } else if (Array.isArray(config)) {
+    return config.map(sanitizeConfig);
+  } else if (config instanceof AnimatedNode) {
+    return config.__nodeID;
+  } else if (typeof config === 'object') {
+    const output = {};
+    for (const property in config) {
+      if (property in config) {
+        output[property] = sanitizeConfig(config[property]);
+      }
+    }
+    return output;
+  }
+  // unhandled
+  return config;
+}
+
+function runPropUpdates() {
+  const visitedNodes = new Set();
+  const findAndUpdateNodes = node => {
+    if (!node) {
+      console.warn('findAndUpdateNodes was passed a nullish node');
+      return;
+    }
+
+    if (visitedNodes.has(node)) {
+      return;
+    } else {
+      visitedNodes.add(node);
+    }
+    if (typeof node.update === 'function') {
+      node.update();
+    } else {
+      const nodes = node.__getChildren();
+      if (nodes) {
+        for (let i = 0, l = nodes.length; i < l; i++) {
+          findAndUpdateNodes(nodes[i]);
+        }
+      }
+    }
+  };
+  for (let i = 0; i < UPDATED_NODES.length; i++) {
+    const node = UPDATED_NODES[i];
+    findAndUpdateNodes(node);
+  }
+  UPDATED_NODES.length = 0; // clear array
+  propUpdatesEnqueued = null;
+  loopID += 1;
+}
+
+export default class AnimatedNode {
+
+  __nodeID;
+  __lastLoopID = { "": -1 };
+  __memoizedValue = { "": null };
+  __children = [];
+
+  constructor(nodeConfig, inputNodes) {
+    this.__nodeID = ++nodeCount;
+    this.__nodeConfig = sanitizeConfig(nodeConfig);
+    this.__initialized = false;
+    this.__inputNodes =
+      inputNodes && inputNodes.filter(node => node instanceof AnimatedNode);
+  }
+
+  toString() {
+    return `AnimatedNode, id: ${this.__nodeID}`;
+  }
+
+  __attach() {
+    this.__nativeInitialize();
+
+    const nodes = this.__inputNodes;
+
+    if (nodes) {
+      for (let i = 0, l = nodes.length; i < l; i++) {
+        nodes[i].__addChild(this);
+      }
+    }
+  }
+
+  __detach() {
+    const nodes = this.__inputNodes;
+
+    if (nodes) {
+      for (let i = 0, l = nodes.length; i < l; i++) {
+        nodes[i].__removeChild(this);
+      }
+    }
+
+    this.__nativeTearDown();
+  }
+
+  __getValue() {
+    if (!(callID in this.__lastLoopID) || this.__lastLoopID[callID] < loopID) {
+      this.__lastLoopID[callID] = loopID;
+      const result = this.__onEvaluate();
+      this.__memoizedValue[callID] = result;
+      return result;
+    }
+    return this.__memoizedValue[callID];
+  }
+
+  __forceUpdateCache(newValue) {
+    this.__memoizedValue[callID] = newValue;
+    this.__markUpdated();
+  }
+
+  __dangerouslyRescheduleEvaluate() {
+    this.__lastLoopID[callID] = -1;
+    this.__markUpdated();
+  }
+
+  __markUpdated() {
+    UPDATED_NODES.push(this);
+    if (!propUpdatesEnqueued) {
+      propUpdatesEnqueued = setImmediate(runPropUpdates);
+    }
+  }
+
+  __nativeInitialize() {
+    if (!this.__initialized) {
+      ReanimatedModule.createNode(this.__nodeID, { ...this.__nodeConfig });
+      this.__initialized = true;
+    }
+  }
+
+  __nativeTearDown() {
+    if (this.__initialized) {
+      ReanimatedModule.dropNode(this.__nodeID);
+      this.__initialized = false;
+    }
+  }
+
+  isNativelyInitialized() {
+    return this.__initialized;
+  }
+
+  __onEvaluate() {
+    throw new Error('Missing implementation of onEvaluate');
+  }
+
+  __getProps() {
+    return this.__getValue();
+  }
+
+  __getChildren() {
+    return this.__children;
+  }
+
+  __addChild(child) {
+    if (this.__children.length === 0) {
+      this.__attach();
+    }
+    this.__children.push(child);
+    child.__nativeInitialize();
+
+    if (ReanimatedModule.connectNodes) {
+      ReanimatedModule.connectNodes(this.__nodeID, child.__nodeID);
+    } else {
+      child.__dangerouslyRescheduleEvaluate();
+    }
+  }
+
+  __removeChild(child) {
+    const index = this.__children.indexOf(child);
+    if (index === -1) {
+      console.warn("Trying to remove a child that doesn't exist");
+      return;
+    }
+
+    if (ReanimatedModule.disconnectNodes) {
+      ReanimatedModule.disconnectNodes(this.__nodeID, child.__nodeID);
+    }
+
+    this.__children.splice(index, 1);
+    if (this.__children.length === 0) {
+      this.__detach();
+    }
+  }
+
+  _connectAnimatedView(nativeViewTag) {
+    if (ReanimatedModule.connectNodeToView) {
+      ReanimatedModule.connectNodeToView(this.__nodeID, nativeViewTag);
+    } else {
+      this.__dangerouslyRescheduleEvaluate();
+    }
+  }
+
+  _disconnectAnimatedView(nativeViewTag) {
+    ReanimatedModule.disconnectNodeFromView(this.__nodeID, nativeViewTag);
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedOperator.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedOperator.js
new file mode 100644
index 0000000..4c91010
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedOperator.js
@@ -0,0 +1,106 @@
+import AnimatedNode from './AnimatedNode';
+import { val } from '../val';
+
+import invariant from 'fbjs/lib/invariant';
+import { adapt } from '../core/AnimatedBlock';
+
+function reduce(fn) {
+  return input => input.reduce((a, b) => fn(val(a), val(b)));
+}
+
+function reduceFrom(fn, initialValue) {
+  return input => input.reduce((a, b) => fn(val(a), val(b)), initialValue);
+}
+
+function infix(fn) {
+  return input => fn(val(input[0]), val(input[1]));
+}
+
+function single(fn) {
+  return input => fn(val(input[0]));
+}
+
+const OPERATIONS = {
+  // arithmetic
+  add: reduce((a, b) => a + b),
+  sub: reduce((a, b) => a - b),
+  multiply: reduce((a, b) => a * b),
+  divide: reduce((a, b) => a / b),
+  pow: reduce((a, b) => Math.pow(a, b)),
+  modulo: reduce((a, b) => ((a % b) + b) % b),
+  sqrt: single(a => Math.sqrt(a)),
+  log: single(a => Math.log(a)),
+  sin: single(a => Math.sin(a)),
+  cos: single(a => Math.cos(a)),
+  tan: single(a => Math.tan(a)),
+  acos: single(a => Math.acos(a)),
+  asin: single(a => Math.asin(a)),
+  atan: single(a => Math.atan(a)),
+  exp: single(a => Math.exp(a)),
+  round: single(a => Math.round(a)),
+  abs: single(a => Math.abs(a)),
+  ceil: single(a => Math.ceil(a)),
+  floor: single(a => Math.floor(a)),
+  max: reduce((a,b) => Math.max(a, b)),
+  min: reduce((a,b) => Math.min(a, b)),
+
+  // logical
+  and: reduceFrom((a, b) => a && b, true),
+  or: reduceFrom((a, b) => a || b, false),
+  not: single(a => !a),
+  defined: single(a => a !== null && a !== undefined && !isNaN(a)),
+
+  // comparing
+  lessThan: infix((a, b) => a < b),
+  /* eslint-disable-next-line eqeqeq */
+  eq: infix((a, b) => a == b),
+  greaterThan: infix((a, b) => a > b),
+  lessOrEq: infix((a, b) => a <= b),
+  greaterOrEq: infix((a, b) => a >= b),
+  /* eslint-disable-next-line eqeqeq */
+  neq: infix((a, b) => a != b),
+};
+
+class AnimatedOperator extends AnimatedNode {
+  _input;
+  _op;
+  _operation;
+
+  constructor(operator, input) {
+    invariant(
+      typeof operator === 'string',
+      `Reanimated: Animated.operator node first argument should be of type String, but got: ${operator}`
+    );
+    invariant(
+      input.every(
+        el =>
+          el instanceof AnimatedNode ||
+          typeof el === 'string' ||
+          typeof el === 'number'
+      ),
+      `Reanimated: Animated.operator node second argument should be one or more of type AnimatedNode, String or Number but got ${input}`
+    );
+    super(
+      { type: 'op', op: operator, input },
+      input
+    );
+    this._op = operator;
+    this._input = input;
+  }
+
+  toString() {
+    return `AnimatedOperator, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    if (!this._operation) {
+      this._operation = OPERATIONS[this._op];
+      invariant(this._operation, `Illegal operator '%s'`, this._op);
+    }
+    return this._operation(this._input);
+  }
+}
+
+export function createAnimatedOperator(name) {
+  return (...args) => new AnimatedOperator(name, args.map(adapt));
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedParam.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedParam.js
new file mode 100644
index 0000000..c5a898b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedParam.js
@@ -0,0 +1,85 @@
+import invariant from 'fbjs/lib/invariant';
+import AnimatedNode, { getCallID, setCallID } from './AnimatedNode';
+import AnimatedClock from './AnimatedClock';
+import { val } from '../val';
+
+export class AnimatedParam extends AnimatedNode {
+  argsStack = [];
+  _prevCallID;
+  
+  constructor() {
+    super({ type: 'param' }, []);
+    this.__attach();
+  }
+
+  beginContext(ref, prevCallID) {
+    this._prevCallID = prevCallID;
+    this.argsStack.push(ref);
+  }
+
+  endContext() {
+    this.argsStack.pop();
+  }
+
+  _getTopNode() {
+    if (this.argsStack.length === 0) throw new Error(`param: Invocation failed because argsStack is empty`);
+    const top = this.argsStack[this.argsStack.length - 1];
+    return top;
+  }
+
+  setValue(value) {
+    const top = this._getTopNode();
+    if (top.setValue) {
+      const callID = getCallID();
+      setCallID(this._prevCallID);
+      top.setValue(value);
+      setCallID(callID);
+    } else {
+      throw new Error(`param: setValue(${value}) failed because the top element has no known method for updating it's current value.`)
+    }
+  }
+  
+  __onEvaluate() {
+    const callID = getCallID();
+    setCallID(this._prevCallID);
+    const top = this._getTopNode();
+    const value = val(top);
+    setCallID(callID);
+    return value;
+  }
+
+  start() {
+    const node = this._getTopNode();
+    invariant(
+      node instanceof AnimatedClock || node instanceof AnimatedParam,
+      `param: top node should be of type AnimatedClock but got ${node}`
+    );
+    node.start();
+  }
+
+  stop() {
+    const node = this._getTopNode();
+    invariant(
+      node instanceof AnimatedClock || node instanceof AnimatedParam,
+      `param: top node should be of type AnimatedClock but got ${node}`
+    );
+    node.stop();
+  }
+
+  isRunning() {
+    const node = this._getTopNode();
+
+    if (node instanceof AnimatedParam) {
+      return node.isRunning()
+    }
+    invariant(
+      node instanceof AnimatedClock,
+      `param: top node should be of type AnimatedClock but got ${node}`
+    );
+    return node.isStarted();
+  }
+}
+
+export function createAnimatedParam() {
+  return new AnimatedParam();
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedProps.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedProps.js
new file mode 100644
index 0000000..848408b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedProps.js
@@ -0,0 +1,105 @@
+import { findNodeHandle } from 'react-native';
+
+import AnimatedNode from './AnimatedNode';
+import AnimatedEvent from './AnimatedEvent';
+import { createOrReuseStyleNode } from './AnimatedStyle';
+
+import invariant from 'fbjs/lib/invariant';
+import deepEqual from 'fbjs/lib/areEqual';
+import { val } from '../val';
+
+function sanitizeProps(inputProps) {
+  let props;
+  for (const key in inputProps) {
+    const value = inputProps[key];
+    if (value instanceof AnimatedNode && !(value instanceof AnimatedEvent)) {
+      if (props === undefined) {
+        props = {};
+      }
+      props[key] = value.__nodeID;
+    }
+  }
+  return props;
+}
+
+export function createOrReusePropsNode(props, callback, oldNode) {
+  if (props.style) {
+    const style = createOrReuseStyleNode(props.style, oldNode && oldNode._props.style);
+    if (style) {
+      props = {
+        ...props,
+        style,
+      };
+    }
+  }
+  const config = sanitizeProps(props);
+  if (config === undefined) {
+    return undefined;
+  }
+  if (oldNode && deepEqual(config, oldNode._config)) {
+    return oldNode;
+  }
+  return new AnimatedProps(props, config, callback);
+}
+
+class AnimatedProps extends AnimatedNode {
+  constructor(props, config, callback) {
+    super(
+      { type: 'props', props: config },
+      Object.values(props).filter(n => !(n instanceof AnimatedEvent))
+    );
+    this._config = config;
+    this._props = props;
+    this._callback = callback;
+    this.__attach();
+  }
+
+  toString() {
+    return `AnimatedProps, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    const props = {};
+    for (const key in this._props) {
+      const value = this._props[key];
+      if (value instanceof AnimatedNode) {
+        props[key] = value.__getValue();
+      }
+    }
+    return props;
+  }
+
+  __detach() {
+    const nativeViewTag = findNodeHandle(this._animatedView);
+    invariant(
+      nativeViewTag != null,
+      'Unable to locate attached view in the native tree'
+    );
+    this._disconnectAnimatedView(nativeViewTag);
+    super.__detach();
+  }
+
+  update() {
+    this._callback();
+
+    if (!this._animatedView) {
+      return;
+    }
+
+    val(this);
+  }
+
+  setNativeView(animatedView) {
+    if (this._animatedView === animatedView) {
+      return;
+    }
+    this._animatedView = animatedView;
+
+    const nativeViewTag = findNodeHandle(this._animatedView);
+    invariant(
+      nativeViewTag != null,
+      'Unable to locate attached view in the native tree'
+    );
+    this._connectAnimatedView(nativeViewTag);
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedSet.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedSet.js
new file mode 100644
index 0000000..8c81213
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedSet.js
@@ -0,0 +1,38 @@
+import AnimatedNode from './AnimatedNode';
+import invariant from 'fbjs/lib/invariant';
+import { val } from '../val';
+import { adapt } from '../core/AnimatedBlock';
+
+class AnimatedSet extends AnimatedNode {
+  _what;
+  _value;
+
+  constructor(what, value) {
+    invariant(
+      what instanceof AnimatedNode,
+      `Reanimated: Animated.set first argument should be of type AnimatedNode but got ${what}`
+    );
+    invariant(
+      value instanceof AnimatedNode,
+      `Reanimated: Animated.set second argument should be of type AnimatedNode, String or Number but got ${value}`
+    );
+    super({ type: 'set', what, value }, [value]);
+    invariant(!what._constant, 'Value to be set cannot be constant');
+    this._what = what;
+    this._value = value;
+  }
+
+  toString() {
+    return `AnimatedSet, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    const newValue = val(this._value);
+    this._what.setValue(newValue);
+    return newValue;
+  }
+}
+
+export function createAnimatedSet(what, value) {
+  return new AnimatedSet(what, adapt(value));
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStartClock.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStartClock.js
new file mode 100644
index 0000000..c40af3d
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStartClock.js
@@ -0,0 +1,30 @@
+import AnimatedNode from './AnimatedNode';
+import AnimatedClock from './AnimatedClock';
+import { AnimatedParam } from "./AnimatedParam";
+import invariant from 'fbjs/lib/invariant';
+
+class AnimatedStartClock extends AnimatedNode {
+  _clockNode;
+
+  constructor(clockNode) {
+    invariant(
+      clockNode instanceof AnimatedClock || clockNode instanceof AnimatedParam,
+      `Reanimated: Animated.startClock argument should be of type AnimatedClock but got ${clockNode}`
+    );
+    super({ type: 'clockStart', clock: clockNode });
+    this._clockNode = clockNode;
+  }
+
+  toString() {
+    return `AnimatedStartClock, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    this._clockNode.start();
+    return 0;
+  }
+}
+
+export function createAnimatedStartClock(clock) {
+  return new AnimatedStartClock(clock);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStopClock.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStopClock.js
new file mode 100644
index 0000000..c88bf9f
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStopClock.js
@@ -0,0 +1,30 @@
+import AnimatedNode from './AnimatedNode';
+import AnimatedClock from './AnimatedClock';
+import { AnimatedParam } from "./AnimatedParam";
+import invariant from 'fbjs/lib/invariant';
+
+class AnimatedStopClock extends AnimatedNode {
+  _clockNode;
+
+  constructor(clockNode) {
+    invariant(
+      clockNode instanceof AnimatedClock || clockNode instanceof AnimatedParam,
+      `Reanimated: Animated.stopClock argument should be of type AnimatedClock but got ${clockNode}`
+    );
+    super({ type: 'clockStop', clock: clockNode });
+    this._clockNode = clockNode;
+  }
+
+  toString() {
+    return `AnimatedStopClock, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    this._clockNode.stop();
+    return 0;
+  }
+}
+
+export function createAnimatedStopClock(clock) {
+  return new AnimatedStopClock(clock);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStyle.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStyle.js
new file mode 100644
index 0000000..c696a05
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedStyle.js
@@ -0,0 +1,78 @@
+import { StyleSheet } from 'react-native';
+
+import AnimatedNode from './AnimatedNode';
+import { createOrReuseTransformNode } from './AnimatedTransform';
+
+import deepEqual from 'fbjs/lib/areEqual';
+
+function sanitizeStyle(inputStyle) {
+  let style;
+  for (const key in inputStyle) {
+    const value = inputStyle[key];
+    if (value instanceof AnimatedNode) {
+      if (style === undefined) {
+        style = {};
+      }
+      style[key] = value.__nodeID;
+    }
+  }
+  return style;
+}
+
+export function createOrReuseStyleNode(style, oldNode) {
+  style = StyleSheet.flatten(style) || {};
+  if (style.transform) {
+    const transform = createOrReuseTransformNode(
+      style.transform,
+      oldNode && oldNode._style.transform
+    );
+    if (transform) {
+      style = {
+        ...style,
+        transform,
+      };
+    }
+  }
+  const config = sanitizeStyle(style);
+  if (config === undefined) {
+    return undefined;
+  }
+  if (oldNode && deepEqual(config, oldNode._config)) {
+    return oldNode;
+  }
+  return new AnimatedStyle(style, config);
+}
+
+/**
+ * AnimatedStyle should never be directly instantiated, use createOrReuseStyleNode
+ * in order to make a new instance of this node.
+ */
+export default class AnimatedStyle extends AnimatedNode {
+  constructor(style, config) {
+    super({ type: 'style', style: config }, Object.values(style));
+    this._config = config;
+    this._style = style;
+  }
+
+  toString() {
+    return `AnimatedStyle, id: ${this.__nodeID}`;
+  }
+
+  _walkStyleAndGetAnimatedValues(style) {
+    const updatedStyle = {};
+    for (const key in style) {
+      const value = style[key];
+      if (value instanceof AnimatedNode) {
+        updatedStyle[key] = value.__getValue();
+      } else if (value && !Array.isArray(value) && typeof value === 'object') {
+        // Support animating nested values (for example: shadowOffset.height)
+        updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
+      }
+    }
+    return updatedStyle;
+  }
+
+  __onEvaluate() {
+    return this._walkStyleAndGetAnimatedValues(this._style);
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedTransform.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedTransform.js
new file mode 100644
index 0000000..0520a71
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedTransform.js
@@ -0,0 +1,78 @@
+import AnimatedNode from './AnimatedNode';
+
+import deepEqual from 'fbjs/lib/areEqual';
+
+function sanitizeTransform(inputTransform) {
+  const outputTransform = [];
+  let hasAnimatedTransform = false;
+  inputTransform.forEach(transform => {
+    for (const key in transform) {
+      const value = transform[key];
+      if (value instanceof AnimatedNode) {
+        hasAnimatedTransform = true;
+        outputTransform.push({
+          property: key,
+          nodeID: value.__nodeID,
+        });
+      } else {
+        outputTransform.push({
+          property: key,
+          value,
+        });
+      }
+    }
+  });
+  return hasAnimatedTransform ? outputTransform : undefined;
+}
+
+function extractAnimatedParentNodes(transform) {
+  const parents = [];
+  transform.forEach(transform => {
+    for (const key in transform) {
+      const value = transform[key];
+      if (value instanceof AnimatedNode) {
+        parents.push(value);
+      }
+    }
+  });
+  return parents;
+}
+
+export function createOrReuseTransformNode(transform, oldNode) {
+  const config = sanitizeTransform(transform);
+  if (config === undefined) {
+    return undefined;
+  }
+  if (oldNode && deepEqual(config, oldNode._config)) {
+    return oldNode;
+  }
+  return new AnimatedTransform(transform, config);
+}
+
+class AnimatedTransform extends AnimatedNode {
+  constructor(transform, config) {
+    super(
+      { type: 'transform', transform: config },
+      extractAnimatedParentNodes(transform)
+    );
+    this._config = config;
+    this._transform = transform;
+  }
+
+  toString() {
+    return `AnimatedTransform, id: ${this.__nodeID}`;
+  }
+
+  __onEvaluate() {
+    return this._transform.map(transform => {
+      const result = {};
+      for (const key in transform) {
+        const value = transform[key];
+        if (value instanceof AnimatedNode) {
+          result[key] = value.__getValue();
+        }
+      }
+      return result;
+    });
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedValue.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedValue.js
new file mode 100644
index 0000000..3cb59d1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/AnimatedValue.js
@@ -0,0 +1,34 @@
+import { createAnimatedSet as set } from '../core/AnimatedSet';
+import interpolate from '../derived/interpolate';
+import InternalAnimatedValue from './InternalAnimatedValue';
+import { Platform } from 'react-native';
+import { evaluateOnce } from '../derived/evaluateOnce';
+import ReanimatedModule from '../ReanimatedModule';
+import { val } from '../val';
+
+// Animated value wrapped with extra methods for omit cycle of dependencies
+export default class AnimatedValue extends InternalAnimatedValue {
+  setValue(value) {
+    this.__detachAnimation(this._animation);
+    if (Platform.OS === 'web' || Platform.OS === 'windows' || Platform.OS === 'macos') {
+      this._updateValue(val(value));
+    } else {
+      if (ReanimatedModule.setValue && typeof value === 'number') {
+        // FIXME Remove it after some time
+        // For OTA-safety
+        // FIXME handle setting value with a node
+        ReanimatedModule.setValue(this.__nodeID, value);
+      } else {
+        evaluateOnce(set(this, value), this);
+      }
+    }
+  }
+
+  toString() {
+    return `AnimatedValue, id: ${this.__nodeID}`;
+  }
+
+  interpolate(config) {
+    return interpolate(this, config);
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/Core.test.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/Core.test.js
new file mode 100644
index 0000000..366d50e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/Core.test.js
@@ -0,0 +1,30 @@
+import React from 'react';
+import Animated from '../Animated';
+
+import renderer from 'react-test-renderer';
+
+jest.mock('../ReanimatedEventEmitter');
+jest.mock('../ReanimatedModule');
+jest.mock('../reanimated2/NativeReanimated.js');
+
+describe('Core Animated components', () => {
+  xit('fails if something other then a node or function that returns a node is passed to Animated.Code exec prop', () => {
+    console.error = jest.fn();
+
+    expect(() =>
+      renderer.create(<Animated.Code exec="not a node" />)
+    ).toThrowError(
+      "<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node."
+    );
+  });
+
+  xit('fails if something other then a node or function that returns a node is passed to Animated.Code children', () => {
+    console.error = jest.fn();
+
+    expect(() =>
+      renderer.create(<Animated.Code>not a node</Animated.Code>)
+    ).toThrowError(
+      "<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node."
+    );
+  });
+});
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/InternalAnimatedValue.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/InternalAnimatedValue.js
new file mode 100644
index 0000000..b262e38
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/InternalAnimatedValue.js
@@ -0,0 +1,90 @@
+import AnimatedNode from './AnimatedNode';
+import { val } from '../val';
+import ReanimatedModule from '../ReanimatedModule';
+import invariant from 'fbjs/lib/invariant';
+
+function sanitizeValue(value) {
+  return value === null || value === undefined || typeof value === 'string'
+    ? value
+    : Number(value);
+}
+
+const CONSTANT_VALUES = new Map();
+
+function initializeConstantValues() {
+  if (CONSTANT_VALUES.size !== 0) {
+    return;
+  }
+  [0, -1, 1, -2, 2].forEach(v =>
+    CONSTANT_VALUES.set(v, new InternalAnimatedValue(v, true))
+  );
+}
+
+/**
+ * This class has been made internal in order to omit dependencies' cycles which
+ * were caused by imperative setValue and interpolate  they are currently exposed with AnimatedValue.js
+ */
+export default class InternalAnimatedValue extends AnimatedNode {
+  static valueForConstant(number) {
+    initializeConstantValues();
+    return (
+      CONSTANT_VALUES.get(number) || new InternalAnimatedValue(number, true)
+    );
+  }
+
+  constructor(value, constant = false) {
+    invariant(
+      value !== null,
+      'Animated.Value cannot be set to the null'
+    );
+    super({ type: 'value', value: sanitizeValue(value) });
+    this._startingValue = this._value = value;
+    this._animation = null;
+    this._constant = constant;
+  }
+
+  __detach() {
+    if (!this._constant) {
+      if (ReanimatedModule.getValue) {
+        ReanimatedModule.getValue(
+          this.__nodeID,
+          val => (this.__nodeConfig.value = val)
+        );
+      } else {
+        this.__nodeConfig.value = this.__getValue();
+      }
+    }
+    this.__detachAnimation(this._animation);
+    super.__detach();
+  }
+
+  __detachAnimation(animation) {
+    animation && animation.__detach();
+    if (this._animation === animation) {
+      this._animation = null;
+    }
+  }
+
+  __attachAnimation(animation) {
+    this.__detachAnimation(this._animation);
+    this._animation = animation;
+  }
+
+  __onEvaluate() {
+    if (this.__inputNodes && this.__inputNodes.length) {
+      this.__inputNodes.forEach(val);
+    }
+    return this._value;
+  }
+
+  // AnimatedValue will override this method to modify the value of a native node.
+  setValue(value) {
+    this.__detachAnimation(this._animation);
+    this._updateValue(value);
+  }
+
+  _updateValue(value) {
+    this._value = value;
+    this.__forceUpdateCache(value);
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/__mocks__/AnimatedProps.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/__mocks__/AnimatedProps.js
new file mode 100644
index 0000000..c6139f4
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/__mocks__/AnimatedProps.js
@@ -0,0 +1,86 @@
+import AnimatedNode from '../AnimatedNode';
+import AnimatedEvent from '../AnimatedEvent';
+import AnimatedStyle, { createOrReuseStyleNode } from '../AnimatedStyle';
+
+import deepEqual from 'fbjs/lib/areEqual';
+
+// This file has been mocked as react-native's `findNodeHandle` is returning undefined value;
+// and I became easier to mock whole this file instead of mocking RN
+
+function sanitizeProps(inputProps) {
+  const props = {};
+  for (const key in inputProps) {
+    const value = inputProps[key];
+    if (value instanceof AnimatedNode && !(value instanceof AnimatedEvent)) {
+      props[key] = value.__nodeID;
+    }
+  }
+  return props;
+}
+
+export function createOrReusePropsNode(props, callback, oldNode) {
+  if (props.style) {
+    props = {
+      ...props,
+      style: createOrReuseStyleNode(
+        props.style,
+        oldNode && oldNode._props.style
+      ),
+    };
+  }
+  const config = sanitizeProps(props);
+  if (oldNode && deepEqual(config, oldNode._config)) {
+    return oldNode;
+  }
+  return new AnimatedProps(props, config, callback);
+}
+
+class AnimatedProps extends AnimatedNode {
+  constructor(props, config, callback) {
+    super(
+      { type: 'props', props: config },
+      Object.values(props).filter(n => !(n instanceof AnimatedEvent))
+    );
+    this._config = config;
+    this._props = props;
+    this._callback = callback;
+    this.__attach();
+  }
+
+  __getProps() {
+    const props = {};
+    for (const key in this._props) {
+      const value = this._props[key];
+      if (value instanceof AnimatedNode) {
+        if (value instanceof AnimatedStyle) {
+          props[key] = value.__getProps();
+        }
+      } else {
+        props[key] = value;
+      }
+    }
+    return props;
+  }
+
+  __onEvaluate() {
+    const props = {};
+    for (const key in this._props) {
+      const value = this._props[key];
+      if (value instanceof AnimatedNode) {
+        props[key] = value.__getValue();
+      }
+    }
+    return props;
+  }
+
+  update() {
+    this._callback();
+  }
+
+  setNativeView(animatedView) {
+    if (this._animatedView === animatedView) {
+      return;
+    }
+    this._animatedView = animatedView;
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/core/createEventObjectProxyPolyfill.js b/node_modules/react-native-reanimated/react-native-reanimated/src/core/createEventObjectProxyPolyfill.js
new file mode 100644
index 0000000..938f7f1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/core/createEventObjectProxyPolyfill.js
@@ -0,0 +1,44 @@
+// JSC on Android and iOS 8 & 9 does not support proxies.
+// The below workaround provides a proxy-like functionality for event data by
+// creating an object which contains predefined fields for the most commonly
+// used event attributes. If your app uses even attribute which is not listed
+// here please submit a PR to add that and we will merge it right away
+export default function createEventObjectProxyPolyfill() {
+  const nodesMap = {
+    // Gesture handlers-related event
+    translationX: {},
+    translationY: {},
+    state: {},
+    oldState: {},
+    absoluteX: {},
+    absoluteY: {},
+    x: {},
+    y: {},
+    velocityX: {},
+    velocityY: {},
+    scale: {},
+    focalX: {},
+    focalY: {},
+    rotation: {},
+    anchorX: {},
+    anchorY: {},
+    velocity: {},
+    numberOfPointers: {},
+    // onLayour-related event
+    layout: { x: {}, y: {}, width: {}, height: {} },
+    // ScrollView event
+    contentOffset: { y: {}, x: {} },
+    layoutMeasurement: { width: {}, height: {} },
+    contentSize: { width: {}, height: {} },
+    zoomScale: {},
+    contentInset: { right: {}, top: {}, left: {}, bottom: {} },
+  };
+  const traverse = obj => {
+    for (const key in obj) {
+      traverse(obj[key]);
+      Object.assign(obj[key], { __isProxy: true });
+    }
+  };
+  traverse(nodesMap);
+  return nodesMap;
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/createAnimatedComponent.js b/node_modules/react-native-reanimated/react-native-reanimated/src/createAnimatedComponent.js
new file mode 100644
index 0000000..bb13093
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/createAnimatedComponent.js
@@ -0,0 +1,371 @@
+import React from 'react';
+import { findNodeHandle, Platform, StyleSheet } from 'react-native';
+import ReanimatedEventEmitter from './ReanimatedEventEmitter';
+
+import AnimatedEvent from './core/AnimatedEvent';
+import AnimatedNode from './core/AnimatedNode';
+import AnimatedValue from './core/AnimatedValue';
+import { createOrReusePropsNode } from './core/AnimatedProps';
+import WorkletEventHandler from './reanimated2/WorkletEventHandler';
+
+import invariant from 'fbjs/lib/invariant';
+
+const setAndForwardRef = require('react-native/Libraries/Utilities/setAndForwardRef');
+
+const NODE_MAPPING = new Map();
+
+function listener(data) {
+  const component = NODE_MAPPING.get(data.viewTag);
+  component && component._updateFromNative(data.props);
+}
+
+function dummyListener() {
+  // empty listener we use to assign to listener properties for which animated
+  // event is used.
+}
+
+function hasAnimatedNodes(value) {
+  if (value instanceof AnimatedNode) {
+    return true;
+  }
+  if (Array.isArray(value)) {
+    return value.some((item) => hasAnimatedNodes(item));
+  }
+  if (value && typeof value === 'object') {
+    return Object.keys(value).some((key) => hasAnimatedNodes(value[key]));
+  }
+  return false;
+}
+
+function flattenArray(array) {
+  if (!Array.isArray(array)) {
+    return array;
+  }
+  const resultArr = [];
+
+  const _flattenArray = (arr) => {
+    arr.forEach((item) => {
+      if (Array.isArray(item)) {
+        _flattenArray(item);
+      } else {
+        resultArr.push(item);
+      }
+    });
+  };
+  _flattenArray(array);
+  return resultArr;
+}
+
+export default function createAnimatedComponent(Component) {
+  invariant(
+    typeof Component !== 'function' ||
+      (Component.prototype && Component.prototype.isReactComponent),
+    '`createAnimatedComponent` does not support stateless functional components; ' +
+      'use a class component instead.'
+  );
+
+  class AnimatedComponent extends React.Component {
+    _invokeAnimatedPropsCallbackOnMount = false;
+
+    constructor(props) {
+      super(props);
+      this._attachProps(this.props);
+    }
+
+    componentWillUnmount() {
+      this._detachPropUpdater();
+      this._propsAnimated && this._propsAnimated.__detach();
+      this._detachNativeEvents();
+    }
+
+    componentDidMount() {
+      if (this._invokeAnimatedPropsCallbackOnMount) {
+        this._invokeAnimatedPropsCallbackOnMount = false;
+        this._animatedPropsCallback();
+      }
+
+      this._propsAnimated && this._propsAnimated.setNativeView(this._component);
+      this._attachNativeEvents();
+      this._attachPropUpdater();
+      this._attachAnimatedStyles();
+    }
+
+    _getEventViewRef() {
+      // Make sure to get the scrollable node for components that implement
+      // `ScrollResponder.Mixin`.
+      return this._component.getScrollableNode
+        ? this._component.getScrollableNode()
+        : this._component;
+    }
+
+    _attachNativeEvents() {
+      const node = this._getEventViewRef();
+      const viewTag = findNodeHandle(node);
+
+      for (const key in this.props) {
+        const prop = this.props[key];
+        if (prop instanceof AnimatedEvent) {
+          prop.attachEvent(node, key);
+        } else if (prop instanceof WorkletEventHandler) {
+          prop.registerForEvents(viewTag, key);
+        }
+      }
+    }
+
+    _detachNativeEvents() {
+      const node = this._getEventViewRef();
+
+      for (const key in this.props) {
+        const prop = this.props[key];
+        if (prop instanceof AnimatedEvent) {
+          prop.detachEvent(node, key);
+        } else if (prop instanceof WorkletEventHandler) {
+          prop.unregisterFromEvents();
+        }
+      }
+    }
+
+    _reattachNativeEvents(prevProps) {
+      const node = this._getEventViewRef();
+      const attached = new Set();
+      const nextEvts = new Set();
+      let viewTag;
+
+      for (const key in this.props) {
+        const prop = this.props[key];
+        if (prop instanceof AnimatedEvent) {
+          nextEvts.add(prop.__nodeID);
+        } else if (
+          prop instanceof WorkletEventHandler &&
+          viewTag === undefined
+        ) {
+          viewTag = prop.viewTag;
+        }
+      }
+      for (const key in prevProps) {
+        const prop = this.props[key];
+        if (prop instanceof AnimatedEvent) {
+          if (!nextEvts.has(prop.__nodeID)) {
+            // event was in prev props but not in current props, we detach
+            prop.detachEvent(node, key);
+          } else {
+            // event was in prev and is still in current props
+            attached.add(prop.__nodeID);
+          }
+        } else if (prop instanceof WorkletEventHandler && prop.reattachNeeded) {
+          prop.unregisterFromEvents();
+        }
+      }
+
+      for (const key in this.props) {
+        const prop = this.props[key];
+        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {
+          // not yet attached
+          prop.attachEvent(node, key);
+        } else if (prop instanceof WorkletEventHandler && prop.reattachNeeded) {
+          prop.registerForEvents(viewTag, key);
+          prop.reattachNeeded = false;
+        }
+      }
+    }
+
+    // The system is best designed when setNativeProps is implemented. It is
+    // able to avoid re-rendering and directly set the attributes that changed.
+    // However, setNativeProps can only be implemented on native components
+    // If you want to animate a composite component, you need to re-render it.
+    // In this case, we have a fallback that uses forceUpdate.
+    _animatedPropsCallback = () => {
+      if (this._component == null) {
+        // AnimatedProps is created in will-mount because it's used in render.
+        // But this callback may be invoked before mount in async mode,
+        // In which case we should defer the setNativeProps() call.
+        // React may throw away uncommitted work in async mode,
+        // So a deferred call won't always be invoked.
+        this._invokeAnimatedPropsCallbackOnMount = true;
+      } else if (typeof this._component.setNativeProps !== 'function') {
+        this.forceUpdate();
+      } else {
+        this._component.setNativeProps(this._propsAnimated.__getValue());
+      }
+    };
+
+    _attachProps(nextProps) {
+      const oldPropsAnimated = this._propsAnimated;
+
+      this._propsAnimated = createOrReusePropsNode(
+        nextProps,
+        this._animatedPropsCallback,
+        oldPropsAnimated
+      );
+      // If prop node has been reused we don't need to call into "__detach"
+      if (oldPropsAnimated !== this._propsAnimated) {
+        // When you call detach, it removes the element from the parent list
+        // of children. If it goes to 0, then the parent also detaches itself
+        // and so on.
+        // An optimization is to attach the new elements and THEN detach the old
+        // ones instead of detaching and THEN attaching.
+        // This way the intermediate state isn't to go to 0 and trigger
+        // this expensive recursive detaching to then re-attach everything on
+        // the very next operation.
+        oldPropsAnimated && oldPropsAnimated.__detach();
+      }
+    }
+
+    _updateFromNative(props) {
+      this._component.setNativeProps(props);
+    }
+
+    _attachPropUpdater() {
+      const viewTag = findNodeHandle(this);
+      NODE_MAPPING.set(viewTag, this);
+      if (NODE_MAPPING.size === 1) {
+        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);
+      }
+    }
+
+    _attachAnimatedStyles() {
+      let styles = Array.isArray(this.props.style)
+        ? this.props.style
+        : [this.props.style];
+      styles = flattenArray(styles);
+      const viewTag = findNodeHandle(this);
+      styles.forEach((style) => {
+        if (style && style.viewTag !== undefined) {
+          style.viewTag.value = viewTag;
+        }
+      });
+      // attach animatedProps property
+      if (this.props.animatedProps) {
+        this.props.animatedProps.viewTag.value = viewTag;
+      }
+    }
+
+    _detachPropUpdater() {
+      const viewTag = findNodeHandle(this);
+      NODE_MAPPING.delete(viewTag);
+      if (NODE_MAPPING.size === 0) {
+        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');
+      }
+    }
+
+    componentDidUpdate(prevProps) {
+      this._attachProps(this.props);
+      this._reattachNativeEvents(prevProps);
+
+      this._propsAnimated && this._propsAnimated.setNativeView(this._component);
+    }
+
+    _setComponentRef = setAndForwardRef({
+      getForwardedRef: () => this.props.forwardedRef,
+      setLocalRef: (ref) => {
+        if (ref !== this._component) {
+          this._component = ref;
+        }
+
+        // TODO: Delete this after React Native also deletes this deprecation helper.
+        if (ref != null && ref.getNode == null) {
+          ref.getNode = () => {
+            console.warn(
+              '%s: Calling %s on the ref of an Animated component ' +
+                'is no longer necessary. You can now directly use the ref ' +
+                'instead. This method will be removed in a future release.',
+              ref.constructor.name ?? '<<anonymous>>',
+              'getNode()'
+            );
+            return ref;
+          };
+        }
+      },
+    });
+
+    _filterNonAnimatedStyle(inputStyle) {
+      const style = {};
+      for (const key in inputStyle) {
+        const value = inputStyle[key];
+        if (!hasAnimatedNodes(value)) {
+          style[key] = value;
+        } else if (value instanceof AnimatedValue) {
+          // if any style in animated component is set directly to the `Value` we set those styles to the first value of `Value` node in order
+          // to avoid flash of default styles when `Value` is being asynchrounously sent via bridge and initialized in the native side.
+          style[key] = value._startingValue;
+        }
+      }
+      return style;
+    }
+
+    _filterNonAnimatedProps(inputProps) {
+      const props = {};
+      for (const key in inputProps) {
+        const value = inputProps[key];
+        if (key === 'style') {
+          const styles = Array.isArray(value) ? value : [value];
+          const processedStyle = styles.map((style) => {
+            if (style && style.viewTag) {
+              // this is how we recognize styles returned by useAnimatedStyle
+              if (style.viewRef.current === null) {
+                style.viewRef.current = this;
+              }
+              return style.initial;
+            } else {
+              return style;
+            }
+          });
+          props[key] = this._filterNonAnimatedStyle(
+            StyleSheet.flatten(processedStyle)
+          );
+        } else if (key === 'animatedProps') {
+          Object.keys(value.initial).forEach((key) => {
+            props[key] = value.initial[key];
+          });
+        } else if (value instanceof AnimatedEvent) {
+          // we cannot filter out event listeners completely as some components
+          // rely on having a callback registered in order to generate events
+          // alltogether. Therefore we provide a dummy callback here to allow
+          // native event dispatcher to hijack events.
+          props[key] = dummyListener;
+        } else if (value instanceof WorkletEventHandler) {
+          if (value.eventNames.length > 0) {
+            value.eventNames.forEach((eventName) => {
+              props[eventName] = value.listeners
+                ? value.listeners[eventName]
+                : dummyListener;
+            });
+          } else {
+            props[key] = dummyListener;
+          }
+        } else if (!(value instanceof AnimatedNode)) {
+          props[key] = value;
+        } else if (value instanceof AnimatedValue) {
+          // if any prop in animated component is set directly to the `Value` we set those props to the first value of `Value` node in order
+          // to avoid default values for a short moment when `Value` is being asynchrounously sent via bridge and initialized in the native side.
+          props[key] = value._startingValue;
+        }
+      }
+      return props;
+    }
+
+    render() {
+      const props = this._filterNonAnimatedProps(this.props);
+      const platformProps = Platform.select({
+        web: {},
+        default: { collapsable: false },
+      });
+      return (
+        <Component {...props} ref={this._setComponentRef} {...platformProps} />
+      );
+    }
+  }
+
+  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName ||
+    Component.name ||
+    'Component'})`;
+
+  return React.forwardRef(function AnimatedComponentWrapper(props, ref) {
+    return (
+      <AnimatedComponent
+        {...props}
+        {...(ref == null ? null : { forwardedRef: ref })}
+      />
+    );
+  });
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/__mocks__/evaluateOnce.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/__mocks__/evaluateOnce.js
new file mode 100644
index 0000000..0e41fc4
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/__mocks__/evaluateOnce.js
@@ -0,0 +1,14 @@
+import { always } from '../../base';
+export function evaluateOnce(node, children = [], callback) {
+  if (!Array.isArray(children)) {
+    children = [children];
+  }
+  const alwaysNode = always(node);
+  for (let i = 0; i < children.length; i++) {
+    alwaysNode.__addChild(children[i]);
+  }
+  for (let i = 0; i < children.length; i++) {
+    alwaysNode.__removeChild(children[i]);
+  }
+  callback && callback();
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/__snapshots__/interpolate.test.js.snap b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/__snapshots__/interpolate.test.js.snap
new file mode 100644
index 0000000..765017f
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/__snapshots__/interpolate.test.js.snap
@@ -0,0 +1,13 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`throws if inputRange and outputRange are not the same length 1`] = `"inputRange and outputRange must be the same length."`;
+
+exports[`throws if inputRange is not monotonically non-decreasing 1`] = `"inputRange must be monotonically non-decreasing. (0,1,0)"`;
+
+exports[`throws if inputRange or outputRange contains an invalid value 1`] = `"inputRange cannot include Infinity. (0,1,Infinity)"`;
+
+exports[`throws if inputRange or outputRange contains an invalid value 2`] = `"outputRange cannot include NaN. (0,1,NaN)"`;
+
+exports[`throws if inputRange or outputRange does not contain at least 2 elements 1`] = `"inputRange must have at least 2 elements. (0)"`;
+
+exports[`throws if inputRange or outputRange does not contain at least 2 elements 2`] = `"outputRange must have at least 2 elements. (0)"`;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/acc.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/acc.js
new file mode 100644
index 0000000..e065948
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/acc.js
@@ -0,0 +1,11 @@
+import { set, add, proc } from '../base';
+import AnimatedValue from '../core/InternalAnimatedValue';
+
+const procAcc = proc(function(v, acc) {
+  return set(acc, add(acc, v));
+});
+
+export default function acc(v) {
+  const acc = new AnimatedValue(0);
+  return procAcc(v, acc);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/color.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/color.js
new file mode 100644
index 0000000..5724d70
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/color.js
@@ -0,0 +1,47 @@
+import { Platform } from 'react-native';
+
+import {
+  add,
+  cond,
+  concat,
+  lessThan,
+  multiply,
+  round,
+  sub,
+  proc,
+} from '../base';
+import AnimatedNode from '../core/AnimatedNode';
+
+const procColor = proc(function(r, g, b, a) {
+  const color = add(
+    multiply(a, 1 << 24),
+    multiply(round(r), 1 << 16),
+    multiply(round(g), 1 << 8),
+    round(b)
+  );
+
+  if (Platform.OS === 'android') {
+    // on Android color is represented as signed 32 bit int
+    return cond(
+      lessThan(color, (1 << 31) >>> 0),
+      color,
+      sub(color, Math.pow(2, 32))
+    );
+  }
+  return color;
+});
+
+export default function color(r, g, b, a = 1) {
+  if (Platform.OS === 'web') {
+    // doesn't support bit shifting
+    return concat('rgba(', r, ',', g, ',', b, ',', a, ')');
+  }
+
+  if (a instanceof AnimatedNode) {
+    a = round(multiply(a, 255));
+  } else {
+    a = Math.round(a * 255);
+  }
+
+  return procColor(r, g, b, a);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/diff.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/diff.js
new file mode 100644
index 0000000..c3d65fa
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/diff.js
@@ -0,0 +1,16 @@
+import { cond, block, defined, sub, set, proc } from '../base';
+import AnimatedValue from '../core/InternalAnimatedValue';
+
+const procDiff = proc(function(v, stash, prev) {
+  return block([
+    set(stash, cond(defined(prev), sub(v, prev), 0)),
+    set(prev, v),
+    stash,
+  ]);
+});
+
+export default function diff(v) {
+  const stash = new AnimatedValue(0);
+  const prev = new AnimatedValue();
+  return procDiff(v, stash, prev);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/diffClamp.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/diffClamp.js
new file mode 100644
index 0000000..46ae931
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/diffClamp.js
@@ -0,0 +1,11 @@
+import { cond, defined, set, add, min, max } from '../base';
+import AnimatedValue from '../core/InternalAnimatedValue';
+import diff from './diff';
+
+export default function diffClamp(a, minVal, maxVal) {
+  const value = new AnimatedValue();
+  return set(
+    value,
+    min(max(add(cond(defined(value), value, a), diff(a)), minVal), maxVal)
+  );
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/evaluateOnce.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/evaluateOnce.js
new file mode 100644
index 0000000..8e81b37
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/evaluateOnce.js
@@ -0,0 +1,35 @@
+import AnimatedValue from '../core/InternalAnimatedValue';
+import { createAnimatedSet as set } from '../core/AnimatedSet';
+import { createAnimatedCall as call } from '../core/AnimatedCall';
+import { createAnimatedAlways as always } from '../core/AnimatedAlways';
+import { createAnimatedCond as cond } from '../core/AnimatedCond';
+
+/**
+ * evaluate given node and notify children
+ * @param node - node to be evaluated
+ * @param input - nodes (or one node) representing values which states input for node.
+ * @param callback - after callback
+ */
+
+export function evaluateOnce(node, input = [], callback) {
+  if (!Array.isArray(input)) {
+    input = [input];
+  }
+  const done = new AnimatedValue(0);
+  const evalNode = cond(
+    done,
+    0,
+    call([node, set(done, 1)], () => {
+      callback && callback();
+      for (let i = 0; i < input.length; i++) {
+        input[i].__removeChild(alwaysNode);
+        alwaysNode.__detach();
+      }
+    })
+  );
+  const alwaysNode = always(evalNode);
+  for (let i = 0; i < input.length; i++) {
+    input[i].__addChild(alwaysNode);
+    alwaysNode.__attach();
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/index.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/index.js
new file mode 100644
index 0000000..e6e1541
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/index.js
@@ -0,0 +1,8 @@
+export { default as acc } from './acc';
+export { default as color } from './color';
+export { default as diff } from './diff';
+export { default as diffClamp } from './diffClamp';
+export { default as interpolateNode, Extrapolate } from './interpolate';
+export { default as interpolateColors } from './interpolateColors';
+export { default as onChange } from './onChange';
+export { default as useCode } from './useCode';
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolate.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolate.js
new file mode 100644
index 0000000..09341d9
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolate.js
@@ -0,0 +1,152 @@
+import {
+  lessThan,
+  multiply,
+  sub,
+  add,
+  divide,
+  greaterThan,
+  lessOrEq,
+  eq,
+} from '../operators';
+import invariant from 'fbjs/lib/invariant';
+
+import AnimatedNode from '../core/AnimatedNode';
+import { createAnimatedCond as cond } from '../core/AnimatedCond';
+import { createAnimatedFunction as proc } from '../core/AnimatedFunction';
+
+const interpolateInternalSingleProc = proc(function(
+  value,
+  inS,
+  inE,
+  outS,
+  outE
+) {
+  const progress = divide(sub(value, inS), sub(inE, inS));
+  // logic below was made in order to provide a compatibility witn an Animated API
+  const resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));
+  const result = cond(
+    eq(inS, inE),
+    cond(lessOrEq(value, inS), outS, outE),
+    resultForNonZeroRange
+  );
+  return result;
+});
+
+function interpolateInternalSingle(value, inputRange, outputRange, offset) {
+  const inS = inputRange[offset];
+  const inE = inputRange[offset + 1];
+  const outS = outputRange[offset];
+  const outE = outputRange[offset + 1];
+  return interpolateInternalSingleProc(value, inS, inE, outS, outE);
+}
+
+function interpolateInternal(value, inputRange, outputRange, offset = 0) {
+  if (inputRange.length - offset === 2) {
+    return interpolateInternalSingle(value, inputRange, outputRange, offset);
+  }
+  return cond(
+    lessThan(value, inputRange[offset + 1]),
+    interpolateInternalSingle(value, inputRange, outputRange, offset),
+    interpolateInternal(value, inputRange, outputRange, offset + 1)
+  );
+}
+
+export const Extrapolate = {
+  EXTEND: 'extend',
+  CLAMP: 'clamp',
+  IDENTITY: 'identity',
+};
+
+function checkNonDecreasing(name, arr) {
+  for (let i = 1; i < arr.length; ++i) {
+    // We can't validate animated nodes in JS.
+    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode)
+      continue;
+    invariant(
+      arr[i] >= arr[i - 1],
+      '%s must be monotonically non-decreasing. (%s)',
+      name,
+      arr
+    );
+  }
+}
+
+function checkMinElements(name, arr) {
+  invariant(
+    arr.length >= 2,
+    '%s must have at least 2 elements. (%s)',
+    name,
+    arr
+  );
+}
+
+function checkValidNumbers(name, arr) {
+  for (let i = 0; i < arr.length; i++) {
+    // We can't validate animated nodes in JS.
+    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;
+    invariant(
+      Number.isFinite(arr[i]),
+      '%s cannot include %s. (%s)',
+      name,
+      arr[i],
+      arr
+    );
+  }
+}
+
+function convertToRadians(outputRange) {
+  for (const [i, value] of outputRange.entries()) {
+    if (typeof value === 'string' && value.endsWith('deg')) {
+      outputRange[i] = parseFloat(value) * (Math.PI / 180);
+    }
+  }
+}
+
+export default function interpolate(value, config) {
+  const {
+    inputRange,
+    outputRange,
+    extrapolate = Extrapolate.EXTEND,
+    extrapolateLeft,
+    extrapolateRight,
+  } = config;
+
+  checkMinElements('inputRange', inputRange);
+  checkValidNumbers('inputRange', inputRange);
+  checkMinElements('outputRange', outputRange);
+  checkValidNumbers('outputRange', outputRange);
+  checkNonDecreasing('inputRange', inputRange);
+  invariant(
+    inputRange.length === outputRange.length,
+    'inputRange and outputRange must be the same length.'
+  );
+
+  convertToRadians(outputRange);
+  const left = extrapolateLeft || extrapolate;
+  const right = extrapolateRight || extrapolate;
+  let output = interpolateInternal(value, inputRange, outputRange);
+
+  if (left === Extrapolate.EXTEND) {
+  } else if (left === Extrapolate.CLAMP) {
+    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);
+  } else if (left === Extrapolate.IDENTITY) {
+    output = cond(lessThan(value, inputRange[0]), value, output);
+  }
+
+  if (right === Extrapolate.EXTEND) {
+  } else if (right === Extrapolate.CLAMP) {
+    output = cond(
+      greaterThan(value, inputRange[inputRange.length - 1]),
+      outputRange[outputRange.length - 1],
+      output
+    );
+  } else if (right === Extrapolate.IDENTITY) {
+    output = cond(
+      greaterThan(value, inputRange[inputRange.length - 1]),
+      value,
+      output
+    );
+  }
+
+  return output;
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolate.test.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolate.test.js
new file mode 100644
index 0000000..7972d1b
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolate.test.js
@@ -0,0 +1,55 @@
+import interpolate from './interpolate';
+import AnimatedValue from '../core/AnimatedValue';
+
+jest.mock('../ReanimatedEventEmitter');
+jest.mock('../ReanimatedModule');
+
+const value = new AnimatedValue(0);
+
+it('throws if inputRange or outputRange does not contain at least 2 elements', () => {
+  expect(() =>
+    interpolate(value, {
+      inputRange: [0],
+      outputRange: [0, 1],
+    })
+  ).toThrowErrorMatchingSnapshot();
+  expect(() =>
+    interpolate(value, {
+      inputRange: [0, 1],
+      outputRange: [0],
+    })
+  ).toThrowErrorMatchingSnapshot();
+});
+
+it('throws if inputRange and outputRange are not the same length', () => {
+  expect(() =>
+    interpolate(value, {
+      inputRange: [0, 1, 2],
+      outputRange: [0, 1, 2, 3],
+    })
+  ).toThrowErrorMatchingSnapshot();
+});
+
+it('throws if inputRange or outputRange contains an invalid value', () => {
+  expect(() =>
+    interpolate(value, {
+      inputRange: [0, 1, Infinity],
+      outputRange: [0, 1, 2],
+    })
+  ).toThrowErrorMatchingSnapshot();
+  expect(() =>
+    interpolate(value, {
+      inputRange: [0, 1, 2],
+      outputRange: [0, 1, NaN],
+    })
+  ).toThrowErrorMatchingSnapshot();
+});
+
+it('throws if inputRange is not monotonically non-decreasing', () => {
+  expect(() =>
+    interpolate(value, {
+      inputRange: [0, 1, 0],
+      outputRange: [0, 1, 2],
+    })
+  ).toThrowErrorMatchingSnapshot();
+});
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolateColors.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolateColors.js
new file mode 100644
index 0000000..c3855fd
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/interpolateColors.js
@@ -0,0 +1,62 @@
+import { processColor } from 'react-native';
+import { round } from '../base';
+import color from './color';
+import interpolate, { Extrapolate } from './interpolate';
+
+function red(c) {
+  return (c >> 16) & 255;
+}
+function green(c) {
+  return (c >> 8) & 255;
+}
+function blue(c) {
+  return c & 255;
+}
+function opacity(c) {
+  return ((c >> 24) & 255) / 255;
+}
+
+/**
+ * Use this if you want to interpolate an `Animated.Value` into color values.
+ *
+ * #### Why is this needed?
+ *
+ * Unfortunately, if you'll pass color values directly into the `outputRange` option
+ * of `interpolate()` function, that won't really work (at least at the moment).
+ * See https://github.com/software-mansion/react-native-reanimated/issues/181 .
+ *
+ * So, for now you can just use this helper instead.
+ */
+export default function interpolateColors(animationValue, options) {
+  const { inputRange, outputColorRange } = options;
+  const colors = outputColorRange.map(processColor);
+
+  const r = round(
+    interpolate(animationValue, {
+      inputRange,
+      outputRange: colors.map(red),
+      extrapolate: Extrapolate.CLAMP,
+    })
+  );
+  const g = round(
+    interpolate(animationValue, {
+      inputRange,
+      outputRange: colors.map(green),
+      extrapolate: Extrapolate.CLAMP,
+    })
+  );
+  const b = round(
+    interpolate(animationValue, {
+      inputRange,
+      outputRange: colors.map(blue),
+      extrapolate: Extrapolate.CLAMP,
+    })
+  );
+  const a = interpolate(animationValue, {
+    inputRange,
+    outputRange: colors.map(opacity),
+    extrapolate: Extrapolate.CLAMP,
+  });
+
+  return color(r, g, b, a);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/onChange.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/onChange.js
new file mode 100644
index 0000000..e39716e
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/onChange.js
@@ -0,0 +1,14 @@
+import { block, cond, defined, neq, not, set, proc } from '../base';
+import AnimatedValue from '../core/InternalAnimatedValue';
+
+const procOnChange = proc(function(value, action, prevValue) {
+  return block([
+    cond(not(defined(prevValue)), set(prevValue, value)),
+    cond(neq(value, prevValue), [set(prevValue, value), action]),
+  ]);
+});
+
+export default function onChange(value, action) {
+  const prevValue = new AnimatedValue();
+  return procOnChange(value, action, prevValue);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/derived/useCode.js b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/useCode.js
new file mode 100644
index 0000000..b3978b1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/derived/useCode.js
@@ -0,0 +1,41 @@
+import React from 'react';
+import { always, block } from '../base';
+
+/**
+ * @callback NodeFactory
+ * Function to create a node or an array of nodes.
+ * @returns {(Node[] | Node | null | undefined | Boolean)}
+ */
+
+/**
+ * React hook to run a node.
+ * @param {NodeFactory} nodeFactory Function to build the node to run.
+ * @param dependencies Array of dependencies. Refresh the node on changes.
+ */
+export default function useCode(nodeFactory, dependencies) {
+  if (!(React.useEffect instanceof Function)) return;
+
+  React.useEffect(() => {
+    // check and correct 1st parameter
+    if (!(nodeFactory instanceof Function)) {
+      console.warn(
+        'useCode() first argument should be a function that returns an animation node.'
+      );
+
+      const node = nodeFactory;
+      nodeFactory = () => node;
+    }
+
+    let node = nodeFactory();
+    if (node) {
+      // allow factory to return array
+      if (node instanceof Array) node = block(node);
+
+      const animatedAlways = always(node);
+      animatedAlways.__attach();
+
+      // return undo function
+      return () => animatedAlways.__detach();
+    }
+  }, dependencies);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/operators.js b/node_modules/react-native-reanimated/react-native-reanimated/src/operators.js
new file mode 100644
index 0000000..19e6104
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/operators.js
@@ -0,0 +1,35 @@
+import { createAnimatedOperator } from './core/AnimatedOperator';
+
+const operator = createAnimatedOperator;
+
+export const add = operator('add');
+export const sub = operator('sub');
+export const multiply = operator('multiply');
+export const divide = operator('divide');
+export const pow = operator('pow');
+export const modulo = operator('modulo');
+export const sqrt = operator('sqrt');
+export const log = operator('log');
+export const sin = operator('sin');
+export const cos = operator('cos');
+export const exp = operator('exp');
+export const round = operator('round');
+export const lessThan = operator('lessThan');
+export const eq = operator('eq');
+export const greaterThan = operator('greaterThan');
+export const lessOrEq = operator('lessOrEq');
+export const greaterOrEq = operator('greaterOrEq');
+export const neq = operator('neq');
+export const and = operator('and');
+export const or = operator('or');
+export const defined = operator('defined');
+export const not = operator('not');
+export const tan = operator('tan');
+export const acos = operator('acos');
+export const asin = operator('asin');
+export const atan = operator('atan');
+export const abs = operator('abs');
+export const ceil = operator('ceil');
+export const floor = operator('floor');
+export const max = operator('max');
+export const min = operator('min');
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Bezier.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Bezier.js
new file mode 100644
index 0000000..84d5771
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Bezier.js
@@ -0,0 +1,156 @@
+/**
+ * https://github.com/gre/bezier-easing
+ * BezierEasing - use bezier curve for transition easing function
+ * by Gatan Renaudeau 2014 - 2015  MIT License
+ */
+
+// These values are established by empiricism with tests (tradeoff: performance VS precision)
+
+export function Bezier(mX1, mY1, mX2, mY2) {
+  'worklet';
+
+  var NEWTON_ITERATIONS = 4;
+  var NEWTON_MIN_SLOPE = 0.001;
+  var SUBDIVISION_PRECISION = 0.0000001;
+  var SUBDIVISION_MAX_ITERATIONS = 10;
+
+  var kSplineTableSize = 11;
+  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
+
+  function A(aA1, aA2) {
+    'worklet';
+    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
+  }
+  function B(aA1, aA2) {
+    'worklet';
+    return 3.0 * aA2 - 6.0 * aA1;
+  }
+  function C(aA1) {
+    'worklet';
+    return 3.0 * aA1;
+  }
+
+  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
+  function calcBezier(aT, aA1, aA2) {
+    'worklet';
+    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
+  }
+
+  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
+  function getSlope(aT, aA1, aA2) {
+    'worklet';
+    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
+  }
+
+  function binarySubdivide(aX, aA, aB, mX1, mX2) {
+    'worklet';
+    var currentX;
+    var currentT;
+    var i = 0;
+    do {
+      currentT = aA + (aB - aA) / 2.0;
+      currentX = calcBezier(currentT, mX1, mX2) - aX;
+      if (currentX > 0.0) {
+        aB = currentT;
+      } else {
+        aA = currentT;
+      }
+    } while (
+      Math.abs(currentX) > SUBDIVISION_PRECISION &&
+      ++i < SUBDIVISION_MAX_ITERATIONS
+    );
+    return currentT;
+  }
+
+  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
+    'worklet';
+    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
+      var currentSlope = getSlope(aGuessT, mX1, mX2);
+      if (currentSlope === 0.0) {
+        return aGuessT;
+      }
+      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
+      aGuessT -= currentX / currentSlope;
+    }
+    return aGuessT;
+  }
+
+  function LinearEasing(x) {
+    'worklet';
+    return x;
+  }
+
+  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
+    throw new Error('bezier x values must be in [0, 1] range');
+  }
+
+  if (mX1 === mY1 && mX2 === mY2) {
+    return LinearEasing;
+  }
+
+  // FIXME: Float32Array is not available in Hermes right now
+  //
+  // var float32ArraySupported = typeof Float32Array === 'function';
+  // const sampleValues = float32ArraySupported
+  // ? new Float32Array(kSplineTableSize)
+  // : new Array(kSplineTableSize);
+
+  // Precompute samples table
+  const sampleValues = new Array(kSplineTableSize);
+
+  for (var i = 0; i < kSplineTableSize; ++i) {
+    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
+  }
+
+  function getTForX(aX) {
+    'worklet';
+    var intervalStart = 0.0;
+    var currentSample = 1;
+    var lastSample = kSplineTableSize - 1;
+
+    for (
+      ;
+      currentSample !== lastSample && sampleValues[currentSample] <= aX;
+      ++currentSample
+    ) {
+      intervalStart += kSampleStepSize;
+    }
+    --currentSample;
+
+    // Interpolate to provide an initial guess for t
+    var dist =
+      (aX - sampleValues[currentSample]) /
+      (sampleValues[currentSample + 1] - sampleValues[currentSample]);
+    var guessForT = intervalStart + dist * kSampleStepSize;
+
+    var initialSlope = getSlope(guessForT, mX1, mX2);
+    if (initialSlope >= NEWTON_MIN_SLOPE) {
+      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
+    } else if (initialSlope === 0.0) {
+      return guessForT;
+    } else {
+      return binarySubdivide(
+        aX,
+        intervalStart,
+        intervalStart + kSampleStepSize,
+        mX1,
+        mX2
+      );
+    }
+  }
+
+  return function BezierEasing(x) {
+    'worklet';
+    if (mX1 === mY1 && mX2 === mY2) {
+      return x; // linear
+    }
+    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
+    if (x === 0) {
+      return 0;
+    }
+    if (x === 1) {
+      return 1;
+    }
+    return calcBezier(getTForX(x), mY1, mY2);
+  };
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Colors.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Colors.js
new file mode 100644
index 0000000..6172931
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Colors.js
@@ -0,0 +1,422 @@
+/* global _WORKLET */
+/**
+ * Copied from:
+ * react-native/Libraries/StyleSheet/normalizeColor.js
+ * react-native/Libraries/StyleSheet/processColor.js
+ */
+
+/* eslint no-bitwise: 0 */
+
+import { Platform } from 'react-native';
+import { makeRemote, makeShareable } from './core';
+
+// var INTEGER = '[-+]?\\d+';
+const NUMBER = '[-+]?\\d*\\.?\\d+';
+const PERCENTAGE = NUMBER + '%';
+
+function call(...args) {
+  'worklet';
+  return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
+}
+
+// matchers use RegExp objects which needs to be created separately on JS and on
+// the UI thread. We keep separate cache of Regexes for UI and JS using the below
+// objects, then pick the right cache in getMatchers() method.
+const jsCachedMatchers = {};
+const uiCachedMatchers = makeRemote({});
+
+function getMatchers() {
+  'worklet';
+  const cachedMatchers = _WORKLET ? uiCachedMatchers : jsCachedMatchers;
+  if (cachedMatchers.rgb === undefined) {
+    cachedMatchers.rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));
+    cachedMatchers.rgba = new RegExp(
+      'rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER)
+    );
+    cachedMatchers.hsl = new RegExp(
+      'hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)
+    );
+    cachedMatchers.hsla = new RegExp(
+      'hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
+    );
+    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
+    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
+    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;
+    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;
+  }
+  return cachedMatchers;
+}
+
+function hue2rgb(p, q, t) {
+  'worklet';
+  if (t < 0) {
+    t += 1;
+  }
+  if (t > 1) {
+    t -= 1;
+  }
+  if (t < 1 / 6) {
+    return p + (q - p) * 6 * t;
+  }
+  if (t < 1 / 2) {
+    return q;
+  }
+  if (t < 2 / 3) {
+    return p + (q - p) * (2 / 3 - t) * 6;
+  }
+  return p;
+}
+
+function hslToRgb(h, s, l) {
+  'worklet';
+  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
+  const p = 2 * l - q;
+  const r = hue2rgb(p, q, h + 1 / 3);
+  const g = hue2rgb(p, q, h);
+  const b = hue2rgb(p, q, h - 1 / 3);
+
+  return (
+    (Math.round(r * 255) << 24) |
+    (Math.round(g * 255) << 16) |
+    (Math.round(b * 255) << 8)
+  );
+}
+
+function parse255(str) {
+  'worklet';
+  const int = Number.parseInt(str, 10);
+  if (int < 0) {
+    return 0;
+  }
+  if (int > 255) {
+    return 255;
+  }
+  return int;
+}
+
+function parse360(str) {
+  'worklet';
+  const int = Number.parseFloat(str);
+  return (((int % 360) + 360) % 360) / 360;
+}
+
+function parse1(str) {
+  'worklet';
+  const num = Number.parseFloat(str);
+  if (num < 0) {
+    return 0;
+  }
+  if (num > 1) {
+    return 255;
+  }
+  return Math.round(num * 255);
+}
+
+function parsePercentage(str) {
+  'worklet';
+  // parseFloat conveniently ignores the final %
+  const int = Number.parseFloat(str);
+  if (int < 0) {
+    return 0;
+  }
+  if (int > 100) {
+    return 1;
+  }
+  return int / 100;
+}
+
+const names = makeShareable({
+  transparent: 0x00000000,
+
+  // http://www.w3.org/TR/css3-color/#svg-color
+  aliceblue: 0xf0f8ffff,
+  antiquewhite: 0xfaebd7ff,
+  aqua: 0x00ffffff,
+  aquamarine: 0x7fffd4ff,
+  azure: 0xf0ffffff,
+  beige: 0xf5f5dcff,
+  bisque: 0xffe4c4ff,
+  black: 0x000000ff,
+  blanchedalmond: 0xffebcdff,
+  blue: 0x0000ffff,
+  blueviolet: 0x8a2be2ff,
+  brown: 0xa52a2aff,
+  burlywood: 0xdeb887ff,
+  burntsienna: 0xea7e5dff,
+  cadetblue: 0x5f9ea0ff,
+  chartreuse: 0x7fff00ff,
+  chocolate: 0xd2691eff,
+  coral: 0xff7f50ff,
+  cornflowerblue: 0x6495edff,
+  cornsilk: 0xfff8dcff,
+  crimson: 0xdc143cff,
+  cyan: 0x00ffffff,
+  darkblue: 0x00008bff,
+  darkcyan: 0x008b8bff,
+  darkgoldenrod: 0xb8860bff,
+  darkgray: 0xa9a9a9ff,
+  darkgreen: 0x006400ff,
+  darkgrey: 0xa9a9a9ff,
+  darkkhaki: 0xbdb76bff,
+  darkmagenta: 0x8b008bff,
+  darkolivegreen: 0x556b2fff,
+  darkorange: 0xff8c00ff,
+  darkorchid: 0x9932ccff,
+  darkred: 0x8b0000ff,
+  darksalmon: 0xe9967aff,
+  darkseagreen: 0x8fbc8fff,
+  darkslateblue: 0x483d8bff,
+  darkslategray: 0x2f4f4fff,
+  darkslategrey: 0x2f4f4fff,
+  darkturquoise: 0x00ced1ff,
+  darkviolet: 0x9400d3ff,
+  deeppink: 0xff1493ff,
+  deepskyblue: 0x00bfffff,
+  dimgray: 0x696969ff,
+  dimgrey: 0x696969ff,
+  dodgerblue: 0x1e90ffff,
+  firebrick: 0xb22222ff,
+  floralwhite: 0xfffaf0ff,
+  forestgreen: 0x228b22ff,
+  fuchsia: 0xff00ffff,
+  gainsboro: 0xdcdcdcff,
+  ghostwhite: 0xf8f8ffff,
+  gold: 0xffd700ff,
+  goldenrod: 0xdaa520ff,
+  gray: 0x808080ff,
+  green: 0x008000ff,
+  greenyellow: 0xadff2fff,
+  grey: 0x808080ff,
+  honeydew: 0xf0fff0ff,
+  hotpink: 0xff69b4ff,
+  indianred: 0xcd5c5cff,
+  indigo: 0x4b0082ff,
+  ivory: 0xfffff0ff,
+  khaki: 0xf0e68cff,
+  lavender: 0xe6e6faff,
+  lavenderblush: 0xfff0f5ff,
+  lawngreen: 0x7cfc00ff,
+  lemonchiffon: 0xfffacdff,
+  lightblue: 0xadd8e6ff,
+  lightcoral: 0xf08080ff,
+  lightcyan: 0xe0ffffff,
+  lightgoldenrodyellow: 0xfafad2ff,
+  lightgray: 0xd3d3d3ff,
+  lightgreen: 0x90ee90ff,
+  lightgrey: 0xd3d3d3ff,
+  lightpink: 0xffb6c1ff,
+  lightsalmon: 0xffa07aff,
+  lightseagreen: 0x20b2aaff,
+  lightskyblue: 0x87cefaff,
+  lightslategray: 0x778899ff,
+  lightslategrey: 0x778899ff,
+  lightsteelblue: 0xb0c4deff,
+  lightyellow: 0xffffe0ff,
+  lime: 0x00ff00ff,
+  limegreen: 0x32cd32ff,
+  linen: 0xfaf0e6ff,
+  magenta: 0xff00ffff,
+  maroon: 0x800000ff,
+  mediumaquamarine: 0x66cdaaff,
+  mediumblue: 0x0000cdff,
+  mediumorchid: 0xba55d3ff,
+  mediumpurple: 0x9370dbff,
+  mediumseagreen: 0x3cb371ff,
+  mediumslateblue: 0x7b68eeff,
+  mediumspringgreen: 0x00fa9aff,
+  mediumturquoise: 0x48d1ccff,
+  mediumvioletred: 0xc71585ff,
+  midnightblue: 0x191970ff,
+  mintcream: 0xf5fffaff,
+  mistyrose: 0xffe4e1ff,
+  moccasin: 0xffe4b5ff,
+  navajowhite: 0xffdeadff,
+  navy: 0x000080ff,
+  oldlace: 0xfdf5e6ff,
+  olive: 0x808000ff,
+  olivedrab: 0x6b8e23ff,
+  orange: 0xffa500ff,
+  orangered: 0xff4500ff,
+  orchid: 0xda70d6ff,
+  palegoldenrod: 0xeee8aaff,
+  palegreen: 0x98fb98ff,
+  paleturquoise: 0xafeeeeff,
+  palevioletred: 0xdb7093ff,
+  papayawhip: 0xffefd5ff,
+  peachpuff: 0xffdab9ff,
+  peru: 0xcd853fff,
+  pink: 0xffc0cbff,
+  plum: 0xdda0ddff,
+  powderblue: 0xb0e0e6ff,
+  purple: 0x800080ff,
+  rebeccapurple: 0x663399ff,
+  red: 0xff0000ff,
+  rosybrown: 0xbc8f8fff,
+  royalblue: 0x4169e1ff,
+  saddlebrown: 0x8b4513ff,
+  salmon: 0xfa8072ff,
+  sandybrown: 0xf4a460ff,
+  seagreen: 0x2e8b57ff,
+  seashell: 0xfff5eeff,
+  sienna: 0xa0522dff,
+  silver: 0xc0c0c0ff,
+  skyblue: 0x87ceebff,
+  slateblue: 0x6a5acdff,
+  slategray: 0x708090ff,
+  slategrey: 0x708090ff,
+  snow: 0xfffafaff,
+  springgreen: 0x00ff7fff,
+  steelblue: 0x4682b4ff,
+  tan: 0xd2b48cff,
+  teal: 0x008080ff,
+  thistle: 0xd8bfd8ff,
+  tomato: 0xff6347ff,
+  turquoise: 0x40e0d0ff,
+  violet: 0xee82eeff,
+  wheat: 0xf5deb3ff,
+  white: 0xffffffff,
+  whitesmoke: 0xf5f5f5ff,
+  yellow: 0xffff00ff,
+  yellowgreen: 0x9acd32ff,
+});
+
+function normalizeColor(color) {
+  'worklet';
+
+  const matchers = getMatchers();
+
+  let match;
+
+  if (typeof color === 'number') {
+    if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
+      return color;
+    }
+    return null;
+  }
+
+  if (typeof color !== 'string') {
+    return null;
+  }
+
+  // Ordered based on occurrences on Facebook codebase
+  if ((match = matchers.hex6.exec(color))) {
+    return Number.parseInt(match[1] + 'ff', 16) >>> 0;
+  }
+
+  if (names[color] !== undefined) {
+    return names[color];
+  }
+
+  if ((match = matchers.rgb.exec(color))) {
+    return (
+      // b
+      ((parse255(match[1]) << 24) | // r
+      (parse255(match[2]) << 16) | // g
+        (parse255(match[3]) << 8) |
+        0x000000ff) >>> // a
+      0
+    );
+  }
+
+  if ((match = matchers.rgba.exec(color))) {
+    return (
+      // b
+      ((parse255(match[1]) << 24) | // r
+      (parse255(match[2]) << 16) | // g
+        (parse255(match[3]) << 8) |
+        parse1(match[4])) >>> // a
+      0
+    );
+  }
+
+  if ((match = matchers.hex3.exec(color))) {
+    return (
+      Number.parseInt(
+        match[1] +
+        match[1] + // r
+        match[2] +
+        match[2] + // g
+        match[3] +
+        match[3] + // b
+          'ff', // a
+        16
+      ) >>> 0
+    );
+  }
+
+  // https://drafts.csswg.org/css-color-4/#hex-notation
+  if ((match = matchers.hex8.exec(color))) {
+    return Number.parseInt(match[1], 16) >>> 0;
+  }
+
+  if ((match = matchers.hex4.exec(color))) {
+    return (
+      Number.parseInt(
+        match[1] +
+        match[1] + // r
+        match[2] +
+        match[2] + // g
+        match[3] +
+        match[3] + // b
+          match[4] +
+          match[4], // a
+        16
+      ) >>> 0
+    );
+  }
+
+  if ((match = matchers.hsl.exec(color))) {
+    return (
+      (hslToRgb(
+        parse360(match[1]), // h
+        parsePercentage(match[2]), // s
+        parsePercentage(match[3]) // l
+      ) |
+        0x000000ff) >>> // a
+      0
+    );
+  }
+
+  if ((match = matchers.hsla.exec(color))) {
+    return (
+      (hslToRgb(
+        parse360(match[1]), // h
+        parsePercentage(match[2]), // s
+        parsePercentage(match[3]) // l
+      ) |
+        parse1(match[4])) >>> // a
+      0
+    );
+  }
+
+  return null;
+}
+
+export default function processColor(color) {
+  'worklet';
+  if (color === null || color === undefined || typeof color === 'number') {
+    return color;
+  }
+
+  let normalizedColor = normalizeColor(color);
+
+  if (normalizedColor === null || normalizedColor === undefined) {
+    return undefined;
+  }
+
+  if (typeof normalizedColor !== 'number') {
+    return null;
+  }
+
+  normalizedColor = ((normalizedColor << 24) | (normalizedColor >>> 8)) >>> 0;
+
+  if (Platform.OS === 'android') {
+    // Android use 32 bit *signed* integer to represent the color
+    // We utilize the fact that bitwise operations in JS also operates on
+    // signed 32 bit integers, so that we can use those to convert from
+    // *unsigned* to *signed* 32bit int that way.
+    normalizedColor = normalizedColor | 0x0;
+  }
+
+  return normalizedColor;
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Easing.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Easing.js
new file mode 100644
index 0000000..0723069
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Easing.js
@@ -0,0 +1,254 @@
+import { Bezier } from './Bezier';
+
+/**
+ * The `Easing` module implements common easing functions. This module is used
+ * by [Animate.timing()](docs/animate.html#timing) to convey physically
+ * believable motion in animations.
+ *
+ * You can find a visualization of some common easing functions at
+ * http://easings.net/
+ *
+ * ### Predefined animations
+ *
+ * The `Easing` module provides several predefined animations through the
+ * following methods:
+ *
+ * - [`back`](docs/easing.html#back) provides a simple animation where the
+ *   object goes slightly back before moving forward
+ * - [`bounce`](docs/easing.html#bounce) provides a bouncing animation
+ * - [`ease`](docs/easing.html#ease) provides a simple inertial animation
+ * - [`elastic`](docs/easing.html#elastic) provides a simple spring interaction
+ *
+ * ### Standard functions
+ *
+ * Three standard easing functions are provided:
+ *
+ * - [`linear`](docs/easing.html#linear)
+ * - [`quad`](docs/easing.html#quad)
+ * - [`cubic`](docs/easing.html#cubic)
+ *
+ * The [`poly`](docs/easing.html#poly) function can be used to implement
+ * quartic, quintic, and other higher power functions.
+ *
+ * ### Additional functions
+ *
+ * Additional mathematical functions are provided by the following methods:
+ *
+ * - [`bezier`](docs/easing.html#bezier) provides a cubic bezier curve
+ * - [`circle`](docs/easing.html#circle) provides a circular function
+ * - [`sin`](docs/easing.html#sin) provides a sinusoidal function
+ * - [`exp`](docs/easing.html#exp) provides an exponential function
+ *
+ * The following helpers are used to modify other easing functions.
+ *
+ * - [`in`](docs/easing.html#in) runs an easing function forwards
+ * - [`inOut`](docs/easing.html#inout) makes any easing function symmetrical
+ * - [`out`](docs/easing.html#out) runs an easing function backwards
+ */
+
+/**
+ * A linear function, `f(t) = t`. Position correlates to elapsed time one to
+ * one.
+ *
+ * http://cubic-bezier.com/#0,0,1,1
+ */
+function linear(t) {
+  'worklet';
+  return t;
+}
+
+/**
+ * A simple inertial interaction, similar to an object slowly accelerating to
+ * speed.
+ *
+ * http://cubic-bezier.com/#.42,0,1,1
+ */
+function ease(t) {
+  'worklet';
+  return Bezier(0.42, 0, 1, 1)(t);
+}
+
+/**
+ * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
+ * time.
+ *
+ * http://easings.net/#easeInQuad
+ */
+function quad(t) {
+  'worklet';
+  return t * t;
+}
+
+/**
+ * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
+ * time.
+ *
+ * http://easings.net/#easeInCubic
+ */
+function cubic(t) {
+  'worklet';
+  return t * t * t;
+}
+
+/**
+ * A power function. Position is equal to the Nth power of elapsed time.
+ *
+ * n = 4: http://easings.net/#easeInQuart
+ * n = 5: http://easings.net/#easeInQuint
+ */
+function poly(n) {
+  'worklet';
+  return (t) => Math.pow(t, n);
+}
+
+/**
+ * A sinusoidal function.
+ *
+ * http://easings.net/#easeInSine
+ */
+function sin(t) {
+  'worklet';
+  return 1 - Math.cos((t * Math.PI) / 2);
+}
+
+/**
+ * A circular function.
+ *
+ * http://easings.net/#easeInCirc
+ */
+function circle(t) {
+  'worklet';
+  return 1 - Math.sqrt(1 - t * t);
+}
+
+/**
+ * An exponential function.
+ *
+ * http://easings.net/#easeInExpo
+ */
+function exp(t) {
+  'worklet';
+  return Math.pow(2, 10 * (t - 1));
+}
+
+/**
+ * A simple elastic interaction, similar to a spring oscillating back and
+ * forth.
+ *
+ * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
+ * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
+ * times.
+ *
+ * http://easings.net/#easeInElastic
+ */
+function elastic(bounciness = 1) {
+  'worklet';
+  const p = bounciness * Math.PI;
+  return (t) => {
+    'worklet';
+    return 1 - Math.pow(Math.cos((t * Math.PI) / 2), 3) * Math.cos(t * p);
+  };
+}
+
+/**
+ * Use with `Animated.parallel()` to create a simple effect where the object
+ * animates back slightly as the animation starts.
+ *
+ * Wolfram Plot:
+ *
+ * - http://tiny.cc/back_default (s = 1.70158, default)
+ */
+function back(s = 1.70158) {
+  'worklet';
+  return (t) => t * t * ((s + 1) * t - s);
+}
+
+/**
+ * Provides a simple bouncing effect.
+ *
+ * http://easings.net/#easeInBounce
+ */
+function bounce(t) {
+  'worklet';
+  if (t < 1 / 2.75) {
+    return 7.5625 * t * t;
+  }
+
+  if (t < 2 / 2.75) {
+    const t2 = t - 1.5 / 2.75;
+    return 7.5625 * t2 * t2 + 0.75;
+  }
+
+  if (t < 2.5 / 2.75) {
+    const t2 = t - 2.25 / 2.75;
+    return 7.5625 * t2 * t2 + 0.9375;
+  }
+
+  const t2 = t - 2.625 / 2.75;
+  return 7.5625 * t2 * t2 + 0.984375;
+}
+
+/**
+ * Provides a cubic bezier curve, equivalent to CSS Transitions'
+ * `transition-timing-function`.
+ *
+ * A useful tool to visualize cubic bezier curves can be found at
+ * http://cubic-bezier.com/
+ */
+function bezier(x1, y1, x2, y2) {
+  'worklet';
+  return Bezier(x1, y1, x2, y2);
+}
+
+/**
+ * Runs an easing function forwards.
+ */
+function in_(easing) {
+  'worklet';
+  return easing;
+}
+
+/**
+ * Runs an easing function backwards.
+ */
+function out(easing) {
+  'worklet';
+  return (t) => {
+    'worklet';
+    return 1 - easing(1 - t);
+  };
+}
+
+/**
+ * Makes any easing function symmetrical. The easing function will run
+ * forwards for half of the duration, then backwards for the rest of the
+ * duration.
+ */
+function inOut(easing) {
+  'worklet';
+  return (t) => {
+    'worklet';
+    if (t < 0.5) {
+      return easing(t * 2) / 2;
+    }
+    return 1 - easing((1 - t) * 2) / 2;
+  };
+}
+
+export const NewEasing = {
+  linear,
+  ease,
+  quad,
+  cubic,
+  poly,
+  sin,
+  circle,
+  exp,
+  elastic,
+  back,
+  bounce,
+  bezier,
+  in: in_,
+  out,
+  inOut,
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Hooks.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Hooks.js
new file mode 100644
index 0000000..017f163
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/Hooks.js
@@ -0,0 +1,596 @@
+import { useEffect, useRef } from 'react';
+
+import WorkletEventHandler from './WorkletEventHandler';
+import {
+  startMapper,
+  stopMapper,
+  makeMutable,
+  makeRemote,
+  requestFrame,
+} from './core';
+import updateProps from './UpdateProps';
+import { initialUpdaterRun } from './animations';
+import { getTag } from './NativeMethods';
+import NativeReanimated from './NativeReanimated';
+import { Platform } from 'react-native';
+
+export function useSharedValue(init) {
+  const ref = useRef(null);
+  if (ref.current === null) {
+    ref.current = {
+      mutable: makeMutable(init),
+      last: init,
+    };
+  } else if (init !== ref.current.last) {
+    ref.current.last = init;
+    ref.current.mutable.value = init;
+  }
+
+  return ref.current.mutable;
+}
+
+export function useMapper(fun, inputs = [], outputs = [], dependencies = []) {
+  useEffect(() => {
+    const mapperId = startMapper(fun, inputs, outputs);
+    return () => {
+      stopMapper(mapperId);
+    };
+  }, dependencies);
+}
+
+export function useEvent(handler, eventNames = [], rebuild = false) {
+  const initRef = useRef(null);
+  if (initRef.current === null || (Platform.OS === 'web' && rebuild)) {
+    initRef.current = new WorkletEventHandler(handler, eventNames);
+  } else if (rebuild) {
+    initRef.current.updateWorklet(handler);
+  }
+  return initRef.current;
+}
+
+function prepareAnimation(animatedProp, lastAnimation, lastValue) {
+  'worklet';
+  function prepareAnimation(animatedProp, lastAnimation, lastValue) {
+    if (Array.isArray(animatedProp)) {
+      animatedProp.forEach((prop, index) =>
+        prepareAnimation(
+          prop,
+          lastAnimation && lastAnimation[index],
+          lastValue && lastValue[index]
+        )
+      );
+      return animatedProp;
+    }
+    if (typeof animatedProp === 'object' && animatedProp.animation) {
+      const animation = animatedProp;
+
+      let value = animation.current;
+      if (lastValue !== undefined) {
+        if (typeof lastValue === 'object') {
+          if (lastValue.value !== undefined) {
+            // previously it was a shared value
+            value = lastValue.value;
+          } else if (lastValue.animation !== undefined) {
+            // it was an animation before, copy its state
+            value = lastAnimation.current;
+          }
+        } else {
+          // previously it was a plan value, just set it as starting point
+          value = lastValue;
+        }
+      }
+
+      animation.callStart = (timestamp) => {
+        animation.start(animation, value, timestamp, lastAnimation);
+      };
+    } else if (typeof animatedProp === 'object') {
+      // it is an object
+      Object.keys(animatedProp).forEach((key) =>
+        prepareAnimation(
+          animatedProp[key],
+          lastAnimation && lastAnimation[key],
+          lastValue && lastValue[key]
+        )
+      );
+    }
+  }
+  return prepareAnimation(animatedProp, lastAnimation, lastValue);
+}
+
+function runAnimations(animation, timestamp, key, result) {
+  'worklet';
+  function runAnimations(animation, timestamp, key, result) {
+    if (Array.isArray(animation)) {
+      result[key] = [];
+      let allFinished = true;
+      animation.forEach((entry, index) => {
+        if (!runAnimations(entry, timestamp, index, result[key])) {
+          allFinished = false;
+        }
+      });
+      return allFinished;
+    } else if (typeof animation === 'object' && animation.animation) {
+      if (animation.callStart) {
+        animation.callStart(timestamp);
+        animation.callStart = null;
+      }
+      const finished = animation.animation(animation, timestamp);
+      animation.timestamp = timestamp;
+      if (finished) {
+        animation.finished = true;
+        animation.callback && animation.callback(true /* finished */);
+      }
+      result[key] = animation.current;
+      return finished;
+    } else if (typeof animation === 'object') {
+      result[key] = {};
+      let allFinished = true;
+      Object.keys(animation).forEach((k) => {
+        if (!runAnimations(animation[k], timestamp, k, result[key])) {
+          allFinished = false;
+        }
+      });
+      return allFinished;
+    } else {
+      result[key] = animation;
+      return true;
+    }
+  }
+  return runAnimations(animation, timestamp, key, result);
+}
+
+// TODO: recirsive worklets aren't supported yet
+function isAnimated(prop) {
+  'worklet';
+  function isAnimated(prop) {
+    if (Array.isArray(prop)) {
+      return prop.some(isAnimated);
+    }
+    if (typeof prop === 'object') {
+      if (prop.animation) {
+        return true;
+      }
+      return Object.keys(prop).some((key) => isAnimated(prop[key]));
+    }
+    return false;
+  }
+  return isAnimated(prop);
+}
+
+function styleDiff(oldStyle, newStyle) {
+  'worklet';
+  const diff = {};
+  Object.keys(oldStyle).forEach((key) => {
+    if (newStyle[key] === undefined) {
+      diff[key] = null;
+    }
+  });
+  Object.keys(newStyle).forEach((key) => {
+    const value = newStyle[key];
+    const oldValue = oldStyle[key];
+
+    if (isAnimated(value)) {
+      // do nothing
+      return;
+    }
+    if (
+      oldValue !== value &&
+      JSON.stringify(oldValue) !== JSON.stringify(value)
+    ) {
+      // I'd use deep equal here but that'd take additional work and this was easier
+      diff[key] = value;
+    }
+  });
+  return diff;
+}
+
+function styleUpdater(viewTag, updater, state, maybeViewRef) {
+  'worklet';
+  const animations = state.animations || {};
+
+  const newValues = updater() || {};
+  const oldValues = state.last;
+
+  // extract animated props
+  let hasAnimations = false;
+  Object.keys(animations).forEach((key) => {
+    const value = newValues[key];
+    if (!isAnimated(value)) {
+      delete animations[key];
+    }
+  });
+  Object.keys(newValues).forEach((key) => {
+    const value = newValues[key];
+    if (isAnimated(value)) {
+      prepareAnimation(value, animations[key], oldValues[key]);
+      animations[key] = value;
+      hasAnimations = true;
+    }
+  });
+
+  function frame(timestamp) {
+    const { animations, last, isAnimationCancelled } = state;
+    if (isAnimationCancelled) {
+      state.isAnimationRunning = false;
+      return;
+    }
+
+    const updates = {};
+    let allFinished = true;
+    Object.keys(animations).forEach((propName) => {
+      const finished = runAnimations(
+        animations[propName],
+        timestamp,
+        propName,
+        updates
+      );
+      if (finished) {
+        last[propName] = updates[propName];
+        delete animations[propName];
+      } else {
+        allFinished = false;
+      }
+    });
+
+    if (Object.keys(updates).length) {
+      updateProps(viewTag.value, updates, maybeViewRef);
+    }
+
+    if (!allFinished) {
+      requestFrame(frame);
+    } else {
+      state.isAnimationRunning = false;
+    }
+  }
+
+  if (hasAnimations) {
+    state.animations = animations;
+    if (!state.isAnimationRunning) {
+      state.isAnimationCancelled = false;
+      state.isAnimationRunning = true;
+      requestFrame(frame);
+    }
+  } else {
+    state.isAnimationCancelled = true;
+    state.animations = {};
+  }
+
+  // calculate diff
+  const diff = styleDiff(oldValues, newValues);
+  state.last = Object.assign({}, oldValues, newValues);
+
+  if (Object.keys(diff).length !== 0) {
+    updateProps(viewTag.value, diff, maybeViewRef);
+  }
+}
+
+export function useAnimatedStyle(updater, dependencies) {
+  const viewTag = useSharedValue(-1);
+  const initRef = useRef(null);
+  const inputs = Object.values(updater._closure);
+  const viewRef = useRef(null);
+
+  // build dependencies
+  if (dependencies === undefined) {
+    dependencies = [...inputs, updater.__workletHash];
+  } else {
+    dependencies.push(updater.__workletHash);
+  }
+
+  if (initRef.current === null) {
+    const initial = initialUpdaterRun(updater);
+    initRef.current = {
+      initial,
+      remoteState: makeRemote({ last: initial }),
+    };
+  }
+
+  const { remoteState, initial } = initRef.current;
+  const maybeViewRef = NativeReanimated.native ? undefined : viewRef;
+
+  useEffect(() => {
+    const fun = () => {
+      'worklet';
+      styleUpdater(viewTag, updater, remoteState, maybeViewRef);
+    };
+    const mapperId = startMapper(fun, inputs, []);
+    return () => {
+      stopMapper(mapperId);
+    };
+  }, dependencies);
+
+  // check for invalid usage of shared values in returned object
+  let wrongKey;
+  const isError = Object.keys(initial).some((key) => {
+    const element = initial[key];
+    const result = typeof element === 'object' && element.value !== undefined;
+    if (result) {
+      wrongKey = key;
+    }
+    return result;
+  });
+  if (isError && wrongKey !== undefined) {
+    throw new Error(
+      `invalid value passed to \`${wrongKey}\`, maybe you forgot to use \`.value\`?`
+    );
+  }
+
+  return {
+    viewTag,
+    initial,
+    viewRef,
+  };
+}
+
+// TODO: we should make sure that when useAP is used we are not assigning styles
+// when you need styles to animated you should always use useAS
+export const useAnimatedProps = useAnimatedStyle;
+
+export function useDerivedValue(processor, dependencies) {
+  const initRef = useRef(null);
+  const inputs = Object.values(processor._closure);
+
+  // build dependencies
+  if (dependencies === undefined) {
+    dependencies = [...inputs, processor.__workletHash];
+  } else {
+    dependencies.push(processor.__workletHash);
+  }
+
+  if (initRef.current === null) {
+    initRef.current = makeMutable(initialUpdaterRun(processor));
+  }
+
+  const sharedValue = initRef.current;
+
+  useEffect(() => {
+    const fun = () => {
+      'worklet';
+      sharedValue.value = processor();
+    };
+    const mapperId = startMapper(fun, inputs, [sharedValue]);
+    return () => {
+      stopMapper(mapperId);
+    };
+  }, dependencies);
+
+  return sharedValue;
+}
+
+// builds one big hash from multiple worklets' hashes
+function buildWorkletsHash(handlers) {
+  return Object.keys(handlers).reduce(
+    (previousValue, key) =>
+      previousValue === null
+        ? handlers[key].__workletHash
+        : previousValue.toString() + handlers[key].__workletHash.toString(),
+    null
+  );
+}
+
+// builds dependencies array for gesture handlers
+function buildDependencies(dependencies, handlers) {
+  if (dependencies === undefined) {
+    dependencies = Object.keys(handlers).map((handlerKey) => {
+      const handler = handlers[handlerKey];
+      return {
+        workletHash: handler.__workletHash,
+        closure: handler._closure,
+      };
+    });
+  } else {
+    dependencies.push(buildWorkletsHash(handlers));
+  }
+  return dependencies;
+}
+
+// this is supposed to work as useEffect comparison
+function areDependenciesEqual(nextDeps, prevDeps) {
+  function is(x, y) {
+    /* eslint-disable no-self-compare */
+    return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);
+    /* eslint-enable no-self-compare */
+  }
+  var objectIs = typeof Object.is === 'function' ? Object.is : is;
+
+  function areHookInputsEqual(nextDeps, prevDeps) {
+    if (prevDeps === null) return !1;
+    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
+      if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
+    return !0;
+  }
+
+  return areHookInputsEqual(nextDeps, prevDeps);
+}
+
+export function useAnimatedGestureHandler(handlers, dependencies) {
+  const initRef = useRef(null);
+  if (initRef.current === null) {
+    initRef.current = {
+      context: makeRemote({}),
+      savedDependencies: [],
+    };
+  }
+  const { context, savedDependencies } = initRef.current;
+
+  dependencies = buildDependencies(dependencies, handlers);
+
+  const dependenciesDiffer = !areDependenciesEqual(
+    dependencies,
+    savedDependencies
+  );
+  initRef.current.savedDependencies = dependencies;
+
+  return useEvent(
+    (event) => {
+      'worklet';
+      const FAILED = 1;
+      const BEGAN = 2;
+      const CANCELLED = 3;
+      const ACTIVE = 4;
+      const END = 5;
+
+      if (event.state === BEGAN && handlers.onStart) {
+        handlers.onStart(event, context);
+      }
+      if (event.state === ACTIVE && handlers.onActive) {
+        handlers.onActive(event, context);
+      }
+      if (event.oldState === ACTIVE && event.state === END && handlers.onEnd) {
+        handlers.onEnd(event, context);
+      }
+      if (
+        event.oldState === BEGAN &&
+        event.state === FAILED &&
+        handlers.onFail
+      ) {
+        handlers.onFail(event, context);
+      }
+      if (
+        event.oldState === ACTIVE &&
+        event.state === CANCELLED &&
+        handlers.onCancel
+      ) {
+        handlers.onCancel(event, context);
+      }
+      if (
+        (event.oldState === BEGAN || event.oldState === ACTIVE) &&
+        event.state !== BEGAN &&
+        event.state !== ACTIVE &&
+        handlers.onFinish
+      ) {
+        handlers.onFinish(
+          event,
+          context,
+          event.state === CANCELLED || event.state === FAILED
+        );
+      }
+    },
+    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],
+    dependenciesDiffer
+  );
+}
+
+export function useAnimatedScrollHandler(handlers, dependencies) {
+  const initRef = useRef(null);
+  if (initRef.current === null) {
+    initRef.current = {
+      context: makeRemote({}),
+      savedDependencies: [],
+    };
+  }
+  const { context, savedDependencies } = initRef.current;
+
+  dependencies = buildDependencies(dependencies, handlers);
+
+  const dependenciesDiffer = !areDependenciesEqual(
+    dependencies,
+    savedDependencies
+  );
+  initRef.current.savedDependencies = dependencies;
+
+  // build event subscription array
+  const subscribeForEvents = ['onScroll'];
+  if (handlers.onBeginDrag !== undefined) {
+    subscribeForEvents.push('onScrollBeginDrag');
+  }
+  if (handlers.onEndDrag !== undefined) {
+    subscribeForEvents.push('onScrollEndDrag');
+  }
+  if (handlers.onMomentumBegin !== undefined) {
+    subscribeForEvents.push('onMomentumScrollBegin');
+  }
+  if (handlers.onMomentumEnd !== undefined) {
+    subscribeForEvents.push('onMomentumScrollEnd');
+  }
+
+  return useEvent(
+    (event) => {
+      'worklet';
+      const {
+        onScroll,
+        onBeginDrag,
+        onEndDrag,
+        onMomentumBegin,
+        onMomentumEnd,
+      } = handlers;
+      if (event.eventName.endsWith('onScroll')) {
+        if (onScroll) {
+          onScroll(event, context);
+        } else if (typeof handlers === 'function') {
+          handlers(event, context);
+        }
+      } else if (onBeginDrag && event.eventName.endsWith('onScrollBeginDrag')) {
+        onBeginDrag(event, context);
+      } else if (onEndDrag && event.eventName.endsWith('onScrollEndDrag')) {
+        onEndDrag(event, context);
+      } else if (
+        onMomentumBegin &&
+        event.eventName.endsWith('onMomentumScrollBegin')
+      ) {
+        onMomentumBegin(event, context);
+      } else if (
+        onMomentumEnd &&
+        event.eventName.endsWith('onMomentumScrollEnd')
+      ) {
+        onMomentumEnd(event, context);
+      }
+    },
+    subscribeForEvents,
+    dependenciesDiffer
+  );
+}
+
+export function useAnimatedRef() {
+  const tag = useSharedValue(-1);
+  const ref = useRef(null);
+
+  if (!ref.current) {
+    const fun = function(component) {
+      'worklet';
+      // enters when ref is set by attaching to a component
+      if (component) {
+        tag.value = getTag(component);
+        fun.current = component;
+      }
+      return tag.value;
+    };
+
+    Object.defineProperty(fun, 'current', {
+      value: null,
+      writable: true,
+      enumerable: false,
+    });
+    ref.current = fun;
+  }
+
+  return ref.current;
+}
+
+/**
+ * @param prepare - worklet used for data preparation for the second parameter
+ * @param react - worklet which takes data prepared by the one in the first parameter and performs certain actions
+ * the first worklet defines the inputs, in other words on which shared values change will it be called.
+ * the second one can modify any shared values but those which are mentioned in the first worklet. Beware of that, because this may result in endless loop and high cpu usage.
+ */
+export function useAnimatedReaction(prepare, react) {
+  const inputsRef = useRef(null);
+  if (inputsRef.current === null) {
+    inputsRef.current = {
+      inputs: Object.values(prepare._closure),
+    };
+  }
+  const { inputs } = inputsRef.current;
+
+  useEffect(() => {
+    const fun = () => {
+      'worklet';
+      const input = prepare();
+      react(input);
+    };
+    const mapperId = startMapper(fun, inputs, []);
+    return () => {
+      stopMapper(mapperId);
+    };
+  }, inputs);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/NativeMethods.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/NativeMethods.js
new file mode 100644
index 0000000..a0764c6
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/NativeMethods.js
@@ -0,0 +1,37 @@
+/* global _WORKLET _measure _scrollTo */
+import { findNodeHandle } from 'react-native';
+
+export function getTag(view) {
+  return findNodeHandle(view);
+}
+
+/**
+ * fields that can be accessed:
+ *  x
+ *  y
+ *  width
+ *  height
+ *  pageX
+ *  pageY
+ */
+export function measure(animatedRef) {
+  'worklet';
+  if (!_WORKLET) {
+    throw new Error('(measure) method cannot be used on RN side!');
+  }
+  const viewTag = animatedRef();
+  const result = _measure(viewTag);
+  if (result.x === -1234567) {
+    throw new Error(`The view with tag ${viewTag} could not be measured`);
+  }
+  return result;
+}
+
+export function scrollTo(animatedRef, x, y, animated) {
+  'worklet';
+  if (!_WORKLET) {
+    return;
+  }
+  const viewTag = animatedRef();
+  _scrollTo(viewTag, x, y, animated);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/NativeReanimated.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/NativeReanimated.js
new file mode 100644
index 0000000..dce1ee8
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/NativeReanimated.js
@@ -0,0 +1,50 @@
+import { TurboModuleRegistry, Platform } from 'react-native';
+import reanimatedJS from './js-reanimated';
+
+const InnerNativeModule =
+  Platform.OS === 'web'
+    ? false
+    : global.__reanimatedModuleProxy ||
+      TurboModuleRegistry.getEnforcing('NativeReanimated');
+
+const NativeReanimated = {
+  native: !!InnerNativeModule,
+
+  installCoreFunctions(valueSetter) {
+    return InnerNativeModule.installCoreFunctions(valueSetter);
+  },
+
+  makeShareable(value) {
+    return InnerNativeModule.makeShareable(value);
+  },
+
+  makeMutable(value) {
+    return InnerNativeModule.makeMutable(value);
+  },
+
+  makeRemote(object) {
+    return InnerNativeModule.makeRemote(object);
+  },
+
+  startMapper(mapper, inputs = [], outputs = []) {
+    return InnerNativeModule.startMapper(mapper, inputs, outputs);
+  },
+
+  stopMapper(mapperId) {
+    return InnerNativeModule.stopMapper(mapperId);
+  },
+
+  registerEventHandler(eventHash, eventHandler) {
+    return InnerNativeModule.registerEventHandler(eventHash, eventHandler);
+  },
+
+  unregisterEventHandler(registrationId) {
+    return InnerNativeModule.unregisterEventHandler(registrationId);
+  },
+
+  getViewProp(viewTag, propName, callback) {
+    return InnerNativeModule.getViewProp(viewTag, propName, callback);
+  },
+};
+
+export default NativeReanimated.native ? NativeReanimated : reanimatedJS;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/UpdateProps.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/UpdateProps.js
new file mode 100644
index 0000000..8b2c1fb
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/UpdateProps.js
@@ -0,0 +1,41 @@
+/* global _updateProps _updatePropsJS */
+import processColor from './Colors';
+import { makeShareable } from './core';
+import { Platform } from 'react-native';
+
+// copied from react-native/Libraries/Components/View/ReactNativeStyleAttributes
+const colorProps = [
+  'backgroundColor',
+  'borderBottomColor',
+  'borderColor',
+  'borderLeftColor',
+  'borderRightColor',
+  'borderTopColor',
+  'borderStartColor',
+  'borderEndColor',
+  'color',
+  'shadowColor',
+  'textDecorationColor',
+  'tintColor',
+  'textShadowColor',
+  'overlayColor',
+];
+
+const ColorProperties = makeShareable(colorProps);
+
+export default function updateProps(viewTag, updates, maybeViewRef) {
+  'worklet';
+
+  if (Platform.OS !== 'web') {
+    Object.keys(updates).forEach((key) => {
+      if (ColorProperties.indexOf(key) !== -1) {
+        updates[key] = processColor(updates[key]);
+      }
+    });
+  }
+
+  const updatePropsInternal =
+    typeof _updateProps === 'undefined' ? _updatePropsJS : _updateProps;
+
+  updatePropsInternal(viewTag, updates, maybeViewRef);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/WorkletEventHandler.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/WorkletEventHandler.js
new file mode 100644
index 0000000..b650f14
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/WorkletEventHandler.js
@@ -0,0 +1,48 @@
+import NativeModule from './NativeReanimated';
+
+const jsListener = (eventName, handler) => (evt) => {
+  handler({ ...evt.nativeEvent, eventName });
+};
+
+export default class WorkletEventHandler {
+  constructor(worklet, eventNames = []) {
+    this.worklet = worklet;
+    this.eventNames = eventNames;
+    this.reattachNeeded = false;
+
+    if (!NativeModule.native) {
+      this.listeners = eventNames.reduce((acc, eventName) => {
+        acc[eventName] = jsListener(eventName, worklet);
+        return acc;
+      }, {});
+    }
+  }
+
+  updateWorklet(newWorklet) {
+    this.worklet = newWorklet;
+    this.reattachNeeded = true;
+  }
+
+  registerForEvents(viewTag, fallbackEventName = undefined) {
+    this.viewTag = viewTag;
+    this.registrations = this.eventNames.map((eventName) =>
+      NativeModule.registerEventHandler(viewTag + eventName, this.worklet)
+    );
+    if (this.registrations.length === 0 && fallbackEventName) {
+      this.registrations.push(
+        NativeModule.registerEventHandler(
+          viewTag + fallbackEventName,
+          this.worklet
+        )
+      );
+    }
+  }
+
+  unregisterFromEvents() {
+    this.registrations &&
+      this.registrations.forEach((id) =>
+        NativeModule.unregisterEventHandler(id)
+      );
+    this.registrations = undefined;
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/__mocks__/NativeReanimated.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/__mocks__/NativeReanimated.js
new file mode 100644
index 0000000..614115c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/__mocks__/NativeReanimated.js
@@ -0,0 +1,10 @@
+export default {
+  installCoreFunctions: () => {},
+  makeShareable: () => {},
+  makeMutable: () => {},
+  makeRemote: () => {},
+  startMapper: () => {},
+  stopMapper: () => {},
+  registerEventHandler: () => {},
+  unregisterEventHandler: () => {},
+};
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/__snapshots__/plugin.test.js.snap b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/__snapshots__/plugin.test.js.snap
new file mode 100644
index 0000000..d0069c4
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/__snapshots__/plugin.test.js.snap
@@ -0,0 +1,38 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`babel plugin transforms  1`] = `
+"var _interopRequireWildcard = require(\\"@babel/runtime/helpers/interopRequireWildcard\\");
+
+var _reactNativeReanimated = _interopRequireWildcard(require(\\"react-native-reanimated\\"));
+
+function Box() {
+  var offset = (0, _reactNativeReanimated.useSharedValue)(0);
+  var animatedStyles = (0, _reactNativeReanimated.useAnimatedStyle)(function () {
+    const _f = function () {
+      return {
+        transform: [{
+          translateX: offset.value * 255
+        }]
+      };
+    };
+
+    _f._closure = {
+      offset
+    };
+    _f.asString = \\"function _f(){const{offset}=jsThis._closure;{return{transform:[{translateX:offset.value*255}]};}}\\";
+    _f.__workletHash = 7114514849439;
+
+    global.__reanimatedWorkletInit(_f);
+
+    return _f;
+  }());
+  return React.createElement(React.Fragment, null, React.createElement(_reactNativeReanimated.default.View, {
+    style: [styles.box, animatedStyles]
+  }), React.createElement(Button, {
+    onPress: function onPress() {
+      return offset.value = Math.random();
+    },
+    title: \\"Move\\"
+  }));
+}"
+`;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/animations.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/animations.js
new file mode 100644
index 0000000..daca979
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/animations.js
@@ -0,0 +1,486 @@
+/* global _WORKLET */
+import { NewEasing as Easing } from './Easing';
+import NativeReanimated from './NativeReanimated';
+
+let IN_STYLE_UPDATER = false;
+
+const assertNumber = (value, callerName) => {
+  'worklet'
+  const valueType = typeof value;
+  if (valueType !== 'number') {
+    let error = `invalid type of toValue passed to ${callerName}, expected \`number\`, got \`${valueType}\``;
+    if (valueType === 'object') {
+      error += ', maybe you forgot to add `.value`?';
+    }
+    throw new Error(error);
+  }
+};
+
+export function initialUpdaterRun(updater) {
+  IN_STYLE_UPDATER = true;
+  const result = updater();
+  IN_STYLE_UPDATER = false;
+  return result;
+}
+
+function defineAnimation(starting, factory) {
+  'worklet';
+  if (IN_STYLE_UPDATER) {
+    return starting;
+  }
+  if (_WORKLET || !NativeReanimated.native) {
+    return factory();
+  }
+  return factory;
+}
+
+export function cancelAnimation(sharedValue) {
+  'worklet';
+  // setting the current value cancels the animation if one is currently running
+  sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign
+}
+
+export function withTiming(toValue, userConfig, callback) {
+  'worklet';
+  // check toValue
+  assertNumber(toValue, 'withTiming');
+
+  return defineAnimation(toValue, () => {
+    'worklet';
+    const config = {
+      duration: 300,
+      easing: Easing.inOut(Easing.quad),
+    };
+    if (userConfig) {
+      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));
+    }
+
+    function timing(animation, now) {
+      const { toValue, progress, startTime, current } = animation;
+
+      const runtime = now - startTime;
+
+      if (runtime >= config.duration) {
+        // reset startTime to avoid reusing finished animation config in `start` method
+        animation.startTime = 0;
+        animation.current = toValue;
+        return true;
+      }
+
+      const newProgress = config.easing(runtime / config.duration);
+
+      const dist =
+        ((toValue - current) * (newProgress - progress)) / (1 - progress);
+      animation.current += dist;
+      animation.progress = newProgress;
+      return false;
+    }
+
+    function start(animation, value, now, previousAnimation) {
+      if (
+        previousAnimation &&
+        previousAnimation.type === 'timing' &&
+        previousAnimation.toValue === toValue &&
+        previousAnimation.startTime
+      ) {
+        // to maintain continuity of timing animations we check if we are starting
+        // new timing over the old one with the same parameters. If so, we want
+        // to copy animation timeline properties
+        animation.startTime = previousAnimation.startTime;
+        animation.progress = previousAnimation.progress;
+      } else {
+        animation.startTime = now;
+        animation.progress = 0;
+      }
+      animation.current = value;
+    }
+
+    return {
+      type: 'timing',
+      animation: timing,
+      start,
+      progress: 0,
+      toValue,
+      current: toValue,
+      callback,
+    };
+  });
+}
+
+export function withSpring(toValue, userConfig, callback) {
+  'worklet';
+  // check toValue
+  assertNumber(toValue, 'withSpring');
+
+  return defineAnimation(toValue, () => {
+    'worklet';
+
+    // TODO: figure out why we can't use spread or Object.assign here
+    // when user config is "frozen object" we can't enumerate it (perhaps
+    // something is wrong with the object prototype).
+    const config = {
+      damping: 10,
+      mass: 1,
+      stiffness: 100,
+      overshootClamping: false,
+      restDisplacementThreshold: 0.001,
+      restSpeedThreshold: 0.001,
+    };
+    if (userConfig) {
+      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));
+    }
+
+    function spring(animation, now) {
+      const { toValue, lastTimestamp, current, velocity } = animation;
+
+      const deltaTime = Math.min(now - lastTimestamp, 64);
+      animation.lastTimestamp = now;
+
+      const c = config.damping;
+      const m = config.mass;
+      const k = config.stiffness;
+
+      const v0 = -velocity;
+      const x0 = toValue - current;
+
+      const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio
+      const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)
+      const omega1 = omega0 * Math.sqrt(1 - zeta ** 2); // exponential decay
+
+      const t = deltaTime / 1000;
+
+      const sin1 = Math.sin(omega1 * t);
+      const cos1 = Math.cos(omega1 * t);
+
+      // under damped
+      const underDampedEnvelope = Math.exp(-zeta * omega0 * t);
+      const underDampedFrag1 =
+        underDampedEnvelope *
+        (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);
+
+      const underDampedPosition = toValue - underDampedFrag1;
+      // This looks crazy -- it's actually just the derivative of the oscillation function
+      const underDampedVelocity =
+        zeta * omega0 * underDampedFrag1 -
+        underDampedEnvelope *
+          (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);
+
+      // critically damped
+      const criticallyDampedEnvelope = Math.exp(-omega0 * t);
+      const criticallyDampedPosition =
+        toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);
+
+      const criticallyDampedVelocity =
+        criticallyDampedEnvelope *
+        (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);
+
+      const isOvershooting = () => {
+        if (config.overshootClamping && config.stiffness !== 0) {
+          return current < toValue
+            ? animation.current > toValue
+            : animation.current < toValue;
+        } else {
+          return false;
+        }
+      };
+
+      const isVelocity = Math.abs(velocity) < config.restSpeedThreshold;
+      const isDisplacement =
+        config.stiffness === 0 ||
+        Math.abs(toValue - current) < config.restDisplacementThreshold;
+
+      if (zeta < 1) {
+        animation.current = underDampedPosition;
+        animation.velocity = underDampedVelocity;
+      } else {
+        animation.current = criticallyDampedPosition;
+        animation.velocity = criticallyDampedVelocity;
+      }
+
+      if (isOvershooting() || (isVelocity && isDisplacement)) {
+        if (config.stiffness !== 0) {
+          animation.velocity = 0;
+          animation.current = toValue;
+        }
+        return true;
+      }
+    }
+
+    function start(animation, value, now, previousAnimation) {
+      animation.current = value;
+      if (previousAnimation) {
+        animation.velocity =
+          previousAnimation.velocity || animation.velocity || 0;
+        animation.lastTimestamp = previousAnimation.lastTimestamp || now;
+      } else {
+        animation.lastTimestamp = now;
+      }
+    }
+
+    return {
+      animation: spring,
+      start,
+      toValue,
+      velocity: config.velocity || 0,
+      current: toValue,
+      callback,
+    };
+  });
+}
+
+export function withDecay(userConfig, callback) {
+  'worklet';
+  return defineAnimation(0, () => {
+    'worklet';
+    const config = {
+      deceleration: 0.998,
+    };
+    if (userConfig) {
+      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));
+    }
+
+    const VELOCITY_EPS = 5;
+
+    function decay(animation, now) {
+      const { lastTimestamp, initialVelocity, current, velocity } = animation;
+
+      const deltaTime = Math.min(now - lastTimestamp, 64);
+      animation.lastTimestamp = now;
+
+      const kv = Math.pow(config.deceleration, deltaTime);
+      const kx = (config.deceleration * (1 - kv)) / (1 - config.deceleration);
+
+      const v0 = velocity / 1000;
+      const v = v0 * kv * 1000;
+      const x = current + v0 * kx;
+
+      animation.current = x;
+      animation.velocity = v;
+
+      let toValueIsReached = null;
+
+      if (Array.isArray(config.clamp)) {
+        if (initialVelocity < 0 && animation.current <= config.clamp[0]) {
+          toValueIsReached = config.clamp[0];
+        } else if (
+          initialVelocity > 0 &&
+          animation.current >= config.clamp[1]
+        ) {
+          toValueIsReached = config.clamp[1];
+        }
+      }
+
+      if (Math.abs(v) < VELOCITY_EPS || toValueIsReached !== null) {
+        if (toValueIsReached !== null) {
+          animation.current = toValueIsReached;
+        }
+
+        return true;
+      }
+    }
+
+    function start(animation, value, now) {
+      animation.current = value;
+      animation.lastTimestamp = now;
+      animation.initialVelocity = config.velocity;
+    }
+
+    return {
+      animation: decay,
+      start,
+      velocity: config.velocity || 0,
+      callback,
+    };
+  });
+}
+
+export function delay(delayMs, _nextAnimation) {
+  'worklet';
+  return defineAnimation(_nextAnimation, () => {
+    'worklet';
+
+    const nextAnimation =
+      typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;
+
+    function delay(animation, now) {
+      const { startTime, started, previousAnimation } = animation;
+
+      if (now - startTime > delayMs) {
+        if (!started) {
+          nextAnimation.start(
+            nextAnimation,
+            animation.current,
+            now,
+            previousAnimation
+          );
+          animation.previousAnimation = null;
+          animation.started = true;
+        }
+        const finished = nextAnimation.animation(nextAnimation, now);
+        animation.current = nextAnimation.current;
+        return finished;
+      } else if (previousAnimation) {
+        const finished = previousAnimation.animation(previousAnimation, now);
+        animation.current = previousAnimation.current;
+        if (finished) {
+          animation.previousAnimation = null;
+        }
+      }
+      return false;
+    }
+
+    function start(animation, value, now, previousAnimation) {
+      animation.startTime = now;
+      animation.started = false;
+      animation.current = value;
+      animation.previousAnimation = previousAnimation;
+    }
+
+    const callback = (finished) => {
+      if (nextAnimation.callback) {
+        nextAnimation.callback(finished);
+      }
+    };
+
+    return {
+      animation: delay,
+      start,
+      current: nextAnimation.current,
+      callback,
+    };
+  });
+}
+
+export function sequence(..._animations) {
+  'worklet';
+  return defineAnimation(_animations[0], () => {
+    'worklet';
+    const animations = _animations.map((a) => {
+      const result = typeof a === 'function' ? a() : a;
+      result.finished = false;
+      return result;
+    });
+    const firstAnimation = animations[0];
+
+    const callback = (finished) => {
+      if (finished) {
+        // we want to call the callback after every single animation
+        // not after all of them
+        return;
+      }
+      // this is going to be called only if sequence has been cancelled
+      animations.forEach((animation) => {
+        if (typeof animation.callback === 'function' && !animation.finished) {
+          animation.callback(finished);
+        }
+      });
+    };
+
+    function sequence(animation, now) {
+      const currentAnim = animations[animation.animationIndex];
+      const finished = currentAnim.animation(currentAnim, now);
+      animation.current = currentAnim.current;
+      if (finished) {
+        // we want to call the callback after every single animation
+        if (currentAnim.callback) {
+          currentAnim.callback(true /* finished */);
+        }
+        currentAnim.finished = true;
+        animation.animationIndex += 1;
+        if (animation.animationIndex < animations.length) {
+          const nextAnim = animations[animation.animationIndex];
+          nextAnim.start(nextAnim, currentAnim.current, now, currentAnim);
+          return false;
+        }
+        return true;
+      }
+      return false;
+    }
+
+    function start(animation, value, now, previousAnimation) {
+      animation.animationIndex = 0;
+      firstAnimation.start(firstAnimation, value, now, previousAnimation);
+    }
+
+    return {
+      animation: sequence,
+      start,
+      animationIndex: 0,
+      current: firstAnimation.current,
+      callback,
+    };
+  });
+}
+
+export function repeat(
+  _nextAnimation,
+  numberOfReps = 2,
+  reverse = false,
+  callback
+) {
+  'worklet';
+  return defineAnimation(_nextAnimation, () => {
+    'worklet';
+
+    const nextAnimation =
+      typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;
+
+    function repeat(animation, now) {
+      const finished = nextAnimation.animation(nextAnimation, now);
+      animation.current = nextAnimation.current;
+      if (finished) {
+        animation.reps += 1;
+        // call inner animation's callback on every repetition
+        // as the second argument the animation's current value is passed
+        if (nextAnimation.callback) {
+          nextAnimation.callback(true /* finished */, animation.current);
+        }
+        if (numberOfReps > 0 && animation.reps >= numberOfReps) {
+          return true;
+        }
+
+        const startValue = reverse
+          ? nextAnimation.current
+          : animation.startValue;
+        if (reverse) {
+          nextAnimation.toValue = animation.startValue;
+          animation.startValue = startValue;
+        }
+        nextAnimation.start(nextAnimation, startValue, now, nextAnimation);
+        return false;
+      }
+      return false;
+    }
+
+    const repCallback = (finished) => {
+      if (callback) {
+        callback(finished);
+      }
+      // when cancelled call inner animation's callback
+      if (!finished && nextAnimation.callback) {
+        nextAnimation.callback(false /* finished */);
+      }
+    };
+
+    function start(animation, value, now, previousAnimation) {
+      animation.startValue = value;
+      animation.reps = 0;
+      nextAnimation.start(nextAnimation, value, now, previousAnimation);
+    }
+
+    return {
+      animation: repeat,
+      start,
+      reps: 0,
+      current: nextAnimation.current,
+      callback: repCallback,
+    };
+  });
+}
+
+/* Deprecated, kept for backward compatibility. Will be removed soon */
+export function loop(nextAnimation, numberOfLoops = 1) {
+  'worklet';
+  console.warn('Method `loop` is deprecated. Please use `repeat` instead');
+  return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/core.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/core.js
new file mode 100644
index 0000000..84502a3
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/core.js
@@ -0,0 +1,152 @@
+import NativeReanimated from './NativeReanimated';
+
+global.__reanimatedWorkletInit = function(worklet) {
+  worklet.__worklet = true;
+};
+
+function pushFrame(frame) {
+  NativeReanimated.pushFrame(frame);
+}
+
+export function requestFrame(frame) {
+  'worklet';
+
+  if (NativeReanimated.native) {
+    requestAnimationFrame(frame);
+  } else {
+    pushFrame(frame);
+  }
+}
+
+global._WORKLET = false;
+global._log = function(s) {
+  console.log(s);
+};
+
+export function runOnUI(worklet) {
+  return makeShareable(worklet);
+}
+
+export function makeShareable(value) {
+  return NativeReanimated.makeShareable(value);
+}
+
+export function getViewProp(viewTag, propName) {
+  return new Promise((resolve, reject) => {
+    return NativeReanimated.getViewProp(viewTag, propName, (result) => {
+      if (result.substr(0, 6) === 'error:') {
+        reject(result);
+      } else {
+        resolve(result);
+      }
+    });
+  });
+}
+
+function workletValueSetter(value) {
+  'worklet';
+
+  const previousAnimation = this._animation;
+  if (previousAnimation) {
+    previousAnimation.cancelled = true;
+    this._animation = null;
+  }
+  if (
+    typeof value === 'function' ||
+    (value !== null && typeof value === 'object' && value.animation)
+  ) {
+    // animated set
+    const animation = typeof value === 'function' ? value() : value;
+    let callStart = (timestamp) => {
+      animation.start(animation, this.value, timestamp, previousAnimation);
+    };
+    const step = (timestamp) => {
+      if (animation.cancelled) {
+        animation.callback && animation.callback(false /* finished */);
+        return;
+      }
+      if (callStart) {
+        callStart(timestamp);
+        callStart = null; // prevent closure from keeping ref to previous animation
+      }
+      const finished = animation.animation(animation, timestamp);
+      animation.timestamp = timestamp;
+      this._value = animation.current;
+      if (finished) {
+        animation.callback && animation.callback(true /* finished */);
+      } else {
+        requestAnimationFrame(step);
+      }
+    };
+
+    this._animation = animation;
+
+    requestAnimationFrame(step);
+  } else {
+    this._value = value;
+  }
+}
+
+// We cannot use pushFrame
+// so we use own implementation for js
+function workletValueSetterJS(value) {
+  const previousAnimation = this._animation;
+  if (previousAnimation) {
+    previousAnimation.cancelled = true;
+    this._animation = null;
+  }
+  if (
+    typeof value === 'function' ||
+    (value !== null && typeof value === 'object' && value.animation)
+  ) {
+    // animated set
+    const animation = typeof value === 'function' ? value() : value;
+    let callStart = (timestamp) => {
+      animation.start(animation, this.value, timestamp, previousAnimation);
+    };
+    const step = (timestamp) => {
+      if (animation.cancelled) {
+        animation.callback && animation.callback(false /* finished */);
+        return;
+      }
+      if (callStart) {
+        callStart(timestamp);
+        callStart = null; // prevent closure from keeping ref to previous animation
+      }
+      const finished = animation.animation(animation, timestamp);
+      animation.timestamp = timestamp;
+      this._setValue(animation.current);
+      if (finished) {
+        animation.callback && animation.callback(true /* finished */);
+      } else {
+        requestFrame(step);
+      }
+    };
+
+    this._animation = animation;
+
+    requestFrame(step);
+  } else {
+    this._setValue(value);
+  }
+}
+
+NativeReanimated.installCoreFunctions(
+  NativeReanimated.native ? workletValueSetter : workletValueSetterJS
+);
+
+export function makeMutable(value) {
+  return NativeReanimated.makeMutable(value);
+}
+
+export function makeRemote(object = {}) {
+  return NativeReanimated.makeRemote(object);
+}
+
+export function startMapper(mapper, inputs = [], outputs = []) {
+  return NativeReanimated.startMapper(mapper, inputs, outputs);
+}
+
+export function stopMapper(mapperId) {
+  setTimeout(() => NativeReanimated.stopMapper(mapperId), 1000  );
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/index.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/index.js
new file mode 100644
index 0000000..59a09d5
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/index.js
@@ -0,0 +1,7 @@
+export * from './core';
+export * from './Hooks';
+export * from './animations';
+export * from './interpolation';
+export * from './Easing';
+export * from './NativeMethods';
+export {default as processColor} from "./Colors";
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/interpolation.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/interpolation.js
new file mode 100644
index 0000000..920eaa9
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/interpolation.js
@@ -0,0 +1,58 @@
+import { Extrapolate } from '../derived/interpolate';
+
+function internalInterpolate(x, l, r, ll, rr, type) {
+  'worklet';
+  if (r - l === 0) return ll;
+  const progress = (x - l) / (r - l);
+  const val = ll + progress * (rr - ll);
+  const coef = rr >= ll ? 1 : -1;
+
+  // TODO: support default values in worklets:
+  // e.g. function interplate(x, input, output, type = Extrapolate.CLAMP)
+  type = type || Extrapolate.EXTEND;
+
+  if (coef * val < coef * ll || coef * val > coef * rr) {
+    switch (type) {
+      case Extrapolate.IDENTITY:
+        return x;
+      case Extrapolate.CLAMP:
+        if (coef * val < coef * ll) {
+          return ll;
+        }
+        return rr;
+      case Extrapolate.EXTEND:
+      default:
+        return val;
+    }
+  }
+  return val;
+}
+
+export function newInterpolate(x, input, output, type) {
+  'worklet';
+  if (x && x.__nodeID) {
+    throw new Error(
+      'Reanimated: interpolate from V1 has been renamed to interpolateNode.'
+    );
+  }
+  const length = input.length;
+  let narrowedInput = [];
+  if (x < input[0]) {
+    narrowedInput = [input[0], input[1], output[0], output[1]];
+  } else if (x > input[length - 1]) {
+    narrowedInput = [
+      input[length - 2],
+      input[length - 1],
+      output[length - 2],
+      output[length - 1],
+    ];
+  } else {
+    for (let i = 1; i < length; ++i) {
+      if (x <= input[i]) {
+        narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];
+        break;
+      }
+    }
+  }
+  return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/JSReanimated.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/JSReanimated.js
new file mode 100644
index 0000000..09dce35
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/JSReanimated.js
@@ -0,0 +1,75 @@
+import MapperRegistry from './MapperRegistry';
+import MutableValue from './MutableValue';
+import Mapper from './Mapper';
+
+export default class JSReanimated {
+  native = false;
+  _valueSetter = undefined;
+  _renderRequested = false;
+  _mapperRegistry = new MapperRegistry(this);
+  _frames = [];
+
+  pushFrame(frame) {
+    this._frames.push(frame);
+
+    this.maybeRequestRender();
+  }
+
+  maybeRequestRender() {
+    if (!this._renderRequested) {
+      this._renderRequested = true;
+
+      requestAnimationFrame((timestampMs) => {
+        this._renderRequested = false;
+
+        this._onRender(timestampMs);
+      });
+    }
+  }
+
+  _onRender(timestampMs) {
+    this._mapperRegistry.execute();
+
+    const frames = [...this._frames];
+    this._frames = [];
+
+    for (let i = 0, len = frames.length; i < len; ++i) {
+      frames[i](timestampMs);
+    }
+
+    if (this._mapperRegistry.needRunOnRender) {
+      this._mapperRegistry.execute();
+    }
+  }
+
+  installCoreFunctions(valueSetter) {
+    this._valueSetter = valueSetter;
+  }
+
+  makeShareable(value) {
+    return value;
+  }
+
+  makeMutable(value) {
+    return new MutableValue(value, this._valueSetter);
+  }
+
+  makeRemote(object) {
+    return object;
+  }
+
+  startMapper(mapper, inputs = [], outputs = []) {
+    const instance = new Mapper(this, mapper, inputs, outputs);
+    const mapperId = this._mapperRegistry.startMapper(instance);
+    this.maybeRequestRender();
+    return mapperId;
+  }
+
+  stopMapper(mapperId) {
+    this._mapperRegistry.stopMapper(mapperId);
+  }
+
+  registerEventHandler(eventHash, eventHandler) {}
+
+  unregisterEventHandler(registrationId) {}
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/Mapper.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/Mapper.js
new file mode 100644
index 0000000..1a46e26
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/Mapper.js
@@ -0,0 +1,47 @@
+import MutableValue from './MutableValue';
+
+export default class Mapper {
+  static MAPPER_ID = 1;
+
+  dirty = true;
+
+  constructor(module, mapper, inputs = [], outputs = []) {
+    this.id = Mapper.MAPPER_ID++;
+    this.inputs = this.extractMutablesFromArray(inputs);
+    this.outputs = this.extractMutablesFromArray(outputs);
+    this.mapper = mapper;
+
+    const markDirty = () => {
+      this.dirty = true;
+      module.maybeRequestRender();
+    };
+
+    this.inputs.forEach((input) => {
+      input.addListener(markDirty);
+    });
+  }
+
+  execute() {
+    this.dirty = false;
+    this.mapper();
+  }
+
+  extractMutablesFromArray(array) {
+    const res = [];
+
+    function extractMutables(value) {
+      if (value instanceof MutableValue) {
+        res.push(value);
+      } else if (Array.isArray(value)) {
+        value.forEach((v) => extractMutables(v));
+      } else if (typeof value === 'object') {
+        Object.keys(value).forEach((key) => {
+          extractMutables(value[key]);
+        });
+      }
+    }
+
+    extractMutables(array);
+    return res;
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/MapperRegistry.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/MapperRegistry.js
new file mode 100644
index 0000000..322e870
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/MapperRegistry.js
@@ -0,0 +1,128 @@
+export default class MapperRegistry {
+  sortedMappers = [];
+  mappers = new Map();
+
+  updatedSinceLastExecute = false;
+
+  constructor(module) {
+    this._module = module;
+  }
+
+  startMapper(mapper) {
+    this.mappers.set(mapper.id, mapper);
+    this.updatedSinceLastExecute = true;
+    return mapper.id;
+  }
+
+  stopMapper(id) {
+    this.mappers.delete(id);
+    this.updatedSinceLastExecute = true;
+  }
+
+  execute() {
+    if (this.updatedSinceLastExecute) {
+      this.updateOrder();
+      this.updatedSinceLastExecute = false;
+    }
+
+    for (let i = 0, len = this.sortedMappers.length; i < len; ++i) {
+      const mapper = this.sortedMappers[i];
+      if (mapper.dirty) {
+        mapper.execute();
+      }
+    }
+  }
+
+  updateOrder() {
+    const nodes = [...this.mappers.values()].map((mapper) => new Node(mapper));
+
+    const mappersById = {};
+    this.mappers.forEach((mapper) => {
+      mappersById[mapper.id] = mapper;
+    });
+
+    // create a graph from array of nodes
+    for (let i = 0, nodesLen = nodes.length; i < nodesLen; ++i) {
+      const node = nodes[i];
+      if (node.mapper.outputs.length === 0) {
+        continue;
+      }
+      for (let j = 0; j < nodesLen; ++j) {
+        const restNode = nodes[j];
+        if (i === j || restNode.mapper.inputs.length === 0) {
+          continue;
+        }
+        for (
+          let outi = 0, outputsLen = node.mapper.outputs.length;
+          outi < outputsLen;
+          ++outi
+        ) {
+          for (
+            let resti = 0, restLen = restNode.mapper.inputs.length;
+            resti < restLen;
+            ++resti
+          ) {
+            if (
+              node.mapper.outputs[outi]._id ===
+              restNode.mapper.inputs[resti]._id
+            ) {
+              node.children.push(restNode);
+            }
+          }
+        }
+      }
+    }
+
+    const post = {};
+    let postCounter = 1;
+    const dfs = (node) => {
+      const index = nodes.indexOf(node);
+      if (index === -1) {
+        // this node has already been handled
+        return;
+      }
+      ++postCounter;
+      nodes.splice(index, 1);
+      if (node.children.length === 0 && nodes.length > 0) {
+        post[node.mapper.id] = postCounter++;
+        dfs(nodes[0]);
+        return;
+      }
+      for (let i = 0, len = node.children.length; i < len; ++i) {
+        dfs(node.children[i]);
+      }
+      post[node.mapper.id] = postCounter++;
+    };
+
+    while (nodes.length) dfs(nodes[0]);
+
+    const postArray = Object.keys(post).map((key) => {
+      return [key, post[key]];
+    });
+    postArray.sort((a, b) => {
+      return b[1] - a[1];
+    });
+
+    // clear sorted mappers
+    this.sortedMappers = [];
+
+    for (let i = 0, len = postArray.length; i < len; ++i) {
+      const [id] = postArray[i];
+      this.sortedMappers.push(mappersById[id]);
+    }
+  }
+
+  get needRunOnRender() {
+    return this.updatedSinceLastExecute;
+  }
+}
+
+class Node {
+  mapper = null;
+  children = [];
+
+  constructor(mapper, parents = [], children = []) {
+    this.mapper = mapper;
+    this.children = children;
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/MutableValue.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/MutableValue.js
new file mode 100644
index 0000000..be95269
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/MutableValue.js
@@ -0,0 +1,36 @@
+export default class MutableValue {
+  static MUTABLE_ID = 1;
+
+  _animation = null;
+  _listeners = [];
+
+  constructor(value, setter) {
+    this._id = MutableValue.MUTABLE_ID++;
+    this._value = value;
+    this._setter = setter;
+  }
+
+  get value() {
+    return this._value;
+  }
+
+  set value(nextValue) {
+    this._setter(nextValue);
+  }
+
+  // this changes the value finally and is supposed to be called from this._setter
+  _setValue(newValue) {
+    this._value = newValue;
+    this._triggerListener();
+  }
+
+  addListener(listener) {
+    this._listeners.push(listener);
+  }
+
+  _triggerListener() {
+    for (let i = 0, len = this._listeners.length; i < len; ++i) {
+      this._listeners[i]();
+    }
+  }
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/index.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/index.js
new file mode 100644
index 0000000..4e87623
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/js-reanimated/index.js
@@ -0,0 +1,21 @@
+import JSReanimated from './JSReanimated';
+
+const reanimatedJS = new JSReanimated();
+
+global._updatePropsJS = (viewTag, updates, viewRef) => {
+  if (viewRef.current && viewRef.current._component) {
+    const [rawStyles] = Object.keys(updates).reduce(
+      (acc, key) => {
+        const value = updates[key];
+        const index = typeof value === 'function' ? 1 : 0;
+        acc[index][key] = value;
+        return acc;
+      },
+      [{}, {}]
+    );
+
+    viewRef.current._component.setNativeProps({ style: rawStyles });
+  }
+};
+
+export default reanimatedJS;
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/plugin.test.js b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/plugin.test.js
new file mode 100644
index 0000000..9ea3d7c
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/reanimated2/plugin.test.js
@@ -0,0 +1,49 @@
+import plugin from '../../plugin';
+import { transform } from '@babel/core';
+
+function runPlugin(input) {
+  return transform(input, {
+    filename: 'someFile.js',
+    compact: false,
+    plugins: [plugin],
+  });
+}
+
+describe('babel plugin', () => {
+  it('transforms ', () => {
+    const input = `
+    import Animated, { useAnimatedStyle, useSharedValue } from 'react-native-reanimated'
+    
+    function Box() {
+        const offset = useSharedValue(0);
+      
+        const animatedStyles = useAnimatedStyle(() => {
+          return {
+            transform: [{ translateX: offset.value * 255 }],
+          };
+        });
+      
+        return (
+          <>
+            <Animated.View style={[styles.box, animatedStyles]} />
+            <Button onPress={() => (offset.value = Math.random())} title="Move" />
+          </>
+        );
+      }
+    `;
+
+    const { code } = runPlugin(input);
+    expect(code).toMatchSnapshot();
+  });
+
+  it('adds closure to worklets', () => {
+    const input = `
+      function someWorklet(greeting) {
+        'worklet';
+        console.log("Hey I'm running on the UI thread");
+      }`;
+
+    const { code } = runPlugin(input);
+    expect(code).toContain('_closure');
+  });
+});
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/useValue.js b/node_modules/react-native-reanimated/react-native-reanimated/src/useValue.js
new file mode 100644
index 0000000..93f3ba1
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/useValue.js
@@ -0,0 +1,10 @@
+import React from 'react';
+import AnimatedValue from './core/AnimatedValue';
+
+export default function useValue(initialValue) {
+  const ref = React.useRef(null);
+  if (ref.current === null) {
+    ref.current = new AnimatedValue(initialValue);
+  }
+  return ref.current;
+}
diff --git a/node_modules/react-native-reanimated/react-native-reanimated/src/val.js b/node_modules/react-native-reanimated/react-native-reanimated/src/val.js
new file mode 100644
index 0000000..13ed220
--- /dev/null
+++ b/node_modules/react-native-reanimated/react-native-reanimated/src/val.js
@@ -0,0 +1,3 @@
+export function val(v) {
+  return v && v.__getValue ? v.__getValue() : v || 0;
+}
diff --git a/node_modules/react-native-reanimated/src/Animated.js b/node_modules/react-native-reanimated/src/Animated.js
index 523853a..d7813c3 100644
--- a/node_modules/react-native-reanimated/src/Animated.js
+++ b/node_modules/react-native-reanimated/src/Animated.js
@@ -81,7 +81,7 @@ export * from './derived';
 export * from './reanimated2';
 
 export {
-  EasingNode,
+  EasingNode as Easing,
   Transitioning,
   Transition,
   createTransitioningComponent,
diff --git a/node_modules/react-native-reanimated/src/derived/index.js b/node_modules/react-native-reanimated/src/derived/index.js
index e6e1541..943d1b6 100644
--- a/node_modules/react-native-reanimated/src/derived/index.js
+++ b/node_modules/react-native-reanimated/src/derived/index.js
@@ -2,7 +2,7 @@ export { default as acc } from './acc';
 export { default as color } from './color';
 export { default as diff } from './diff';
 export { default as diffClamp } from './diffClamp';
-export { default as interpolateNode, Extrapolate } from './interpolate';
+export { default as interpolateNode, default as interpolate, Extrapolate } from './interpolate';
 export { default as interpolateColors } from './interpolateColors';
 export { default as onChange } from './onChange';
 export { default as useCode } from './useCode';
diff --git a/node_modules/react-native-reanimated/src/reanimated2/Easing.js b/node_modules/react-native-reanimated/src/reanimated2/Easing.js
index 48a3c76..0723069 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/Easing.js
+++ b/node_modules/react-native-reanimated/src/reanimated2/Easing.js
@@ -235,7 +235,7 @@ function inOut(easing) {
   };
 }
 
-export const Easing = {
+export const NewEasing = {
   linear,
   ease,
   quad,
diff --git a/node_modules/react-native-reanimated/src/reanimated2/animations.js b/node_modules/react-native-reanimated/src/reanimated2/animations.js
index 6629e32..daca979 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/animations.js
+++ b/node_modules/react-native-reanimated/src/reanimated2/animations.js
@@ -1,5 +1,5 @@
 /* global _WORKLET */
-import { Easing } from './Easing';
+import { NewEasing as Easing } from './Easing';
 import NativeReanimated from './NativeReanimated';
 
 let IN_STYLE_UPDATER = false;
diff --git a/node_modules/react-native-reanimated/src/reanimated2/core.js b/node_modules/react-native-reanimated/src/reanimated2/core.js
index 31c89f6..8352dd7 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/core.js
+++ b/node_modules/react-native-reanimated/src/reanimated2/core.js
@@ -148,5 +148,5 @@ export function startMapper(mapper, inputs = [], outputs = []) {
 }
 
 export function stopMapper(mapperId) {
-  NativeReanimated.stopMapper(mapperId);
+  //NativeReanimated.stopMapper(mapperId);
 }
diff --git a/node_modules/react-native-reanimated/src/reanimated2/interpolation.js b/node_modules/react-native-reanimated/src/reanimated2/interpolation.js
index fc43c60..920eaa9 100644
--- a/node_modules/react-native-reanimated/src/reanimated2/interpolation.js
+++ b/node_modules/react-native-reanimated/src/reanimated2/interpolation.js
@@ -28,7 +28,7 @@ function internalInterpolate(x, l, r, ll, rr, type) {
   return val;
 }
 
-export function interpolate(x, input, output, type) {
+export function newInterpolate(x, input, output, type) {
   'worklet';
   if (x && x.__nodeID) {
     throw new Error(
