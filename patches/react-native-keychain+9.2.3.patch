diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt
index 7227ba1..f317a06 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/DataStorePrefsStorage.kt
@@ -54,6 +54,32 @@ class DataStorePrefsStorage(
     return ResultSet(cipherStorageName, bytesForUsername, bytesForPassword)
   }
 
+  override fun getAllEncryptedEntries(): MutableList<Map<String, Any?>> {
+    val processedServices = mutableListOf<String>()
+    val data = mutableListOf<Map<String, Any?>>()
+    runBlocking {
+      val allKeys = prefsData.asMap().keys
+      for (key in allKeys) {
+        val keyName = key.name
+        if (keyName.length >= 2) {
+          val serviceName = keyName.substring(0, keyName.length - 2)
+          if (!processedServices.contains(serviceName)) {
+            val item = getEncryptedEntry(serviceName)
+            if (item != null) {
+              val map = mapOf(
+                "resultSet" to item,
+                "service" to serviceName
+              )
+              data.add(map)
+              processedServices.add(serviceName)
+            }
+          }
+        }
+      }
+    }
+    return data
+  }
+
   override fun removeEntry(service: String) {
     val keyForUsername = stringPreferencesKey(getKeyForUsername(service))
     val keyForPassword = stringPreferencesKey(getKeyForPassword(service))
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt
index 7a2c679..5cc6e53 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/KeychainModule.kt
@@ -168,7 +168,6 @@ class KeychainModule(reactContext: ReactApplicationContext) :
       val startTime = System.nanoTime()
       Log.v(KEYCHAIN_MODULE, "warming up started at $startTime")
       val best = cipherStorageForCurrentAPILevel as CipherStorageBase
-      val instance = best.getCachedInstance()
       val isSecure = best.supportsSecureHardware()
       val requiredLevel =
         if (isSecure) SecurityLevel.SECURE_HARDWARE else SecurityLevel.SECURE_SOFTWARE
@@ -245,6 +244,50 @@ class KeychainModule(reactContext: ReactApplicationContext) :
     }
   }
 
+  override fun canOverrideExistingModule(): Boolean {
+    return true;
+  }
+
+  @ReactMethod
+  fun getAllInternetCredentialsForServer(options: ReadableMap, promise: Promise) {
+    coroutineScope.launch {
+      mutex.withLock {
+        try {
+          val allCredentials = Arguments.createArray()
+          val currentCipherStorage = getCipherStorageForCurrentAPILevel(true)
+          val allResults = prefsStorage.getAllEncryptedEntries()
+
+          for (data in allResults) {
+            val resultSet = data["resultSet"] as PrefsStorageBase.ResultSet
+            val service = data["service"] as String
+            val rules = getSecurityRulesOrDefault(options)
+            val promptInfo = getPromptInfo(options)
+            val decryptionResult =
+              decryptCredentials(service, currentCipherStorage, resultSet, rules, promptInfo)
+
+            val credentials = Arguments.createMap().apply {
+              putString("service", service)
+              putString("username", decryptionResult.username)
+              putString("password", decryptionResult.password)
+            }
+            allCredentials.pushMap(credentials)
+          }
+
+          val result = Arguments.createMap().apply {
+            putArray("results", allCredentials)
+          }
+          promise.resolve(result)
+        } catch (e: KeyStoreAccessException) {
+          e.message?.let { Log.e(KEYCHAIN_MODULE, it) }
+          promise.reject(Errors.E_KEYSTORE_ACCESS_ERROR, e)
+        } catch (e: CryptoFailedException) {
+          e.message?.let { Log.e(KEYCHAIN_MODULE, it) }
+          promise.reject(Errors.E_CRYPTO_FAILED, e)
+        }
+      }
+    }
+  }
+
   @ReactMethod
   fun setGenericPasswordForOptions(
     options: ReadableMap?,
@@ -539,12 +582,25 @@ class KeychainModule(reactContext: ReactApplicationContext) :
     securityLevel: SecurityLevel,
     promptInfo: PromptInfo
   ): CipherStorage.EncryptionResult {
+    Log.d(KEYCHAIN_MODULE, "Starting encryption for alias: $alias")
+    Log.d(KEYCHAIN_MODULE, "Using storage: ${storage.getCipherStorageName()}")
+    Log.d(KEYCHAIN_MODULE, "Security level: $securityLevel")
+    Log.d(KEYCHAIN_MODULE, "Username: $username")
+    Log.d(KEYCHAIN_MODULE, "Password: $password")
+
     val handler = getInteractiveHandler(storage, promptInfo)
+    Log.d(KEYCHAIN_MODULE, "Got interactive handler for encryption")
+
     storage.encrypt(handler, alias, username, password, securityLevel)
+    Log.d(KEYCHAIN_MODULE, "Encryption completed")
+
     CryptoFailedException.reThrowOnError(handler.error)
     if (null == handler.encryptionResult) {
+      Log.e(KEYCHAIN_MODULE, "No encryption results and no error. Something deeply wrong!")
       throw CryptoFailedException("No decryption results and no error. Something deeply wrong!")
     }
+
+    Log.d(KEYCHAIN_MODULE, "Successfully encrypted data")
     return handler.encryptionResult!!
   }
 
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt
index d165f3e..91fd8b1 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/PrefsStorageBase.kt
@@ -13,6 +13,8 @@ interface PrefsStorageBase {
 
   fun getEncryptedEntry(service: String): ResultSet?
 
+  fun getAllEncryptedEntries(): MutableList<Map<String, Any?>>
+
   fun removeEntry(service: String)
 
   fun storeEncryptedEntry(service: String, encryptionResult: EncryptionResult)
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.kt
index 6a941bf..80d1189 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageBase.kt
@@ -14,6 +14,7 @@ import com.oblador.keychain.cipherStorage.CipherStorageBase.DecryptBytesHandler
 import com.oblador.keychain.cipherStorage.CipherStorageBase.EncryptStringHandler
 import com.oblador.keychain.exceptions.CryptoFailedException
 import com.oblador.keychain.exceptions.KeyStoreAccessException
+import com.oblador.keychain.resultHandler.ResultHandler
 import java.io.ByteArrayInputStream
 import java.io.ByteArrayOutputStream
 import java.io.Closeable
@@ -41,11 +42,21 @@ import javax.crypto.NoSuchPaddingException
 abstract class CipherStorageBase(protected val applicationContext: Context) : CipherStorage {
   // region Constants
   /** Logging tag. */
-  protected val LOG_TAG = CipherStorageBase::class.java.simpleName
+  protected val LOG_TAG get() = Companion.LOG_TAG
 
   /** Default key storage type/name. */
   companion object {
     const val KEYSTORE_TYPE = "AndroidKeyStore"
+    const val PREFIX_DELIMITER = "_"
+
+    /** Logging tag. */
+    private val LOG_TAG = CipherStorageBase::class.java.simpleName
+
+    // Prefix constants
+    const val PREFIX_RSA = "RSA"
+    const val PREFIX_AES_GCM = "AES_GCM"
+    const val PREFIX_AES_GCM_NO_AUTH = "AES_GCM_NA"
+    const val PREFIX_AES_CBC = "AES_CBC"
 
     /** Key used for testing storage capabilities. */
     const val TEST_KEY_ALIAS = "$KEYSTORE_TYPE#supportsSecureHardware"
@@ -79,6 +90,43 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
         output.write(buf, 0, len)
       }
     }
+
+    fun getPrefixedAlias(alias: String, prefix: String): String {
+      return if (alias.startsWith("$prefix$PREFIX_DELIMITER")) {
+        alias
+      } else {
+        "$prefix$PREFIX_DELIMITER$alias"
+      }
+    }
+
+    fun migrateLegacyKey(
+        legacyAlias: String,
+        newAlias: String,
+        keyStore: KeyStore,
+        handler: ResultHandler,
+        level: SecurityLevel
+    ) {
+        try {
+            val legacyKey = keyStore.getKey(legacyAlias, null) ?: return
+
+            // Save the key under new alias
+            keyStore.setKeyEntry(
+                newAlias,
+                legacyKey,
+                null,
+                keyStore.getCertificateChain(legacyAlias)
+            )
+
+            // Verify the new key works
+            if (keyStore.getKey(newAlias, null) != null) {
+                // If successful, delete the old key
+                keyStore.deleteEntry(legacyAlias)
+                Log.d(LOG_TAG, "Successfully migrated key from $legacyAlias to $newAlias")
+            }
+        } catch (e: Exception) {
+            Log.w(LOG_TAG, "Failed to migrate legacy key $legacyAlias: ${e.message}")
+        }
+    }
   }
 
   // endregion
@@ -158,12 +206,18 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
 
   /** Remove key with provided name from security storage. */
   override fun removeKey(alias: String) {
-    val safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+    val defaultAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
     val ks = getKeyStoreAndLoad()
 
     try {
-      if (ks.containsAlias(safeAlias)) {
-        ks.deleteEntry(safeAlias)
+      if (ks.containsAlias(defaultAlias)) {
+        ks.deleteEntry(defaultAlias)
+      }
+      // Try each possible prefix
+      listOf(PREFIX_RSA, PREFIX_AES_GCM, PREFIX_AES_GCM_NO_AUTH, PREFIX_AES_CBC).forEach { prefix ->
+        val prefixedAlias = getPrefixedAlias(defaultAlias, prefix)
+        if (ks.containsAlias(prefixedAlias)) {
+          ks.deleteEntry(prefixedAlias)
       }
     } catch (ignored: GeneralSecurityException) {
       /* only one exception can be raised by code: 'KeyStore is not loaded' */
@@ -174,7 +228,15 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
     val ks = getKeyStoreAndLoad()
     try {
       val aliases = ks.aliases()
-      return HashSet(Collections.list(aliases))
+      // Strip prefixes when returning keys
+      return HashSet(Collections.list(aliases).map { alias ->
+        listOf(PREFIX_RSA, PREFIX_AES_GCM, PREFIX_AES_GCM_NO_AUTH, PREFIX_AES_CBC).forEach { prefix ->
+          if (alias.startsWith("$prefix$PREFIX_DELIMITER")) {
+            return@map alias.substring(prefix.length + PREFIX_DELIMITER.length)
+          }
+        }
+        alias
+      })
     } catch (e: KeyStoreException) {
       throw KeyStoreAccessException("Error accessing aliases in keystore $ks", e)
     }
@@ -212,17 +274,10 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
 
   // region Implementation
 
-  /** Get cipher instance and cache it for any next call. */
+  /** Get cipher instance */
   @Throws(NoSuchAlgorithmException::class, NoSuchPaddingException::class)
-  fun getCachedInstance(): Cipher {
-    if (cachedCipher == null) {
-      synchronized(this) {
-        if (cachedCipher == null) {
-          cachedCipher = Cipher.getInstance(getEncryptionTransformation())
-        }
-      }
-    }
-    return cachedCipher!!
+  fun getCipher(): Cipher {
+    return Cipher.getInstance(getEncryptionTransformation())
   }
 
   /** Check requirements to the security level. */
@@ -304,6 +359,42 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
     return key
   }
 
+  /**
+   * Try to extract key, first with prefix then fallback to legacy format
+   */
+  @Throws(GeneralSecurityException::class) 
+  protected fun extractKeyWithMigration(
+      alias: String,
+      prefix: String,
+      handler: ResultHandler,
+      level: SecurityLevel,
+      retries: AtomicInteger
+  ): Key {
+      val prefixedAlias = getPrefixedAlias(alias, prefix)
+      val keyStore = getKeyStoreAndLoad()
+
+      // First try prefixed alias
+      if (keyStore.containsAlias(prefixedAlias)) {
+          return extractKey(keyStore, prefixedAlias, retries) ?: 
+              throw KeyStoreAccessException("Failed to extract key for $prefixedAlias")
+      }
+
+      // Try legacy alias
+      if (keyStore.containsAlias(alias)) {
+          val key = extractKey(keyStore, alias, retries)
+          if (key != null) {
+              // Migrate to new format
+              migrateLegacyKey(alias, prefixedAlias, keyStore, handler, level)
+              return key
+          }
+      }
+
+      // No existing key found, create new one with prefix
+      generateKeyAndStoreUnderAlias(prefixedAlias, level)
+      return extractKey(keyStore, prefixedAlias, retries) ?:
+          throw KeyStoreAccessException("Failed to generate key for $prefixedAlias")
+  }
+
   /** Verify that provided key satisfy minimal needed level. */
   @Throws(GeneralSecurityException::class)
   protected fun validateKeySecurityLevel(level: SecurityLevel, key: Key): Boolean {
@@ -350,6 +441,7 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
   /** Default encryption with cipher without initialization vector. */
   @Throws(IOException::class, GeneralSecurityException::class)
   open fun encryptString(key: Key, value: String): ByteArray {
+    Log.d(LOG_TAG, "Encrypting string with key: ${key.algorithm} and value length: ${value.length}")
     return encryptString(key, value, Defaults.encrypt)
   }
 
@@ -362,20 +454,35 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
   /** Encrypt provided string value. */
   @Throws(IOException::class, GeneralSecurityException::class)
   protected fun encryptString(key: Key, value: String, handler: EncryptStringHandler?): ByteArray {
-    val cipher = getCachedInstance()
+    Log.d(LOG_TAG, "Starting encryption of string value")
+    Log.d(LOG_TAG, "Input value length: ${value.length}")
+    
+    val cipher = getCipher()
+    Log.d(LOG_TAG, "Cipher algorithm: ${cipher.algorithm}")
+    
     try {
       ByteArrayOutputStream().use { output ->
         if (handler != null) {
+          Log.d(LOG_TAG, "Using custom handler for initialization")
           handler.initialize(cipher, key, output)
           output.flush()
         }
 
-        CipherOutputStream(output, cipher).use { encrypt -> encrypt.write(value.toByteArray(UTF8)) }
+        val valueBytes = value.toByteArray(UTF8)
+        Log.d(LOG_TAG, "Value converted to bytes, length: ${valueBytes.size}")
+        
+        CipherOutputStream(output, cipher).use { encrypt -> 
+          encrypt.write(valueBytes)
+          Log.d(LOG_TAG, "Wrote bytes to CipherOutputStream")
+        }
 
-        return output.toByteArray()
+        val result = output.toByteArray()
+        Log.d(LOG_TAG, "Final encrypted output size: ${result.size}")
+        return result
       }
     } catch (fail: Throwable) {
-      Log.e(LOG_TAG, fail.message, fail)
+      Log.e(LOG_TAG, "Encryption failed: ${fail.message}", fail)
+      Log.e(LOG_TAG, "Stack trace: ${fail.stackTraceToString()}")
       throw fail
     }
   }
@@ -388,7 +495,7 @@ abstract class CipherStorageBase(protected val applicationContext: Context) : Ci
     bytes: ByteArray,
     handler: DecryptBytesHandler?
   ): String {
-    val cipher = getCachedInstance()
+    val cipher = getCipher()
     try {
       ByteArrayInputStream(bytes).use { input ->
         ByteArrayOutputStream().use { output ->
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.kt
index 99ae741..c23399c 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesCbc.kt
@@ -88,14 +88,17 @@ class CipherStorageKeystoreAesCbc(reactContext: ReactApplicationContext) :
 
         throwIfInsufficientLevel(level)
 
-        val safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+        val defaultAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+        val safeAlias = getPrefixedAlias(defaultAlias, PREFIX_AES_CBC)
         val retries = AtomicInteger(1)
 
         try {
             val key = extractGeneratedKey(safeAlias, level, retries)
 
             val result = CipherStorage.EncryptionResult(
-                encryptString(key, username), encryptString(key, password), this
+                encryptString(key, username),
+                encryptString(key, password),
+                this
             )
             handler.onEncrypt(result, null)
         } catch (e: GeneralSecurityException) {
@@ -121,14 +124,16 @@ class CipherStorageKeystoreAesCbc(reactContext: ReactApplicationContext) :
 
         throwIfInsufficientLevel(level)
 
-        val safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+        val defaultAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
         val retries = AtomicInteger(1)
 
         try {
-            val key = extractGeneratedKey(safeAlias, level, retries)
+            val key = extractKeyWithMigration(defaultAlias, PREFIX_AES_CBC, handler, level, retries)
 
             val results = CipherStorage.DecryptionResult(
-                decryptBytes(key, username), decryptBytes(key, password), getSecurityLevel(key)
+                decryptBytes(key, username),
+                decryptBytes(key, password),
+                getSecurityLevel(key)
             )
             handler.onDecrypt(results, null)
         } catch (e: GeneralSecurityException) {
@@ -159,9 +164,10 @@ class CipherStorageKeystoreAesCbc(reactContext: ReactApplicationContext) :
             throw KeyStoreAccessException("Unsupported API${Build.VERSION.SDK_INT} version detected.")
         }
 
+        val safeAlias = getPrefixedAlias(alias, PREFIX_AES_CBC)
         val purposes = KeyProperties.PURPOSE_DECRYPT or KeyProperties.PURPOSE_ENCRYPT
 
-        return KeyGenParameterSpec.Builder(alias, purposes)
+        return KeyGenParameterSpec.Builder(safeAlias, purposes)
             .setBlockModes(BLOCK_MODE_CBC)
             .setEncryptionPaddings(PADDING_PKCS7)
             .setRandomizedEncryptionRequired(true)
@@ -206,7 +212,7 @@ class CipherStorageKeystoreAesCbc(reactContext: ReactApplicationContext) :
         bytes: ByteArray,
         handler: DecryptBytesHandler?
     ): String {
-        val cipher = getCachedInstance()
+        val cipher = getCipher()
 
         return try {
             // read the initialization vector from bytes array
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt
index dc4e616..1a3f01d 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreAesGcm.kt
@@ -27,7 +27,10 @@ import javax.crypto.SecretKeyFactory
 import javax.crypto.spec.GCMParameterSpec
 
 @TargetApi(Build.VERSION_CODES.M)
-class CipherStorageKeystoreAesGcm(reactContext: ReactApplicationContext, private val requiresBiometricAuth: Boolean) :
+class CipherStorageKeystoreAesGcm(
+    reactContext: ReactApplicationContext,
+    private val requiresBiometricAuth: Boolean
+) :
     CipherStorageBase(reactContext) {
 
     // region Constants
@@ -86,7 +89,8 @@ class CipherStorageKeystoreAesGcm(reactContext: ReactApplicationContext, private
 
         throwIfInsufficientLevel(level)
 
-        val safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+        val defaultAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+        val safeAlias = getPrefixedAuthAlias(defaultAlias) 
         val retries = AtomicInteger(1)
         var key: Key? = null
 
@@ -124,12 +128,13 @@ class CipherStorageKeystoreAesGcm(reactContext: ReactApplicationContext, private
     ) {
         throwIfInsufficientLevel(level)
 
-        val safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+        val defaultAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+        val prefix = if (requiresAuth) PREFIX_AES_GCM else PREFIX_AES_GCM_NO_AUTH
         val retries = AtomicInteger(1)
         var key: Key? = null
 
         try {
-            key = extractGeneratedKey(safeAlias, level, retries)
+            key = extractKeyWithMigration(defaultAlias, prefix, handler, level, retries)
             val results =
                 CipherStorage.DecryptionResult(
                     decryptBytes(key, username),
@@ -140,8 +145,13 @@ class CipherStorageKeystoreAesGcm(reactContext: ReactApplicationContext, private
         } catch (ex: UserNotAuthenticatedException) {
             Log.d(LOG_TAG, "Unlock of keystore is needed. Error: ${ex.message}", ex)
             // expected that KEY instance is extracted and we caught exception on decryptBytes operation
-            val context =
-                CryptoContext(safeAlias, key!!, password, username, CryptoOperation.DECRYPT)
+            val context = CryptoContext(
+                getPrefixedAlias(defaultAlias, prefix), 
+                key!!,
+                password,
+                username,
+                CryptoOperation.DECRYPT
+            )
 
             handler.askAccessPermissions(context)
         } catch (fail: Throwable) {
@@ -173,9 +183,10 @@ class CipherStorageKeystoreAesGcm(reactContext: ReactApplicationContext, private
 
         val purposes = KeyProperties.PURPOSE_DECRYPT or KeyProperties.PURPOSE_ENCRYPT
 
-        val validityDuration = 5
+        val validityDuration = 1
+        val safeAlias = getPrefixedAuthAlias(alias)
         val keyGenParameterSpecBuilder =
-            KeyGenParameterSpec.Builder(alias, purposes)
+            KeyGenParameterSpec.Builder(safeAlias, purposes)
                 .setBlockModes(BLOCK_MODE_GCM)
                 .setEncryptionPaddings(PADDING_NONE)
                 .setRandomizedEncryptionRequired(true)
@@ -243,7 +254,10 @@ class CipherStorageKeystoreAesGcm(reactContext: ReactApplicationContext, private
         val encrypt = EncryptStringHandler { cipher, key, output ->
             cipher.init(Cipher.ENCRYPT_MODE, key)
             val iv = cipher.iv
-            output.write(iv, 0, iv.size)
+            if (iv.size != IV_LENGTH) {
+                throw CryptoFailedException("IV length mismatch: expected ${IV_LENGTH}, got ${iv.size}")
+            }
+          output.write(iv, 0, iv.size)
         }
 
         /** Read initialization vector from input stream and configure cipher by it. */
@@ -267,4 +281,13 @@ class CipherStorageKeystoreAesGcm(reactContext: ReactApplicationContext, private
         decryptBytes(key, bytes, IV.decrypt)
 
     // endregion
+
+    // region Alias Helpers
+
+    private fun getPrefixedAuthAlias(alias: String): String {
+        val prefix = if (requiresAuth) PREFIX_AES_GCM else PREFIX_AES_GCM_NO_AUTH
+        return getPrefixedAlias(alias, prefix)
+    }
+
+    // endregion
 }
diff --git a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt
index f4f69d3..dbc23ac 100644
--- a/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt
+++ b/node_modules/react-native-keychain/android/src/main/java/com/oblador/keychain/cipherStorage/CipherStorageKeystoreRsaEcb.kt
@@ -63,7 +63,8 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
   ) {
     throwIfInsufficientLevel(level)
 
-    val safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+    val defaultAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
+    val safeAlias = getPrefixedAlias(defaultAlias, PREFIX_RSA)
     val retries = AtomicInteger(1)
     try {
       extractGeneratedKey(safeAlias, level, retries)
@@ -106,13 +107,18 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
   ) {
     throwIfInsufficientLevel(level)
 
+
     val safeAlias = getDefaultAliasIfEmpty(alias, getDefaultAliasServiceName())
     val retries = AtomicInteger(1)
     var key: Key? = null
 
     try {
-      // key is always NOT NULL otherwise GeneralSecurityException raised
-      key = extractGeneratedKey(safeAlias, level, retries)
+      // key is always NOT NULL otherwise GeneralSecurityException is thrown
+      key = extractKeyWithMigration(safeAlias, PREFIX_RSA, handler, level, retries)
+      val results = CipherStorage.DecryptionResult(
+          decryptBytes(key, username),
+          decryptBytes(key, password)
+      )
 
       val results =
         CipherStorage.DecryptionResult(decryptBytes(key, username), decryptBytes(key, password))
@@ -121,8 +127,14 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
     } catch (ex: UserNotAuthenticatedException) {
       Log.d(LOG_TAG, "Unlock of keystore is needed. Error: ${ex.message}", ex)
 
-      // expected that KEY instance is extracted and we caught exception on decryptBytes operation
-      val context = CryptoContext(safeAlias, key!!, password, username, CryptoOperation.DECRYPT)
+      // expected that KEY instance is extracted and we caught expection on decrtptBytes operation
+      val context = CryptoContext(
+        getPrefixedAlias(safeAlias, PREFIX_RSA), 
+        key!!,
+        password,
+        username,
+        CryptoOperation.DECRYPT
+      )
 
       handler.askAccessPermissions(context)
     } catch (fail: Throwable) {
@@ -159,8 +171,9 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
     val keyStore = getKeyStoreAndLoad()
 
     // Retrieve the certificate after ensuring the key is compatible
-    val certificate = keyStore.getCertificate(alias)
-      ?: throw GeneralSecurityException("Certificate is null for alias $alias")
+    val prefixedAlias = getPrefixedAlias(alias, PREFIX_RSA)
+    val certificate = keyStore.getCertificate(prefixedAlias)
+        ?: throw GeneralSecurityException("Certificate is null for alias $prefixedAlias")
 
     val publicKey = certificate.publicKey
     val kf = KeyFactory.getInstance(ALGORITHM_RSA)
@@ -190,13 +203,14 @@ class CipherStorageKeystoreRsaEcb(reactContext: ReactApplicationContext) :
       throw KeyStoreAccessException("Unsupported API${Build.VERSION.SDK_INT} version detected.")
     }
 
+    val safeAlias = getPrefixedAlias(alias, PREFIX_RSA)
     val purposes = KeyProperties.PURPOSE_DECRYPT or KeyProperties.PURPOSE_ENCRYPT
 
     val keySize = if (isForTesting) ENCRYPTION_KEY_SIZE_WHEN_TESTING else ENCRYPTION_KEY_SIZE
 
-    val validityDuration = 5
+    val validityDuration = 1
     val keyGenParameterSpecBuilder =
-      KeyGenParameterSpec.Builder(alias, purposes)
+      KeyGenParameterSpec.Builder(safeAlias, purposes)
         .setBlockModes(BLOCK_MODE_ECB)
         .setEncryptionPaddings(PADDING_PKCS1)
         .setRandomizedEncryptionRequired(true)
diff --git a/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m b/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m
index 18e42ab..7bc2d7a 100644
--- a/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m
+++ b/node_modules/react-native-keychain/ios/RNKeychainManager/RNKeychainManager.m
@@ -586,6 +586,86 @@ RCT_EXPORT_METHOD(getInternetCredentialsForServer:(NSString *)server
 
 }
 
+RCT_EXPORT_METHOD(getAllInternetCredentialsForServer:(NSDictionary *)options resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
+{
+  NSDictionary *query = @{
+    (__bridge NSString *)kSecClass: (__bridge id)(kSecClassInternetPassword),
+    (__bridge NSString *)kSecReturnAttributes: (__bridge id)kCFBooleanTrue,
+    (__bridge NSString *)kSecReturnData: (__bridge id)kCFBooleanTrue,
+    (__bridge NSString *)kSecMatchLimit: (__bridge NSString *)kSecMatchLimitAll
+  };
+
+  // Look up server in the keychain
+  NSArray *found = nil;
+  CFTypeRef foundTypeRef = NULL;
+  OSStatus osStatus = SecItemCopyMatching((__bridge CFDictionaryRef) query, (CFTypeRef*)&foundTypeRef);
+
+  if (osStatus != noErr && osStatus != errSecItemNotFound) {
+    NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:osStatus userInfo:nil];
+    return rejectWithError(reject, error);
+  }
+
+  found = (__bridge NSArray*)(foundTypeRef);
+  if (!found) {
+    return resolve(@(NO));
+  }
+
+  NSMutableArray *results = [@[] mutableCopy];
+
+  for(int i=0; i< found.count; i++){
+      NSDictionary *item  = found[i];
+      NSString *server = (NSString *) [item objectForKey:(__bridge id)(kSecAttrServer)];
+      NSString *username = (NSString *) [item objectForKey:(__bridge id)(kSecAttrAccount)];
+        NSString *password = [[NSString alloc] initWithData:[item objectForKey:(__bridge id)(kSecValueData)] encoding:NSUTF8StringEncoding];
+
+        [results addObject:@{@"username": username, @"password":password, @"server": server}];
+  }
+
+  CFRelease(foundTypeRef);
+
+  return resolve(@{
+    @"results": results
+  });
+}
+
+RCT_EXPORT_METHOD(getAllInternetCredentialsKeys:(NSDictionary *)options resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
+{
+  NSDictionary *query = @{
+    (__bridge NSString *)kSecClass: (__bridge id)(kSecClassInternetPassword),
+    (__bridge NSString *)kSecReturnAttributes: (__bridge id)kCFBooleanTrue,
+    (__bridge NSString *)kSecMatchLimit: (__bridge NSString *)kSecMatchLimitAll
+  };
+
+  // Look up all the keys in the keychain
+  NSArray *found = nil;
+  CFTypeRef foundTypeRef = NULL;
+  OSStatus osStatus = SecItemCopyMatching((__bridge CFDictionaryRef) query, (CFTypeRef*)&foundTypeRef);
+
+  if (osStatus != noErr && osStatus != errSecItemNotFound) {
+    NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:osStatus userInfo:nil];
+    return rejectWithError(reject, error);
+  }
+
+  found = (__bridge NSArray*)(foundTypeRef);
+  if (!found) {
+    return resolve(@(NO));
+  }
+
+  NSMutableArray *results = [@[] mutableCopy];
+
+  for(int i=0; i< found.count; i++){
+      NSDictionary *item  = found[i];
+      NSString *username = (NSString *) [item objectForKey:(__bridge id)(kSecAttrAccount)];
+      [results addObject:username];
+  }
+
+  CFRelease(foundTypeRef);
+
+  return resolve(@{
+    @"results": results
+  });
+}
+
 RCT_EXPORT_METHOD(resetInternetCredentialsForOptions:(NSDictionary *)options
                   resolver:(RCTPromiseResolveBlock)resolve
                   rejecter:(RCTPromiseRejectBlock)reject)
diff --git a/node_modules/react-native-keychain/lib/commonjs/index.js b/node_modules/react-native-keychain/lib/commonjs/index.js
index 38a73d5..dfa9875 100644
--- a/node_modules/react-native-keychain/lib/commonjs/index.js
+++ b/node_modules/react-native-keychain/lib/commonjs/index.js
@@ -12,6 +12,8 @@ var _exportNames = {
   hasInternetCredentials: true,
   setInternetCredentials: true,
   getInternetCredentials: true,
+  getAllInternetCredentials: true,
+  getAllInternetCredentialsKeys: true,
   resetInternetCredentials: true,
   getSupportedBiometryType: true,
   requestSharedWebCredentials: true,
@@ -24,6 +26,8 @@ exports.default = void 0;
 exports.getAllGenericPasswordServices = getAllGenericPasswordServices;
 exports.getGenericPassword = getGenericPassword;
 exports.getInternetCredentials = getInternetCredentials;
+exports.getAllInternetCredentials = getAllInternetCredentials;
+exports.getAllInternetCredentialsKeys = getAllInternetCredentialsKeys;
 exports.getSecurityLevel = getSecurityLevel;
 exports.getSupportedBiometryType = getSupportedBiometryType;
 exports.hasGenericPassword = hasGenericPassword;
@@ -215,6 +219,24 @@ function getInternetCredentials(server, options) {
   return RNKeychainManager.getInternetCredentialsForServer(server, (0, _normalizeOptions.normalizeOptions)(options));
 }
 
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+function getAllInternetCredentials(options) {
+  return RNKeychainManager.getAllInternetCredentialsForServer(normalizeOptions(options));
+}
+
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+function getAllInternetCredentialsKeys(options) {
+  return RNKeychainManager.getAllInternetCredentialsKeys(normalizeOptions(options));
+}
+
 /**
  * Deletes all internet password keychain entries for the given server.
  *
@@ -356,6 +378,8 @@ var _default = exports.default = {
   getSupportedBiometryType,
   setInternetCredentials,
   getInternetCredentials,
+  getAllInternetCredentials,
+  getAllInternetCredentialsKeys,
   resetInternetCredentials,
   setGenericPassword,
   getGenericPassword,
diff --git a/node_modules/react-native-keychain/lib/module/index.js b/node_modules/react-native-keychain/lib/module/index.js
index 9374201..71ba7f2 100644
--- a/node_modules/react-native-keychain/lib/module/index.js
+++ b/node_modules/react-native-keychain/lib/module/index.js
@@ -158,6 +158,24 @@ export function getInternetCredentials(server, options) {
   return RNKeychainManager.getInternetCredentialsForServer(server, normalizeOptions(options));
 }
 
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+export function getAllInternetCredentials(options) {
+  return RNKeychainManager.getAllInternetCredentialsForServer(normalizeOptions(options));
+}
+
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+export function getAllInternetCredentialsKeys(options) {
+  return RNKeychainManager.getAllInternetCredentialsKeys(normalizeOptions(options));
+}
+
 /**
  * Deletes all internet password keychain entries for the given server.
  *
diff --git a/node_modules/react-native-keychain/lib/typescript/index.d.ts b/node_modules/react-native-keychain/lib/typescript/index.d.ts
index 43f2e2f..772ee23 100644
--- a/node_modules/react-native-keychain/lib/typescript/index.d.ts
+++ b/node_modules/react-native-keychain/lib/typescript/index.d.ts
@@ -1,5 +1,5 @@
 import { ACCESSIBLE, ACCESS_CONTROL, AUTHENTICATION_TYPE, SECURITY_LEVEL, SECURITY_RULES, STORAGE_TYPE, BIOMETRY_TYPE } from './enums';
-import type { Result, UserCredentials, SharedWebCredentials, GetOptions, BaseOptions, SetOptions, AuthenticationTypeOption, AccessControlOption } from './types';
+import type { Result, UserCredentials, SharedWebCredentials, GetOptions, BaseOptions, SetOptions, AuthenticationTypeOption, AccessControlOption, AllCredentials, AllCredentialsKeys } from './types';
 /**
  * Saves the `username` and `password` combination for the given service.
  *
@@ -122,6 +122,18 @@ export declare function setInternetCredentials(server: string, username: string,
  * ```
  */
 export declare function getInternetCredentials(server: string, options?: GetOptions): Promise<false | UserCredentials>;
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+export declare function getAllInternetCredentials(options?: GetOptions): Promise<false | AllCredentials>;
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+export declare function getAllInternetCredentialsKeys(options?: GetOptions): Promise<false | AllCredentialsKeys>;
 /**
  * Deletes all internet password keychain entries for the given server.
  *
diff --git a/node_modules/react-native-keychain/lib/typescript/types.d.ts b/node_modules/react-native-keychain/lib/typescript/types.d.ts
index 565554a..c292223 100644
--- a/node_modules/react-native-keychain/lib/typescript/types.d.ts
+++ b/node_modules/react-native-keychain/lib/typescript/types.d.ts
@@ -112,6 +112,21 @@ export type UserCredentials = {
     /** The password associated with the keychain item. */
     password: string;
 } & Result;
+
+/**
+ * All credentials returned by keychain functions.
+ */
+export type AllCredentials = {
+    results: UserCredentials[];
+};
+
+/**
+ * All credentials keys returned by keychain functions.
+ */
+export type AllCredentialsKeys = {
+    results: string[];
+};
+
 /**
  * Shared web credentials returned by keychain functions.
  * @platform iOS
diff --git a/node_modules/react-native-keychain/src/index.ts b/node_modules/react-native-keychain/src/index.ts
index 7bfe371..782a0b2 100644
--- a/node_modules/react-native-keychain/src/index.ts
+++ b/node_modules/react-native-keychain/src/index.ts
@@ -17,6 +17,8 @@ import type {
   SetOptions,
   AuthenticationTypeOption,
   AccessControlOption,
+  AllCredentials,
+  AllCredentialsKeys,
 } from './types';
 import {
   normalizeOptions,
@@ -209,6 +211,32 @@ export function getInternetCredentials(
   );
 }
 
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[{ server, username, password }, ...]` when successful
+ */
+export function getAllInternetCredentials(
+  options?: GetOptions
+): Promise<false | AllCredentials> {
+  return RNKeychainManager.getAllInternetCredentialsForServer(
+    normalizeOptions(options)
+  );
+}
+
+/**
+ * Fetches all the keychain entries for the app
+ * @param {object} options Keychain options, iOS only
+ * @return {Promise} Resolves to `[username]` when successful
+ */
+export function getAllInternetCredentialsKeys(
+  options?: GetOptions
+): Promise<false | AllCredentialsKeys> {
+  return RNKeychainManager.getAllInternetCredentialsKeys(
+    normalizeOptions(options)
+  );
+}
+
 /**
  * Deletes all internet password keychain entries for the given server.
  *
@@ -378,6 +406,8 @@ export default {
   getSupportedBiometryType,
   setInternetCredentials,
   getInternetCredentials,
+  getAllInternetCredentials,
+  getAllInternetCredentialsKeys,
   resetInternetCredentials,
   setGenericPassword,
   getGenericPassword,
diff --git a/node_modules/react-native-keychain/src/types.ts b/node_modules/react-native-keychain/src/types.ts
index 2c27bb4..f1719e3 100644
--- a/node_modules/react-native-keychain/src/types.ts
+++ b/node_modules/react-native-keychain/src/types.ts
@@ -120,6 +120,20 @@ export type Result = {
   storage: STORAGE_TYPE;
 };
 
+/**
+ * All credentials returned by keychain functions.
+ */
+export type AllCredentials = {
+  results: UserCredentials[];
+};
+
+/**
+ * All credentials keys returned by keychain functions.
+ */
+export type AllCredentialsKeys = {
+  results: string[];
+};
+
 /**
  * User credentials returned by keychain functions.
  */
